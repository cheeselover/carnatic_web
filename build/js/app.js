(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
    return fromTypedArray(that, object)
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = String(string)

  if (string.length === 0) return 0

  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      return string.length
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return string.length * 2
    case 'hex':
      return string.length >>> 1
    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(string).length
    case 'base64':
      return base64ToBytes(string).length
    default:
      return string.length
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/process/browser.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/main.js":[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';
/*eslint-disable no-undef*/
var visitors = require('./vendor/fbtransform/visitors');
var transform = require('jstransform').transform;
var typesSyntax = require('jstransform/visitors/type-syntax');
var inlineSourceMap = require('./vendor/inline-source-map');

var visitReactTag = require('./vendor/fbtransform/transforms/react').visitorList[0];

var slice = Array.prototype.slice;

function partial(func) {
  var partialArgs = slice.call(arguments, 1);
  return function() {
    return func.apply(this, partialArgs.concat(slice.call(arguments)));
  };
}

function extend(dest, src) {
  if (src != null) {
    Object.keys(src).forEach(function(prop) {
      dest[prop] = src[prop];
    });
  }
  return dest;
}

module.exports = {
  transform: function(input, options) {
    options = processOptions(options);
    var output = innerTransform(input, options);
    var result = output.code;
    if (options.sourceMap) {
      var map = inlineSourceMap(
        output.sourceMap,
        input,
        options.filename
      );
      result += '\n' + map;
    }
    return result;
  },
  transformWithDetails: function(input, options) {
    options = processOptions(options);
    var output = innerTransform(input, options);
    var result = {};
    result.code = output.code;
    if (options.sourceMap) {
      result.sourceMap = output.sourceMap.toJSON();
    }
    if (options.filename) {
      result.sourceMap.sources = [options.filename];
    }
    return result;
  }
};

/**
 * Only copy the values that we need. We'll do some preprocessing to account for
 * converting command line flags to options that jstransform can actually use.
 */
function processOptions(opts) {
  opts = extend({precompile: true}, opts);
  var options = {};

  options.harmony = opts.harmony;
  options.stripTypes = opts.stripTypes;
  options.sourceMap = opts.sourceMap;
  options.filename = opts.sourceFilename;
  options.precompile = opts.precompile;

  if (opts.es6module) {
    options.sourceType = 'module';
  }
  if (opts.nonStrictEs6module) {
    options.sourceType = 'nonStrictModule';
  }

  // Instead of doing any fancy validation, only look for 'es3'. If we have
  // that, then use it. Otherwise use 'es5'.
  options.es3 = opts.target === 'es3';
  options.es5 = !options.es3;

  return options;
}

function innerTransform(input, options) {
  var visitorSets = ['react'];
  if (options.harmony) {
    visitorSets.push('harmony');
  }

  if (options.es3) {
    visitorSets.push('es3');
  }

  if (options.stripTypes) {
    // Stripping types needs to happen before the other transforms
    // unfortunately, due to bad interactions. For example,
    // es6-rest-param-visitors conflict with stripping rest param type
    // annotation
    input = transform(typesSyntax.visitorList, input, options).code;
  }

  var visitorList = visitors.getVisitorsBySet(visitorSets);

  // Patch the react tag visitor to preconfigure the MSX precompile argument
  for (var i = 0; i < visitorList.length ; i++) {
    var visitor = visitorList[i];
    if (visitor === visitReactTag) {
      visitorList[i] = partial(visitor, options.precompile);
      visitorList[i].test = visitor.test;
    }
  }

  return transform(visitorList, input, options);
}

},{"./vendor/fbtransform/transforms/react":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/transforms/react.js","./vendor/fbtransform/visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/visitors.js","./vendor/inline-source-map":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/inline-source-map.js","jstransform":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/jstransform.js","jstransform/visitors/type-syntax":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/type-syntax.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/base62/base62.js":[function(require,module,exports){
var Base62 = (function (my) {
  my.chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

  my.encode = function(i){
    if (i === 0) {return '0'}
    var s = ''
    while (i > 0) {
      s = this.chars[i % 62] + s
      i = Math.floor(i/62)
    }
    return s
  };
  my.decode = function(a,b,c,d){
    for (
      b = c = (
        a === (/\W|_|^$/.test(a += "") || a)
      ) - 1;
      d = a.charCodeAt(c++);
    )
    b = b * 62 + d - [, 48, 29, 87][d >> 5];
    return b
  };

  return my;
}({}));

module.exports = Base62
},{}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js":[function(require,module,exports){
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        SyntaxTreeDelegate,
        XHTMLEntities,
        ClassPropertyType,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        delegate,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10,
        JSXIdentifier: 11,
        JSXText: 12
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.JSXIdentifier] = 'JSXIdentifier';
    TokenName[Token.JSXText] = 'JSXText';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AnyTypeAnnotation: 'AnyTypeAnnotation',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrayTypeAnnotation: 'ArrayTypeAnnotation',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AssignmentExpression: 'AssignmentExpression',
        BinaryExpression: 'BinaryExpression',
        BlockStatement: 'BlockStatement',
        BooleanTypeAnnotation: 'BooleanTypeAnnotation',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ClassImplements: 'ClassImplements',
        ClassProperty: 'ClassProperty',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DeclareClass: 'DeclareClass',
        DeclareFunction: 'DeclareFunction',
        DeclareModule: 'DeclareModule',
        DeclareVariable: 'DeclareVariable',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportDeclaration: 'ExportDeclaration',
        ExportBatchSpecifier: 'ExportBatchSpecifier',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        ForStatement: 'ForStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        FunctionTypeAnnotation: 'FunctionTypeAnnotation',
        FunctionTypeParam: 'FunctionTypeParam',
        GenericTypeAnnotation: 'GenericTypeAnnotation',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        InterfaceDeclaration: 'InterfaceDeclaration',
        InterfaceExtends: 'InterfaceExtends',
        IntersectionTypeAnnotation: 'IntersectionTypeAnnotation',
        LabeledStatement: 'LabeledStatement',
        Literal: 'Literal',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        NullableTypeAnnotation: 'NullableTypeAnnotation',
        NumberTypeAnnotation: 'NumberTypeAnnotation',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        ObjectTypeAnnotation: 'ObjectTypeAnnotation',
        ObjectTypeCallProperty: 'ObjectTypeCallProperty',
        ObjectTypeIndexer: 'ObjectTypeIndexer',
        ObjectTypeProperty: 'ObjectTypeProperty',
        Program: 'Program',
        Property: 'Property',
        QualifiedTypeIdentifier: 'QualifiedTypeIdentifier',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SpreadProperty: 'SpreadProperty',
        StringLiteralTypeAnnotation: 'StringLiteralTypeAnnotation',
        StringTypeAnnotation: 'StringTypeAnnotation',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TupleTypeAnnotation: 'TupleTypeAnnotation',
        TryStatement: 'TryStatement',
        TypeAlias: 'TypeAlias',
        TypeAnnotation: 'TypeAnnotation',
        TypeCastExpression: 'TypeCastExpression',
        TypeofTypeAnnotation: 'TypeofTypeAnnotation',
        TypeParameterDeclaration: 'TypeParameterDeclaration',
        TypeParameterInstantiation: 'TypeParameterInstantiation',
        UnaryExpression: 'UnaryExpression',
        UnionTypeAnnotation: 'UnionTypeAnnotation',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        VoidTypeAnnotation: 'VoidTypeAnnotation',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        JSXIdentifier: 'JSXIdentifier',
        JSXNamespacedName: 'JSXNamespacedName',
        JSXMemberExpression: 'JSXMemberExpression',
        JSXEmptyExpression: 'JSXEmptyExpression',
        JSXExpressionContainer: 'JSXExpressionContainer',
        JSXElement: 'JSXElement',
        JSXClosingElement: 'JSXClosingElement',
        JSXOpeningElement: 'JSXOpeningElement',
        JSXAttribute: 'JSXAttribute',
        JSXSpreadAttribute: 'JSXSpreadAttribute',
        JSXText: 'JSXText',
        YieldExpression: 'YieldExpression',
        AwaitExpression: 'AwaitExpression'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    ClassPropertyType = {
        'static': 'static',
        prototype: 'prototype'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInFormalsList: 'Invalid left-hand side in formals list',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',
        IllegalClassConstructorProperty: 'Illegal constructor property in class definition',
        IllegalReturn: 'Illegal return statement',
        IllegalSpread: 'Illegal spread element',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',
        DefaultRestParameter: 'Rest parameter can not have a default value',
        ElementAfterSpreadElement: 'Spread must be the final element of an element list',
        PropertyAfterSpreadProperty: 'A rest property must be the final property of an object literal',
        ObjectPatternAsRestParameter: 'Invalid rest parameter',
        ObjectPatternAsSpread: 'Invalid spread argument',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        MissingFromClause: 'Missing from clause',
        NoAsAfterImportNamespace: 'Missing as after import *',
        InvalidModuleSpecifier: 'Invalid module specifier',
        IllegalImportDeclaration: 'Illegal import declaration',
        IllegalExportDeclaration: 'Illegal export declaration',
        NoUninitializedConst: 'Const must be initialized',
        ComprehensionRequiresBlock: 'Comprehension must have at least one block',
        ComprehensionError: 'Comprehension Error',
        EachNotAllowed: 'Each is not supported',
        InvalidJSXAttributeValue: 'JSX value should be either an expression or a quoted JSX text',
        ExpectedJSXClosingTag: 'Expected corresponding JSX closing tag for %0',
        AdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag',
        ConfusedAboutFunctionType: 'Unexpected token =>. It looks like ' +
            'you are trying to write a function type, but you ended up ' +
            'writing a grouped type followed by an =>, which is a syntax ' +
            'error. Remember, function type parameters are named so function ' +
            'types look like (name1: type1, name2: type2) => returnType. You ' +
            'probably wrote (type1) => returnType'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        LeadingZeros: new RegExp('^0+(?!$)')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function StringMap() {
        this.$data = {};
    }

    StringMap.prototype.get = function (key) {
        key = '$' + key;
        return this.$data[key];
    };

    StringMap.prototype.set = function (key, value) {
        key = '$' + key;
        this.$data[key] = value;
        return this;
    };

    StringMap.prototype.has = function (key) {
        key = '$' + key;
        return Object.prototype.hasOwnProperty.call(this.$data, key);
    };

    StringMap.prototype.delete = function (key) {
        key = '$' + key;
        return delete this.$data[key];
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 32) ||  // space
            (ch === 9) ||      // tab
            (ch === 0xB) ||
            (ch === 0xC) ||
            (ch === 0xA0) ||
            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' is only treated as a keyword in strict mode.
        // 'let' is for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;
        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment() {
        var start, loc, ch, comment;

        start = index - 2;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - 2
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + 2, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + 2, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else if (ch === 42) {
                // Block comment ends with '*/' (char #42, char #47).
                if (source.charCodeAt(index + 1) === 47) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function skipComment() {
        var ch;

        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else if (ch === 47) { // 47 is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 47) {
                    ++index;
                    ++index;
                    skipSingleLineComment();
                } else if (ch === 42) {  // 42 is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        // UTF-16 Encoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (char #92, char #117) denotes an escaped character.
        if (ch === 92) {
            if (source.charCodeAt(index) !== 117) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (char #92, char #117) denotes an escaped character.
            if (ch === 92) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 117) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 92) {
                // Blackslash (char #92) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (char #92) starts an escaped character.
        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        if (state.inJSXTag || state.inJSXChild) {
            // Don't need to check for '{' and '}' as it's already handled
            // correctly by default.
            switch (code) {
            case 60:  // <
            case 62:  // >
                ++index;
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        switch (code) {
        // Check for most common single-character punctuators.
        case 40:   // ( open bracket
        case 41:   // ) close bracket
        case 59:   // ; semicolon
        case 44:   // , comma
        case 123:  // { open curly brace
        case 125:  // } close curly brace
        case 91:   // [
        case 93:   // ]
        case 58:   // :
        case 63:   // ?
        case 126:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 40) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 123) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (char #61) marks an assignment or comparison operator.
            if (code2 === 61) {
                switch (code) {
                case 37:  // %
                case 38:  // &
                case 42:  // *:
                case 43:  // +
                case 45:  // -
                case 47:  // /
                case 60:  // <
                case 62:  // >
                case 94:  // ^
                case 124: // |
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };

                case 33: // !
                case 61: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 61) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                default:
                    break;
                }
            }
            break;
        }

        // Peek more characters.

        ch2 = source[index + 1];
        ch3 = source[index + 2];
        ch4 = source[index + 3];

        // 4-character punctuator: >>>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            if (ch4 === '=') {
                index += 4;
                return {
                    type: Token.Punctuator,
                    value: '>>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // 3-character punctuators: === !== >>> <<= >>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>' && !state.inType) {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '<<=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '...',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||

        // Don't match these tokens if we're in a type, since they never can
        // occur and can mess up types like Map<string, Array<string>>
        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0) && !state.inType) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '=' && ch2 === '>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: '=>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '.') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {
                    return scanOctalLiteral(ch, start);
                }
                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            /* istanbul ignore else */
                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanTemplate() {
        var cooked = '', ch, start, terminated, tail, restore, unescaped, code, octal;

        terminated = false;
        tail = false;
        start = index;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            /* istanbul ignore else */
                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            cooked += String.fromCharCode(code);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === '\r' && source[index] === '\n') {
                    ++index;
                }
                lineStart = index;
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - ((tail) ? 1 : 2))
            },
            tail: tail,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanTemplateElement(option) {
        var startsWith, template;

        lookahead = null;
        skipComment();

        startsWith = (option.head) ? '`' : '}';

        if (source[index] !== startsWith) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        template = scanTemplate();

        peek();

        return template;
    }

    function testRegExp(pattern, flags) {
        var tmp = pattern,
            value;

        if (flags.indexOf('u') >= 0) {
            // Replace each astral symbol and every Unicode code point
            // escape sequence with a single ASCII symbol to avoid throwing on
            // regular expressions that are only valid in combination with the
            // `/u` flag.
            // Note: replacing with the ASCII symbol `x` might cause false
            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
            // perfectly valid pattern that is equivalent to `[a-b]`, but it
            // would be replaced by `[x-b]` which throws an error.
            tmp = tmp
                .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                    if (parseInt($1, 16) <= 0x10FFFF) {
                        return 'x';
                    }
                    throwError({}, Messages.InvalidRegExp);
                })
                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
        }

        // First, detect invalid regular expressions.
        try {
            value = new RegExp(tmp);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError({}, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                } else {
                    str += '\\';
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);

        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return scanRegExp();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return scanRegExp();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return scanRegExp();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return scanRegExp();
            }
            return scanRegExp();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
            return scanRegExp();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        if (!state.inJSXChild) {
            skipComment();
        }

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        if (state.inJSXChild) {
            return advanceJSXChild();
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            if (state.inJSXTag) {
                return scanJSXStringLiteral();
            }
            return scanStringLiteral();
        }

        if (state.inJSXTag && isJSXIdentifierStart(ch)) {
            return scanJSXIdentifier();
        }

        if (ch === 96) {
            return scanTemplate();
        }
        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) char #47 can also start a regex.
        if (extra.tokenize && ch === 47) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = advance();

        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function lookahead2() {
        var adv, pos, line, start, result;

        // If we are collecting the tokens, don't grab the next one yet.
        /* istanbul ignore next */
        adv = (typeof extra.advance === 'function') ? extra.advance : advance;

        pos = index;
        line = lineNumber;
        start = lineStart;

        // Scan for the next immediate token.
        /* istanbul ignore if */
        if (lookahead === null) {
            lookahead = adv();
        }
        index = lookahead.range[1];
        lineNumber = lookahead.lineNumber;
        lineStart = lookahead.lineStart;

        // Grab the token right after.
        result = adv();
        index = pos;
        lineNumber = line;
        lineStart = start;

        return result;
    }

    function rewind(token) {
        index = token.range[0];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        lookahead = token;
    }

    function markerCreate() {
        if (!extra.loc && !extra.range) {
            return undefined;
        }
        skipComment();
        return {offset: index, line: lineNumber, col: index - lineStart};
    }

    function markerCreatePreserveWhitespace() {
        if (!extra.loc && !extra.range) {
            return undefined;
        }
        return {offset: index, line: lineNumber, col: index - lineStart};
    }

    function processComment(node) {
        var lastChild,
            trailingComments,
            bottomRight = extra.bottomRightStack,
            last = bottomRight[bottomRight.length - 1];

        if (node.type === Syntax.Program) {
            /* istanbul ignore else */
            if (node.body.length > 0) {
                return;
            }
        }

        if (extra.trailingComments.length > 0) {
            if (extra.trailingComments[0].range[0] >= node.range[1]) {
                trailingComments = extra.trailingComments;
                extra.trailingComments = [];
            } else {
                extra.trailingComments.length = 0;
            }
        } else {
            if (last && last.trailingComments && last.trailingComments[0].range[0] >= node.range[1]) {
                trailingComments = last.trailingComments;
                delete last.trailingComments;
            }
        }

        // Eating the stack.
        if (last) {
            while (last && last.range[0] >= node.range[0]) {
                lastChild = last;
                last = bottomRight.pop();
            }
        }

        if (lastChild) {
            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
                node.leadingComments = lastChild.leadingComments;
                delete lastChild.leadingComments;
            }
        } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
            node.leadingComments = extra.leadingComments;
            extra.leadingComments = [];
        }

        if (trailingComments) {
            node.trailingComments = trailingComments;
        }

        bottomRight.push(node);
    }

    function markerApply(marker, node) {
        if (extra.range) {
            node.range = [marker.offset, index];
        }
        if (extra.loc) {
            node.loc = {
                start: {
                    line: marker.line,
                    column: marker.col
                },
                end: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
            node = delegate.postProcess(node);
        }
        if (extra.attachComment) {
            processComment(node);
        }
        return node;
    }

    SyntaxTreeDelegate = {

        name: 'SyntaxTree',

        postProcess: function (node) {
            return node;
        },

        createArrayExpression: function (elements) {
            return {
                type: Syntax.ArrayExpression,
                elements: elements
            };
        },

        createAssignmentExpression: function (operator, left, right) {
            return {
                type: Syntax.AssignmentExpression,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBinaryExpression: function (operator, left, right) {
            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
                        Syntax.BinaryExpression;
            return {
                type: type,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBlockStatement: function (body) {
            return {
                type: Syntax.BlockStatement,
                body: body
            };
        },

        createBreakStatement: function (label) {
            return {
                type: Syntax.BreakStatement,
                label: label
            };
        },

        createCallExpression: function (callee, args) {
            return {
                type: Syntax.CallExpression,
                callee: callee,
                'arguments': args
            };
        },

        createCatchClause: function (param, body) {
            return {
                type: Syntax.CatchClause,
                param: param,
                body: body
            };
        },

        createConditionalExpression: function (test, consequent, alternate) {
            return {
                type: Syntax.ConditionalExpression,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createContinueStatement: function (label) {
            return {
                type: Syntax.ContinueStatement,
                label: label
            };
        },

        createDebuggerStatement: function () {
            return {
                type: Syntax.DebuggerStatement
            };
        },

        createDoWhileStatement: function (body, test) {
            return {
                type: Syntax.DoWhileStatement,
                body: body,
                test: test
            };
        },

        createEmptyStatement: function () {
            return {
                type: Syntax.EmptyStatement
            };
        },

        createExpressionStatement: function (expression) {
            return {
                type: Syntax.ExpressionStatement,
                expression: expression
            };
        },

        createForStatement: function (init, test, update, body) {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        },

        createForInStatement: function (left, right, body) {
            return {
                type: Syntax.ForInStatement,
                left: left,
                right: right,
                body: body,
                each: false
            };
        },

        createForOfStatement: function (left, right, body) {
            return {
                type: Syntax.ForOfStatement,
                left: left,
                right: right,
                body: body
            };
        },

        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression,
                                             isAsync, returnType, typeParameters) {
            var funDecl = {
                type: Syntax.FunctionDeclaration,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: rest,
                generator: generator,
                expression: expression,
                returnType: returnType,
                typeParameters: typeParameters
            };

            if (isAsync) {
                funDecl.async = true;
            }

            return funDecl;
        },

        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression,
                                            isAsync, returnType, typeParameters) {
            var funExpr = {
                type: Syntax.FunctionExpression,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: rest,
                generator: generator,
                expression: expression,
                returnType: returnType,
                typeParameters: typeParameters
            };

            if (isAsync) {
                funExpr.async = true;
            }

            return funExpr;
        },

        createIdentifier: function (name) {
            return {
                type: Syntax.Identifier,
                name: name,
                // Only here to initialize the shape of the object to ensure
                // that the 'typeAnnotation' key is ordered before others that
                // are added later (like 'loc' and 'range'). This just helps
                // keep the shape of Identifier nodes consistent with everything
                // else.
                typeAnnotation: undefined,
                optional: undefined
            };
        },

        createTypeAnnotation: function (typeAnnotation) {
            return {
                type: Syntax.TypeAnnotation,
                typeAnnotation: typeAnnotation
            };
        },

        createTypeCast: function (expression, typeAnnotation) {
            return {
                type: Syntax.TypeCastExpression,
                expression: expression,
                typeAnnotation: typeAnnotation
            };
        },

        createFunctionTypeAnnotation: function (params, returnType, rest, typeParameters) {
            return {
                type: Syntax.FunctionTypeAnnotation,
                params: params,
                returnType: returnType,
                rest: rest,
                typeParameters: typeParameters
            };
        },

        createFunctionTypeParam: function (name, typeAnnotation, optional) {
            return {
                type: Syntax.FunctionTypeParam,
                name: name,
                typeAnnotation: typeAnnotation,
                optional: optional
            };
        },

        createNullableTypeAnnotation: function (typeAnnotation) {
            return {
                type: Syntax.NullableTypeAnnotation,
                typeAnnotation: typeAnnotation
            };
        },

        createArrayTypeAnnotation: function (elementType) {
            return {
                type: Syntax.ArrayTypeAnnotation,
                elementType: elementType
            };
        },

        createGenericTypeAnnotation: function (id, typeParameters) {
            return {
                type: Syntax.GenericTypeAnnotation,
                id: id,
                typeParameters: typeParameters
            };
        },

        createQualifiedTypeIdentifier: function (qualification, id) {
            return {
                type: Syntax.QualifiedTypeIdentifier,
                qualification: qualification,
                id: id
            };
        },

        createTypeParameterDeclaration: function (params) {
            return {
                type: Syntax.TypeParameterDeclaration,
                params: params
            };
        },

        createTypeParameterInstantiation: function (params) {
            return {
                type: Syntax.TypeParameterInstantiation,
                params: params
            };
        },

        createAnyTypeAnnotation: function () {
            return {
                type: Syntax.AnyTypeAnnotation
            };
        },

        createBooleanTypeAnnotation: function () {
            return {
                type: Syntax.BooleanTypeAnnotation
            };
        },

        createNumberTypeAnnotation: function () {
            return {
                type: Syntax.NumberTypeAnnotation
            };
        },

        createStringTypeAnnotation: function () {
            return {
                type: Syntax.StringTypeAnnotation
            };
        },

        createStringLiteralTypeAnnotation: function (token) {
            return {
                type: Syntax.StringLiteralTypeAnnotation,
                value: token.value,
                raw: source.slice(token.range[0], token.range[1])
            };
        },

        createVoidTypeAnnotation: function () {
            return {
                type: Syntax.VoidTypeAnnotation
            };
        },

        createTypeofTypeAnnotation: function (argument) {
            return {
                type: Syntax.TypeofTypeAnnotation,
                argument: argument
            };
        },

        createTupleTypeAnnotation: function (types) {
            return {
                type: Syntax.TupleTypeAnnotation,
                types: types
            };
        },

        createObjectTypeAnnotation: function (properties, indexers, callProperties) {
            return {
                type: Syntax.ObjectTypeAnnotation,
                properties: properties,
                indexers: indexers,
                callProperties: callProperties
            };
        },

        createObjectTypeIndexer: function (id, key, value, isStatic) {
            return {
                type: Syntax.ObjectTypeIndexer,
                id: id,
                key: key,
                value: value,
                static: isStatic
            };
        },

        createObjectTypeCallProperty: function (value, isStatic) {
            return {
                type: Syntax.ObjectTypeCallProperty,
                value: value,
                static: isStatic
            };
        },

        createObjectTypeProperty: function (key, value, optional, isStatic) {
            return {
                type: Syntax.ObjectTypeProperty,
                key: key,
                value: value,
                optional: optional,
                static: isStatic
            };
        },

        createUnionTypeAnnotation: function (types) {
            return {
                type: Syntax.UnionTypeAnnotation,
                types: types
            };
        },

        createIntersectionTypeAnnotation: function (types) {
            return {
                type: Syntax.IntersectionTypeAnnotation,
                types: types
            };
        },

        createTypeAlias: function (id, typeParameters, right) {
            return {
                type: Syntax.TypeAlias,
                id: id,
                typeParameters: typeParameters,
                right: right
            };
        },

        createInterface: function (id, typeParameters, body, extended) {
            return {
                type: Syntax.InterfaceDeclaration,
                id: id,
                typeParameters: typeParameters,
                body: body,
                extends: extended
            };
        },

        createInterfaceExtends: function (id, typeParameters) {
            return {
                type: Syntax.InterfaceExtends,
                id: id,
                typeParameters: typeParameters
            };
        },

        createDeclareFunction: function (id) {
            return {
                type: Syntax.DeclareFunction,
                id: id
            };
        },

        createDeclareVariable: function (id) {
            return {
                type: Syntax.DeclareVariable,
                id: id
            };
        },

        createDeclareModule: function (id, body) {
            return {
                type: Syntax.DeclareModule,
                id: id,
                body: body
            };
        },

        createJSXAttribute: function (name, value) {
            return {
                type: Syntax.JSXAttribute,
                name: name,
                value: value || null
            };
        },

        createJSXSpreadAttribute: function (argument) {
            return {
                type: Syntax.JSXSpreadAttribute,
                argument: argument
            };
        },

        createJSXIdentifier: function (name) {
            return {
                type: Syntax.JSXIdentifier,
                name: name
            };
        },

        createJSXNamespacedName: function (namespace, name) {
            return {
                type: Syntax.JSXNamespacedName,
                namespace: namespace,
                name: name
            };
        },

        createJSXMemberExpression: function (object, property) {
            return {
                type: Syntax.JSXMemberExpression,
                object: object,
                property: property
            };
        },

        createJSXElement: function (openingElement, closingElement, children) {
            return {
                type: Syntax.JSXElement,
                openingElement: openingElement,
                closingElement: closingElement,
                children: children
            };
        },

        createJSXEmptyExpression: function () {
            return {
                type: Syntax.JSXEmptyExpression
            };
        },

        createJSXExpressionContainer: function (expression) {
            return {
                type: Syntax.JSXExpressionContainer,
                expression: expression
            };
        },

        createJSXOpeningElement: function (name, attributes, selfClosing) {
            return {
                type: Syntax.JSXOpeningElement,
                name: name,
                selfClosing: selfClosing,
                attributes: attributes
            };
        },

        createJSXClosingElement: function (name) {
            return {
                type: Syntax.JSXClosingElement,
                name: name
            };
        },

        createIfStatement: function (test, consequent, alternate) {
            return {
                type: Syntax.IfStatement,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createLabeledStatement: function (label, body) {
            return {
                type: Syntax.LabeledStatement,
                label: label,
                body: body
            };
        },

        createLiteral: function (token) {
            var object = {
                type: Syntax.Literal,
                value: token.value,
                raw: source.slice(token.range[0], token.range[1])
            };
            if (token.regex) {
                object.regex = token.regex;
            }
            return object;
        },

        createMemberExpression: function (accessor, object, property) {
            return {
                type: Syntax.MemberExpression,
                computed: accessor === '[',
                object: object,
                property: property
            };
        },

        createNewExpression: function (callee, args) {
            return {
                type: Syntax.NewExpression,
                callee: callee,
                'arguments': args
            };
        },

        createObjectExpression: function (properties) {
            return {
                type: Syntax.ObjectExpression,
                properties: properties
            };
        },

        createPostfixExpression: function (operator, argument) {
            return {
                type: Syntax.UpdateExpression,
                operator: operator,
                argument: argument,
                prefix: false
            };
        },

        createProgram: function (body) {
            return {
                type: Syntax.Program,
                body: body
            };
        },

        createProperty: function (kind, key, value, method, shorthand, computed) {
            return {
                type: Syntax.Property,
                key: key,
                value: value,
                kind: kind,
                method: method,
                shorthand: shorthand,
                computed: computed
            };
        },

        createReturnStatement: function (argument) {
            return {
                type: Syntax.ReturnStatement,
                argument: argument
            };
        },

        createSequenceExpression: function (expressions) {
            return {
                type: Syntax.SequenceExpression,
                expressions: expressions
            };
        },

        createSwitchCase: function (test, consequent) {
            return {
                type: Syntax.SwitchCase,
                test: test,
                consequent: consequent
            };
        },

        createSwitchStatement: function (discriminant, cases) {
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        },

        createThisExpression: function () {
            return {
                type: Syntax.ThisExpression
            };
        },

        createThrowStatement: function (argument) {
            return {
                type: Syntax.ThrowStatement,
                argument: argument
            };
        },

        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            return {
                type: Syntax.TryStatement,
                block: block,
                guardedHandlers: guardedHandlers,
                handlers: handlers,
                finalizer: finalizer
            };
        },

        createUnaryExpression: function (operator, argument) {
            if (operator === '++' || operator === '--') {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            }
            return {
                type: Syntax.UnaryExpression,
                operator: operator,
                argument: argument,
                prefix: true
            };
        },

        createVariableDeclaration: function (declarations, kind) {
            return {
                type: Syntax.VariableDeclaration,
                declarations: declarations,
                kind: kind
            };
        },

        createVariableDeclarator: function (id, init) {
            return {
                type: Syntax.VariableDeclarator,
                id: id,
                init: init
            };
        },

        createWhileStatement: function (test, body) {
            return {
                type: Syntax.WhileStatement,
                test: test,
                body: body
            };
        },

        createWithStatement: function (object, body) {
            return {
                type: Syntax.WithStatement,
                object: object,
                body: body
            };
        },

        createTemplateElement: function (value, tail) {
            return {
                type: Syntax.TemplateElement,
                value: value,
                tail: tail
            };
        },

        createTemplateLiteral: function (quasis, expressions) {
            return {
                type: Syntax.TemplateLiteral,
                quasis: quasis,
                expressions: expressions
            };
        },

        createSpreadElement: function (argument) {
            return {
                type: Syntax.SpreadElement,
                argument: argument
            };
        },

        createSpreadProperty: function (argument) {
            return {
                type: Syntax.SpreadProperty,
                argument: argument
            };
        },

        createTaggedTemplateExpression: function (tag, quasi) {
            return {
                type: Syntax.TaggedTemplateExpression,
                tag: tag,
                quasi: quasi
            };
        },

        createArrowFunctionExpression: function (params, defaults, body, rest, expression, isAsync) {
            var arrowExpr = {
                type: Syntax.ArrowFunctionExpression,
                id: null,
                params: params,
                defaults: defaults,
                body: body,
                rest: rest,
                generator: false,
                expression: expression
            };

            if (isAsync) {
                arrowExpr.async = true;
            }

            return arrowExpr;
        },

        createMethodDefinition: function (propertyType, kind, key, value, computed) {
            return {
                type: Syntax.MethodDefinition,
                key: key,
                value: value,
                kind: kind,
                'static': propertyType === ClassPropertyType.static,
                computed: computed
            };
        },

        createClassProperty: function (key, typeAnnotation, computed, isStatic) {
            return {
                type: Syntax.ClassProperty,
                key: key,
                typeAnnotation: typeAnnotation,
                computed: computed,
                static: isStatic
            };
        },

        createClassBody: function (body) {
            return {
                type: Syntax.ClassBody,
                body: body
            };
        },

        createClassImplements: function (id, typeParameters) {
            return {
                type: Syntax.ClassImplements,
                id: id,
                typeParameters: typeParameters
            };
        },

        createClassExpression: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {
            return {
                type: Syntax.ClassExpression,
                id: id,
                superClass: superClass,
                body: body,
                typeParameters: typeParameters,
                superTypeParameters: superTypeParameters,
                implements: implemented
            };
        },

        createClassDeclaration: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {
            return {
                type: Syntax.ClassDeclaration,
                id: id,
                superClass: superClass,
                body: body,
                typeParameters: typeParameters,
                superTypeParameters: superTypeParameters,
                implements: implemented
            };
        },

        createModuleSpecifier: function (token) {
            return {
                type: Syntax.ModuleSpecifier,
                value: token.value,
                raw: source.slice(token.range[0], token.range[1])
            };
        },

        createExportSpecifier: function (id, name) {
            return {
                type: Syntax.ExportSpecifier,
                id: id,
                name: name
            };
        },

        createExportBatchSpecifier: function () {
            return {
                type: Syntax.ExportBatchSpecifier
            };
        },

        createImportDefaultSpecifier: function (id) {
            return {
                type: Syntax.ImportDefaultSpecifier,
                id: id
            };
        },

        createImportNamespaceSpecifier: function (id) {
            return {
                type: Syntax.ImportNamespaceSpecifier,
                id: id
            };
        },

        createExportDeclaration: function (isDefault, declaration, specifiers, src) {
            return {
                type: Syntax.ExportDeclaration,
                'default': !!isDefault,
                declaration: declaration,
                specifiers: specifiers,
                source: src
            };
        },

        createImportSpecifier: function (id, name) {
            return {
                type: Syntax.ImportSpecifier,
                id: id,
                name: name
            };
        },

        createImportDeclaration: function (specifiers, src, isType) {
            return {
                type: Syntax.ImportDeclaration,
                specifiers: specifiers,
                source: src,
                isType: isType
            };
        },

        createYieldExpression: function (argument, dlg) {
            return {
                type: Syntax.YieldExpression,
                argument: argument,
                delegate: dlg
            };
        },

        createAwaitExpression: function (argument) {
            return {
                type: Syntax.AwaitExpression,
                argument: argument
            };
        },

        createComprehensionExpression: function (filter, blocks, body) {
            return {
                type: Syntax.ComprehensionExpression,
                filter: filter,
                blocks: blocks,
                body: body
            };
        }

    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, idx) {
                    assert(idx < args.length, 'Message reference must be in range');
                    return args[idx];
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.range[0];
            error.lineNumber = token.lineNumber;
            error.column = token.range[0] - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        error.description = msg;
        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral || token.type === Token.JSXText) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        if (token.type === Token.Template) {
            throwError(token, Messages.UnexpectedTemplate, token.value.raw);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword, contextual) {
        var token = lex();
        if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||
                token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified contextual keyword.
    // If not, an exception will be thrown.

    function expectContextualKeyword(keyword) {
        return expectKeyword(keyword, true);
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword, contextual) {
        var expectedType = contextual ? Token.Identifier : Token.Keyword;
        return lookahead.type === expectedType && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword

    function matchContextualKeyword(keyword) {
        return matchKeyword(keyword, true);
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    // Note that 'yield' is treated as a keyword in strict mode, but a
    // contextual keyword (identifier) in non-strict mode, so we need to
    // use matchKeyword('yield', false) and matchKeyword('yield', true)
    // (i.e. matchContextualKeyword) appropriately.
    function matchYield() {
        return state.yieldAllowed && matchKeyword('yield', !strict);
    }

    function matchAsync() {
        var backtrackToken = lookahead, matches = false;

        if (matchContextualKeyword('async')) {
            lex(); // Make sure peekLineTerminator() starts after 'async'.
            matches = !peekLineTerminator();
            rewind(backtrackToken); // Revert the lex().
        }

        return matches;
    }

    function matchAwait() {
        return state.awaitAllowed && matchContextualKeyword('await');
    }

    function consumeSemicolon() {
        var line, oldIndex = index, oldLineNumber = lineNumber,
            oldLineStart = lineStart, oldLookahead = lookahead;

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            index = oldIndex;
            lineNumber = oldLineNumber;
            lineStart = oldLineStart;
            lookahead = oldLookahead;
            return;
        }

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    function isAssignableLeftHandSide(expr) {
        return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true,
            marker = markerCreate();

        expect('[');
        while (!match(']')) {
            if (lookahead.value === 'for' &&
                    lookahead.type === Token.Keyword) {
                if (!possiblecomprehension) {
                    throwError({}, Messages.ComprehensionError);
                }
                matchKeyword('for');
                tmp = parseForStatement({ignoreBody: true});
                tmp.of = tmp.type === Syntax.ForOfStatement;
                tmp.type = Syntax.ComprehensionBlock;
                if (tmp.left.kind) { // can't be let or const
                    throwError({}, Messages.ComprehensionError);
                }
                blocks.push(tmp);
            } else if (lookahead.value === 'if' &&
                           lookahead.type === Token.Keyword) {
                if (!possiblecomprehension) {
                    throwError({}, Messages.ComprehensionError);
                }
                expectKeyword('if');
                expect('(');
                filter = parseExpression();
                expect(')');
            } else if (lookahead.value === ',' &&
                           lookahead.type === Token.Punctuator) {
                possiblecomprehension = false; // no longer allowed.
                lex();
                elements.push(null);
            } else {
                tmp = parseSpreadOrAssignmentExpression();
                elements.push(tmp);
                if (tmp && tmp.type === Syntax.SpreadElement) {
                    if (!match(']')) {
                        throwError({}, Messages.ElementAfterSpreadElement);
                    }
                } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {
                    expect(','); // this lexes.
                    possiblecomprehension = false;
                }
            }
        }

        expect(']');

        if (filter && !blocks.length) {
            throwError({}, Messages.ComprehensionRequiresBlock);
        }

        if (blocks.length) {
            if (elements.length !== 1) {
                throwError({}, Messages.ComprehensionError);
            }
            return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));
        }
        return markerApply(marker, delegate.createArrayExpression(elements));
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(options) {
        var previousStrict, previousYieldAllowed, previousAwaitAllowed,
            params, defaults, body, marker = markerCreate();

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = options.generator;
        previousAwaitAllowed = state.awaitAllowed;
        state.awaitAllowed = options.async;
        params = options.params || [];
        defaults = options.defaults || [];

        body = parseConciseBody();
        if (options.name && strict && isRestrictedWord(params[0].name)) {
            throwErrorTolerant(options.name, Messages.StrictParamName);
        }
        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;
        state.awaitAllowed = previousAwaitAllowed;

        return markerApply(marker, delegate.createFunctionExpression(
            null,
            params,
            defaults,
            body,
            options.rest || null,
            options.generator,
            body.type !== Syntax.BlockStatement,
            options.async,
            options.returnType,
            options.typeParameters
        ));
    }


    function parsePropertyMethodFunction(options) {
        var previousStrict, tmp, method;

        previousStrict = strict;
        strict = true;

        tmp = parseParams();

        if (tmp.stricted) {
            throwErrorTolerant(tmp.stricted, tmp.message);
        }

        method = parsePropertyFunction({
            params: tmp.params,
            defaults: tmp.defaults,
            rest: tmp.rest,
            generator: options.generator,
            async: options.async,
            returnType: tmp.returnType,
            typeParameters: options.typeParameters
        });

        strict = previousStrict;

        return method;
    }


    function parseObjectPropertyKey() {
        var marker = markerCreate(),
            token = lex(),
            propertyKey,
            result;

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return markerApply(marker, delegate.createLiteral(token));
        }

        if (token.type === Token.Punctuator && token.value === '[') {
            // For computed properties we should skip the [ and ], and
            // capture in marker only the assignment expression itself.
            marker = markerCreate();
            propertyKey = parseAssignmentExpression();
            result = markerApply(marker, propertyKey);
            expect(']');
            return result;
        }

        return markerApply(marker, delegate.createIdentifier(token.value));
    }

    function parseObjectProperty() {
        var token, key, id, param, computed,
            marker = markerCreate(), returnType, typeParameters;

        token = lookahead;
        computed = (token.value === '[' && token.type === Token.Punctuator);

        if (token.type === Token.Identifier || computed || matchAsync()) {
            id = parseObjectPropertyKey();

            if (match(':')) {
                lex();

                return markerApply(
                    marker,
                    delegate.createProperty(
                        'init',
                        id,
                        parseAssignmentExpression(),
                        false,
                        false,
                        computed
                    )
                );
            }

            if (match('(') || match('<')) {
                if (match('<')) {
                    typeParameters = parseTypeParameterDeclaration();
                }
                return markerApply(
                    marker,
                    delegate.createProperty(
                        'init',
                        id,
                        parsePropertyMethodFunction({
                            generator: false,
                            async: false,
                            typeParameters: typeParameters
                        }),
                        true,
                        false,
                        computed
                    )
                );
            }

            // Property Assignment: Getter and Setter.

            if (token.value === 'get') {
                computed = (lookahead.value === '[');
                key = parseObjectPropertyKey();

                expect('(');
                expect(')');
                if (match(':')) {
                    returnType = parseTypeAnnotation();
                }

                return markerApply(
                    marker,
                    delegate.createProperty(
                        'get',
                        key,
                        parsePropertyFunction({
                            generator: false,
                            async: false,
                            returnType: returnType
                        }),
                        false,
                        false,
                        computed
                    )
                );
            }

            if (token.value === 'set') {
                computed = (lookahead.value === '[');
                key = parseObjectPropertyKey();

                expect('(');
                token = lookahead;
                param = [ parseTypeAnnotatableIdentifier() ];
                expect(')');
                if (match(':')) {
                    returnType = parseTypeAnnotation();
                }

                return markerApply(
                    marker,
                    delegate.createProperty(
                        'set',
                        key,
                        parsePropertyFunction({
                            params: param,
                            generator: false,
                            async: false,
                            name: token,
                            returnType: returnType
                        }),
                        false,
                        false,
                        computed
                    )
                );
            }

            if (token.value === 'async') {
                computed = (lookahead.value === '[');
                key = parseObjectPropertyKey();

                if (match('<')) {
                    typeParameters = parseTypeParameterDeclaration();
                }

                return markerApply(
                    marker,
                    delegate.createProperty(
                        'init',
                        key,
                        parsePropertyMethodFunction({
                            generator: false,
                            async: true,
                            typeParameters: typeParameters
                        }),
                        true,
                        false,
                        computed
                    )
                );
            }

            if (computed) {
                // Computed properties can only be used with full notation.
                throwUnexpected(lookahead);
            }

            return markerApply(
                marker,
                delegate.createProperty('init', id, id, false, true, false)
            );
        }

        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            if (!match('*')) {
                throwUnexpected(token);
            }
            lex();

            computed = (lookahead.type === Token.Punctuator && lookahead.value === '[');

            id = parseObjectPropertyKey();

            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }

            if (!match('(')) {
                throwUnexpected(lex());
            }

            return markerApply(marker, delegate.createProperty(
                'init',
                id,
                parsePropertyMethodFunction({
                    generator: true,
                    typeParameters: typeParameters
                }),
                true,
                false,
                computed
            ));
        }
        key = parseObjectPropertyKey();
        if (match(':')) {
            lex();
            return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));
        }
        if (match('(') || match('<')) {
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
            return markerApply(marker, delegate.createProperty(
                'init',
                key,
                parsePropertyMethodFunction({
                    generator: false,
                    typeParameters: typeParameters
                }),
                true,
                false,
                false
            ));
        }
        throwUnexpected(lex());
    }

    function parseObjectSpreadProperty() {
        var marker = markerCreate();
        expect('...');
        return markerApply(marker, delegate.createSpreadProperty(parseAssignmentExpression()));
    }

    function getFieldName(key) {
        var toString = String;
        if (key.type === Syntax.Identifier) {
            return key.name;
        }
        return toString(key.value);
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, kind, storedKind, map = new StringMap(),
            marker = markerCreate(), toString = String;

        expect('{');

        while (!match('}')) {
            if (match('...')) {
                property = parseObjectSpreadProperty();
            } else {
                property = parseObjectProperty();

                if (property.key.type === Syntax.Identifier) {
                    name = property.key.name;
                } else {
                    name = toString(property.key.value);
                }
                kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

                if (map.has(name)) {
                    storedKind = map.get(name);
                    if (storedKind === PropertyKind.Data) {
                        if (strict && kind === PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                        } else if (kind !== PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.AccessorDataProperty);
                        }
                    } else {
                        if (kind === PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.AccessorDataProperty);
                        } else if (storedKind & kind) {
                            throwErrorTolerant({}, Messages.AccessorGetSet);
                        }
                    }
                    map.set(name, storedKind | kind);
                } else {
                    map.set(name, kind);
                }
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return markerApply(marker, delegate.createObjectExpression(properties));
    }

    function parseTemplateElement(option) {
        var marker = markerCreate(),
            token = scanTemplateElement(option);
        if (strict && token.octal) {
            throwError(token, Messages.StrictOctalLiteral);
        }
        return markerApply(marker, delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail));
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, marker = markerCreate();

        quasi = parseTemplateElement({ head: true });
        quasis = [ quasi ];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr, marker, typeAnnotation;

        expect('(');

        ++state.parenthesizedCount;

        marker = markerCreate();

        expr = parseExpression();

        if (match(':')) {
            typeAnnotation = parseTypeAnnotation();
            expr = markerApply(marker, delegate.createTypeCast(
                expr,
                typeAnnotation
            ));
        }

        expect(')');

        return expr;
    }

    function matchAsyncFuncExprOrDecl() {
        var token;

        if (matchAsync()) {
            token = lookahead2();
            if (token.type === Token.Keyword && token.value === 'function') {
                return true;
            }
        }

        return false;
    }

    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var marker, type, token, expr;

        type = lookahead.type;

        if (type === Token.Identifier) {
            marker = markerCreate();
            return markerApply(marker, delegate.createIdentifier(lex().value));
        }

        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            marker = markerCreate();
            return markerApply(marker, delegate.createLiteral(lex()));
        }

        if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                marker = markerCreate();
                lex();
                return markerApply(marker, delegate.createThisExpression());
            }

            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }

            if (matchKeyword('class')) {
                return parseClassExpression();
            }

            if (matchKeyword('super')) {
                marker = markerCreate();
                lex();
                return markerApply(marker, delegate.createIdentifier('super'));
            }
        }

        if (type === Token.BooleanLiteral) {
            marker = markerCreate();
            token = lex();
            token.value = (token.value === 'true');
            return markerApply(marker, delegate.createLiteral(token));
        }

        if (type === Token.NullLiteral) {
            marker = markerCreate();
            token = lex();
            token.value = null;
            return markerApply(marker, delegate.createLiteral(token));
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('/') || match('/=')) {
            marker = markerCreate();
            expr = delegate.createLiteral(scanRegExp());
            peek();
            return markerApply(marker, expr);
        }

        if (type === Token.Template) {
            return parseTemplateLiteral();
        }

        if (match('<')) {
            return parseJSXElement();
        }

        throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [], arg;

        expect('(');

        if (!match(')')) {
            while (index < length) {
                arg = parseSpreadOrAssignmentExpression();
                args.push(arg);

                if (match(')')) {
                    break;
                } else if (arg.type === Syntax.SpreadElement) {
                    throwError({}, Messages.ElementAfterSpreadElement);
                }

                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseSpreadOrAssignmentExpression() {
        if (match('...')) {
            var marker = markerCreate();
            lex();
            return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));
        }
        return parseAssignmentExpression();
    }

    function parseNonComputedProperty() {
        var marker = markerCreate(),
            token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return markerApply(marker, delegate.createIdentifier(token.value));
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, marker = markerCreate();

        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return markerApply(marker, delegate.createNewExpression(callee, args));
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, marker = markerCreate();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {
            if (match('(')) {
                args = parseArguments();
                expr = markerApply(marker, delegate.createCallExpression(expr, args));
            } else if (match('[')) {
                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));
            } else if (match('.')) {
                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));
            } else {
                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
            }
        }

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, marker = markerCreate();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || lookahead.type === Token.Template) {
            if (match('[')) {
                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));
            } else if (match('.')) {
                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));
            } else {
                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var marker = markerCreate(),
            expr = parseLeftHandSideExpressionAllowCall(),
            token;

        if (lookahead.type !== Token.Punctuator) {
            return expr;
        }

        if ((match('++') || match('--')) && !peekLineTerminator()) {
            // 11.3.1, 11.3.2
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            token = lex();
            expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var marker, token, expr;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            return parsePostfixExpression();
        }

        if (match('++') || match('--')) {
            marker = markerCreate();
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
        }

        if (match('+') || match('-') || match('~') || match('!')) {
            marker = markerCreate();
            token = lex();
            expr = parseUnaryExpression();
            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
        }

        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            marker = markerCreate();
            token = lex();
            expr = parseUnaryExpression();
            expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
            return expr;
        }

        return parsePostfixExpression();
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var expr, token, prec, previousAllowIn, stack, right, operator, left, i,
            marker, markers;

        previousAllowIn = state.allowIn;
        state.allowIn = true;

        marker = markerCreate();
        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token, previousAllowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, markerCreate()];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                markers.pop();
                marker = markers.pop();
                markerApply(marker, expr);
                stack.push(expr);
                markers.push(marker);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(markerCreate());
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        state.allowIn = previousAllowIn;

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
            marker = markers.pop();
            markerApply(marker, expr);
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, marker = markerCreate();
        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));
        }

        return expr;
    }

    // 11.13 Assignment Operators

    // 12.14.5 AssignmentPattern

    function reinterpretAsAssignmentBindingPattern(expr) {
        var i, len, property, element;

        if (expr.type === Syntax.ObjectExpression) {
            expr.type = Syntax.ObjectPattern;
            for (i = 0, len = expr.properties.length; i < len; i += 1) {
                property = expr.properties[i];
                if (property.type === Syntax.SpreadProperty) {
                    if (i < len - 1) {
                        throwError({}, Messages.PropertyAfterSpreadProperty);
                    }
                    reinterpretAsAssignmentBindingPattern(property.argument);
                } else {
                    if (property.kind !== 'init') {
                        throwError({}, Messages.InvalidLHSInAssignment);
                    }
                    reinterpretAsAssignmentBindingPattern(property.value);
                }
            }
        } else if (expr.type === Syntax.ArrayExpression) {
            expr.type = Syntax.ArrayPattern;
            for (i = 0, len = expr.elements.length; i < len; i += 1) {
                element = expr.elements[i];
                /* istanbul ignore else */
                if (element) {
                    reinterpretAsAssignmentBindingPattern(element);
                }
            }
        } else if (expr.type === Syntax.Identifier) {
            if (isRestrictedWord(expr.name)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }
        } else if (expr.type === Syntax.SpreadElement) {
            reinterpretAsAssignmentBindingPattern(expr.argument);
            if (expr.argument.type === Syntax.ObjectPattern) {
                throwError({}, Messages.ObjectPatternAsSpread);
            }
        } else {
            /* istanbul ignore else */
            if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }
        }
    }

    // 13.2.3 BindingPattern

    function reinterpretAsDestructuredParameter(options, expr) {
        var i, len, property, element;

        if (expr.type === Syntax.ObjectExpression) {
            expr.type = Syntax.ObjectPattern;
            for (i = 0, len = expr.properties.length; i < len; i += 1) {
                property = expr.properties[i];
                if (property.type === Syntax.SpreadProperty) {
                    if (i < len - 1) {
                        throwError({}, Messages.PropertyAfterSpreadProperty);
                    }
                    reinterpretAsDestructuredParameter(options, property.argument);
                } else {
                    if (property.kind !== 'init') {
                        throwError({}, Messages.InvalidLHSInFormalsList);
                    }
                    reinterpretAsDestructuredParameter(options, property.value);
                }
            }
        } else if (expr.type === Syntax.ArrayExpression) {
            expr.type = Syntax.ArrayPattern;
            for (i = 0, len = expr.elements.length; i < len; i += 1) {
                element = expr.elements[i];
                if (element) {
                    reinterpretAsDestructuredParameter(options, element);
                }
            }
        } else if (expr.type === Syntax.Identifier) {
            validateParam(options, expr, expr.name);
        } else if (expr.type === Syntax.SpreadElement) {
            // BindingRestElement only allows BindingIdentifier
            if (expr.argument.type !== Syntax.Identifier) {
                throwError({}, Messages.InvalidLHSInFormalsList);
            }
            validateParam(options, expr.argument, expr.argument.name);
        } else {
            throwError({}, Messages.InvalidLHSInFormalsList);
        }
    }

    function reinterpretAsCoverFormalsList(expressions) {
        var i, len, param, params, defaults, defaultCount, options, rest;

        params = [];
        defaults = [];
        defaultCount = 0;
        rest = null;
        options = {
            paramSet: new StringMap()
        };

        for (i = 0, len = expressions.length; i < len; i += 1) {
            param = expressions[i];
            if (param.type === Syntax.Identifier) {
                params.push(param);
                defaults.push(null);
                validateParam(options, param, param.name);
            } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {
                reinterpretAsDestructuredParameter(options, param);
                params.push(param);
                defaults.push(null);
            } else if (param.type === Syntax.SpreadElement) {
                assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');
                if (param.argument.type !== Syntax.Identifier) {
                    throwError({}, Messages.InvalidLHSInFormalsList);
                }
                reinterpretAsDestructuredParameter(options, param.argument);
                rest = param.argument;
            } else if (param.type === Syntax.AssignmentExpression) {
                params.push(param.left);
                defaults.push(param.right);
                ++defaultCount;
                validateParam(options, param.left, param.left.name);
            } else {
                return null;
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            throwError(
                strict ? options.stricted : options.firstRestricted,
                options.message
            );
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            rest: rest,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, marker) {
        var previousStrict, previousYieldAllowed, previousAwaitAllowed, body;

        expect('=>');

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = false;
        previousAwaitAllowed = state.awaitAllowed;
        state.awaitAllowed = !!options.async;
        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwError(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            throwErrorTolerant(options.stricted, options.message);
        }

        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;
        state.awaitAllowed = previousAwaitAllowed;

        return markerApply(marker, delegate.createArrowFunctionExpression(
            options.params,
            options.defaults,
            body,
            options.rest,
            body.type !== Syntax.BlockStatement,
            !!options.async
        ));
    }

    function parseAssignmentExpression() {
        var marker, expr, token, params, oldParenthesizedCount,
            startsWithParen = false, backtrackToken = lookahead,
            possiblyAsync = false;

        if (matchYield()) {
            return parseYieldExpression();
        }

        if (matchAwait()) {
            return parseAwaitExpression();
        }

        oldParenthesizedCount = state.parenthesizedCount;

        marker = markerCreate();

        if (matchAsyncFuncExprOrDecl()) {
            return parseFunctionExpression();
        }

        if (matchAsync()) {
            // We can't be completely sure that this 'async' token is
            // actually a contextual keyword modifying a function
            // expression, so we might have to un-lex() it later by
            // calling rewind(backtrackToken).
            possiblyAsync = true;
            lex();
        }

        if (match('(')) {
            token = lookahead2();
            if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {
                params = parseParams();
                if (!match('=>')) {
                    throwUnexpected(lex());
                }
                params.async = possiblyAsync;
                return parseArrowFunctionExpression(params, marker);
            }
            startsWithParen = true;
        }

        token = lookahead;

        // If the 'async' keyword is not followed by a '(' character or an
        // identifier, then it can't be an arrow function modifier, and we
        // should interpret it as a normal identifer.
        if (possiblyAsync && !match('(') && token.type !== Token.Identifier) {
            possiblyAsync = false;
            rewind(backtrackToken);
        }

        expr = parseConditionalExpression();

        if (match('=>') &&
                (state.parenthesizedCount === oldParenthesizedCount ||
                state.parenthesizedCount === (oldParenthesizedCount + 1))) {
            if (expr.type === Syntax.Identifier) {
                params = reinterpretAsCoverFormalsList([ expr ]);
            } else if (expr.type === Syntax.AssignmentExpression ||
                    expr.type === Syntax.ArrayExpression ||
                    expr.type === Syntax.ObjectExpression) {
                if (!startsWithParen) {
                    throwUnexpected(lex());
                }
                params = reinterpretAsCoverFormalsList([ expr ]);
            } else if (expr.type === Syntax.SequenceExpression) {
                params = reinterpretAsCoverFormalsList(expr.expressions);
            }
            if (params) {
                params.async = possiblyAsync;
                return parseArrowFunctionExpression(params, marker);
            }
        }

        // If we haven't returned by now, then the 'async' keyword was not
        // a function modifier, and we should rewind and interpret it as a
        // normal identifier.
        if (possiblyAsync) {
            possiblyAsync = false;
            rewind(backtrackToken);
            expr = parseConditionalExpression();
        }

        if (matchAssign()) {
            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            // ES.next draf 11.13 Runtime Semantics step 1
            if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {
                reinterpretAsAssignmentBindingPattern(expr);
            } else if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var marker, expr, expressions, sequence, spreadFound;

        marker = markerCreate();
        expr = parseAssignmentExpression();
        expressions = [ expr ];

        if (match(',')) {
            while (index < length) {
                if (!match(',')) {
                    break;
                }

                lex();
                expr = parseSpreadOrAssignmentExpression();
                expressions.push(expr);

                if (expr.type === Syntax.SpreadElement) {
                    spreadFound = true;
                    if (!match(')')) {
                        throwError({}, Messages.ElementAfterSpreadElement);
                    }
                    break;
                }
            }

            sequence = markerApply(marker, delegate.createSequenceExpression(expressions));
        }

        if (spreadFound && lookahead2().value !== '=>') {
            throwError({}, Messages.IllegalSpread);
        }

        return sequence || expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block, marker = markerCreate();

        expect('{');

        block = parseStatementList();

        expect('}');

        return markerApply(marker, delegate.createBlockStatement(block));
    }

    // 12.2 Variable Statement

    function parseTypeParameterDeclaration() {
        var marker = markerCreate(), paramTypes = [];

        expect('<');
        while (!match('>')) {
            paramTypes.push(parseTypeAnnotatableIdentifier());
            if (!match('>')) {
                expect(',');
            }
        }
        expect('>');

        return markerApply(marker, delegate.createTypeParameterDeclaration(
            paramTypes
        ));
    }

    function parseTypeParameterInstantiation() {
        var marker = markerCreate(), oldInType = state.inType, paramTypes = [];

        state.inType = true;

        expect('<');
        while (!match('>')) {
            paramTypes.push(parseType());
            if (!match('>')) {
                expect(',');
            }
        }
        expect('>');

        state.inType = oldInType;

        return markerApply(marker, delegate.createTypeParameterInstantiation(
            paramTypes
        ));
    }

    function parseObjectTypeIndexer(marker, isStatic) {
        var id, key, value;

        expect('[');
        id = parseObjectPropertyKey();
        expect(':');
        key = parseType();
        expect(']');
        expect(':');
        value = parseType();

        return markerApply(marker, delegate.createObjectTypeIndexer(
            id,
            key,
            value,
            isStatic
        ));
    }

    function parseObjectTypeMethodish(marker) {
        var params = [], rest = null, returnType, typeParameters = null;
        if (match('<')) {
            typeParameters = parseTypeParameterDeclaration();
        }

        expect('(');
        while (lookahead.type === Token.Identifier) {
            params.push(parseFunctionTypeParam());
            if (!match(')')) {
                expect(',');
            }
        }

        if (match('...')) {
            lex();
            rest = parseFunctionTypeParam();
        }
        expect(')');
        expect(':');
        returnType = parseType();

        return markerApply(marker, delegate.createFunctionTypeAnnotation(
            params,
            returnType,
            rest,
            typeParameters
        ));
    }

    function parseObjectTypeMethod(marker, isStatic, key) {
        var optional = false, value;
        value = parseObjectTypeMethodish(marker);

        return markerApply(marker, delegate.createObjectTypeProperty(
            key,
            value,
            optional,
            isStatic
        ));
    }

    function parseObjectTypeCallProperty(marker, isStatic) {
        var valueMarker = markerCreate();
        return markerApply(marker, delegate.createObjectTypeCallProperty(
            parseObjectTypeMethodish(valueMarker),
            isStatic
        ));
    }

    function parseObjectType(allowStatic) {
        var callProperties = [], indexers = [], marker, optional = false,
            properties = [], propertyKey, propertyTypeAnnotation,
            token, isStatic, matchStatic;

        expect('{');

        while (!match('}')) {
            marker = markerCreate();
            matchStatic =
                   strict
                   ? matchKeyword('static')
                   : matchContextualKeyword('static');

            if (allowStatic && matchStatic) {
                token = lex();
                isStatic = true;
            }

            if (match('[')) {
                indexers.push(parseObjectTypeIndexer(marker, isStatic));
            } else if (match('(') || match('<')) {
                callProperties.push(parseObjectTypeCallProperty(marker, allowStatic));
            } else {
                if (isStatic && match(':')) {
                    propertyKey = markerApply(marker, delegate.createIdentifier(token));
                    throwErrorTolerant(token, Messages.StrictReservedWord);
                } else {
                    propertyKey = parseObjectPropertyKey();
                }
                if (match('<') || match('(')) {
                    // This is a method property
                    properties.push(parseObjectTypeMethod(marker, isStatic, propertyKey));
                } else {
                    if (match('?')) {
                        lex();
                        optional = true;
                    }
                    expect(':');
                    propertyTypeAnnotation = parseType();
                    properties.push(markerApply(marker, delegate.createObjectTypeProperty(
                        propertyKey,
                        propertyTypeAnnotation,
                        optional,
                        isStatic
                    )));
                }
            }

            if (match(';')) {
                lex();
            } else if (!match('}')) {
                throwUnexpected(lookahead);
            }
        }

        expect('}');

        return delegate.createObjectTypeAnnotation(
            properties,
            indexers,
            callProperties
        );
    }

    function parseGenericType() {
        var marker = markerCreate(),
            typeParameters = null, typeIdentifier;

        typeIdentifier = parseVariableIdentifier();

        while (match('.')) {
            expect('.');
            typeIdentifier = markerApply(marker, delegate.createQualifiedTypeIdentifier(
                typeIdentifier,
                parseVariableIdentifier()
            ));
        }

        if (match('<')) {
            typeParameters = parseTypeParameterInstantiation();
        }

        return markerApply(marker, delegate.createGenericTypeAnnotation(
            typeIdentifier,
            typeParameters
        ));
    }

    function parseVoidType() {
        var marker = markerCreate();
        expectKeyword('void');
        return markerApply(marker, delegate.createVoidTypeAnnotation());
    }

    function parseTypeofType() {
        var argument, marker = markerCreate();
        expectKeyword('typeof');
        argument = parsePrimaryType();
        return markerApply(marker, delegate.createTypeofTypeAnnotation(
            argument
        ));
    }

    function parseTupleType() {
        var marker = markerCreate(), types = [];
        expect('[');
        // We allow trailing commas
        while (index < length && !match(']')) {
            types.push(parseType());
            if (match(']')) {
                break;
            }
            expect(',');
        }
        expect(']');
        return markerApply(marker, delegate.createTupleTypeAnnotation(
            types
        ));
    }

    function parseFunctionTypeParam() {
        var marker = markerCreate(), name, optional = false, typeAnnotation;
        name = parseVariableIdentifier();
        if (match('?')) {
            lex();
            optional = true;
        }
        expect(':');
        typeAnnotation = parseType();
        return markerApply(marker, delegate.createFunctionTypeParam(
            name,
            typeAnnotation,
            optional
        ));
    }

    function parseFunctionTypeParams() {
        var ret = { params: [], rest: null };
        while (lookahead.type === Token.Identifier) {
            ret.params.push(parseFunctionTypeParam());
            if (!match(')')) {
                expect(',');
            }
        }

        if (match('...')) {
            lex();
            ret.rest = parseFunctionTypeParam();
        }
        return ret;
    }

    // The parsing of types roughly parallels the parsing of expressions, and
    // primary types are kind of like primary expressions...they're the
    // primitives with which other types are constructed.
    function parsePrimaryType() {
        var params = null, returnType = null,
            marker = markerCreate(), rest = null, tmp,
            typeParameters, token, type, isGroupedType = false;

        switch (lookahead.type) {
        case Token.Identifier:
            switch (lookahead.value) {
            case 'any':
                lex();
                return markerApply(marker, delegate.createAnyTypeAnnotation());
            case 'bool':  // fallthrough
            case 'boolean':
                lex();
                return markerApply(marker, delegate.createBooleanTypeAnnotation());
            case 'number':
                lex();
                return markerApply(marker, delegate.createNumberTypeAnnotation());
            case 'string':
                lex();
                return markerApply(marker, delegate.createStringTypeAnnotation());
            }
            return markerApply(marker, parseGenericType());
        case Token.Punctuator:
            switch (lookahead.value) {
            case '{':
                return markerApply(marker, parseObjectType());
            case '[':
                return parseTupleType();
            case '<':
                typeParameters = parseTypeParameterDeclaration();
                expect('(');
                tmp = parseFunctionTypeParams();
                params = tmp.params;
                rest = tmp.rest;
                expect(')');

                expect('=>');

                returnType = parseType();

                return markerApply(marker, delegate.createFunctionTypeAnnotation(
                    params,
                    returnType,
                    rest,
                    typeParameters
                ));
            case '(':
                lex();
                // Check to see if this is actually a grouped type
                if (!match(')') && !match('...')) {
                    if (lookahead.type === Token.Identifier) {
                        token = lookahead2();
                        isGroupedType = token.value !== '?' && token.value !== ':';
                    } else {
                        isGroupedType = true;
                    }
                }

                if (isGroupedType) {
                    type = parseType();
                    expect(')');

                    // If we see a => next then someone was probably confused about
                    // function types, so we can provide a better error message
                    if (match('=>')) {
                        throwError({}, Messages.ConfusedAboutFunctionType);
                    }

                    return type;
                }

                tmp = parseFunctionTypeParams();
                params = tmp.params;
                rest = tmp.rest;

                expect(')');

                expect('=>');

                returnType = parseType();

                return markerApply(marker, delegate.createFunctionTypeAnnotation(
                    params,
                    returnType,
                    rest,
                    null /* typeParameters */
                ));
            }
            break;
        case Token.Keyword:
            switch (lookahead.value) {
            case 'void':
                return markerApply(marker, parseVoidType());
            case 'typeof':
                return markerApply(marker, parseTypeofType());
            }
            break;
        case Token.StringLiteral:
            token = lex();
            if (token.octal) {
                throwError(token, Messages.StrictOctalLiteral);
            }
            return markerApply(marker, delegate.createStringLiteralTypeAnnotation(
                token
            ));
        }

        throwUnexpected(lookahead);
    }

    function parsePostfixType() {
        var marker = markerCreate(), t = parsePrimaryType();
        if (match('[')) {
            expect('[');
            expect(']');
            return markerApply(marker, delegate.createArrayTypeAnnotation(t));
        }
        return t;
    }

    function parsePrefixType() {
        var marker = markerCreate();
        if (match('?')) {
            lex();
            return markerApply(marker, delegate.createNullableTypeAnnotation(
                parsePrefixType()
            ));
        }
        return parsePostfixType();
    }


    function parseIntersectionType() {
        var marker = markerCreate(), type, types;
        type = parsePrefixType();
        types = [type];
        while (match('&')) {
            lex();
            types.push(parsePrefixType());
        }

        return types.length === 1 ?
                type :
                markerApply(marker, delegate.createIntersectionTypeAnnotation(
                    types
                ));
    }

    function parseUnionType() {
        var marker = markerCreate(), type, types;
        type = parseIntersectionType();
        types = [type];
        while (match('|')) {
            lex();
            types.push(parseIntersectionType());
        }
        return types.length === 1 ?
                type :
                markerApply(marker, delegate.createUnionTypeAnnotation(
                    types
                ));
    }

    function parseType() {
        var oldInType = state.inType, type;
        state.inType = true;

        type = parseUnionType();

        state.inType = oldInType;
        return type;
    }

    function parseTypeAnnotation() {
        var marker = markerCreate(), type;

        expect(':');
        type = parseType();

        return markerApply(marker, delegate.createTypeAnnotation(type));
    }

    function parseVariableIdentifier() {
        var marker = markerCreate(),
            token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return markerApply(marker, delegate.createIdentifier(token.value));
    }

    function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {
        var marker = markerCreate(),
            ident = parseVariableIdentifier(),
            isOptionalParam = false;

        if (canBeOptionalParam && match('?')) {
            expect('?');
            isOptionalParam = true;
        }

        if (requireTypeAnnotation || match(':')) {
            ident.typeAnnotation = parseTypeAnnotation();
            ident = markerApply(marker, ident);
        }

        if (isOptionalParam) {
            ident.optional = true;
            ident = markerApply(marker, ident);
        }

        return ident;
    }

    function parseVariableDeclaration(kind) {
        var id,
            marker = markerCreate(),
            init = null,
            typeAnnotationMarker = markerCreate();
        if (match('{')) {
            id = parseObjectInitialiser();
            reinterpretAsAssignmentBindingPattern(id);
            if (match(':')) {
                id.typeAnnotation = parseTypeAnnotation();
                markerApply(typeAnnotationMarker, id);
            }
        } else if (match('[')) {
            id = parseArrayInitialiser();
            reinterpretAsAssignmentBindingPattern(id);
            if (match(':')) {
                id.typeAnnotation = parseTypeAnnotation();
                markerApply(typeAnnotationMarker, id);
            }
        } else {
            /* istanbul ignore next */
            id = state.allowKeyword ? parseNonComputedProperty() : parseTypeAnnotatableIdentifier();
            // 12.2.1
            if (strict && isRestrictedWord(id.name)) {
                throwErrorTolerant({}, Messages.StrictVarName);
            }
        }

        if (kind === 'const') {
            if (!match('=')) {
                throwError({}, Messages.NoUninitializedConst);
            }
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return markerApply(marker, delegate.createVariableDeclarator(id, init));
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations, marker = markerCreate();

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, marker = markerCreate();

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));
    }

    // people.mozilla.org/~jorendorff/es6-draft.html

    function parseModuleSpecifier() {
        var marker = markerCreate(),
            specifier;

        if (lookahead.type !== Token.StringLiteral) {
            throwError({}, Messages.InvalidModuleSpecifier);
        }
        specifier = delegate.createModuleSpecifier(lookahead);
        lex();
        return markerApply(marker, specifier);
    }

    function parseExportBatchSpecifier() {
        var marker = markerCreate();
        expect('*');
        return markerApply(marker, delegate.createExportBatchSpecifier());
    }

    function parseExportSpecifier() {
        var id, name = null, marker = markerCreate(), from;
        if (matchKeyword('default')) {
            lex();
            id = markerApply(marker, delegate.createIdentifier('default'));
            // export {default} from "something";
        } else {
            id = parseVariableIdentifier();
        }
        if (matchContextualKeyword('as')) {
            lex();
            name = parseNonComputedProperty();
        }

        return markerApply(marker, delegate.createExportSpecifier(id, name));
    }

    function parseExportDeclaration() {
        var declaration = null,
            possibleIdentifierToken, sourceElement,
            isExportFromIdentifier,
            src = null, specifiers = [],
            marker = markerCreate();

        expectKeyword('export');

        if (matchKeyword('default')) {
            // covers:
            // export default ...
            lex();
            if (matchKeyword('function') || matchKeyword('class')) {
                possibleIdentifierToken = lookahead2();
                if (isIdentifierName(possibleIdentifierToken)) {
                    // covers:
                    // export default function foo () {}
                    // export default class foo {}
                    sourceElement = parseSourceElement();
                    return markerApply(marker, delegate.createExportDeclaration(true, sourceElement, [sourceElement.id], null));
                }
                // covers:
                // export default function () {}
                // export default class {}
                switch (lookahead.value) {
                case 'class':
                    return markerApply(marker, delegate.createExportDeclaration(true, parseClassExpression(), [], null));
                case 'function':
                    return markerApply(marker, delegate.createExportDeclaration(true, parseFunctionExpression(), [], null));
                }
            }

            if (matchContextualKeyword('from')) {
                throwError({}, Messages.UnexpectedToken, lookahead.value);
            }

            // covers:
            // export default {};
            // export default [];
            if (match('{')) {
                declaration = parseObjectInitialiser();
            } else if (match('[')) {
                declaration = parseArrayInitialiser();
            } else {
                declaration = parseAssignmentExpression();
            }
            consumeSemicolon();
            return markerApply(marker, delegate.createExportDeclaration(true, declaration, [], null));
        }

        // non-default export
        if (lookahead.type === Token.Keyword || matchContextualKeyword('type')) {
            // covers:
            // export var f = 1;
            switch (lookahead.value) {
            case 'type':
            case 'let':
            case 'const':
            case 'var':
            case 'class':
            case 'function':
                return markerApply(marker, delegate.createExportDeclaration(false, parseSourceElement(), specifiers, null));
            }
        }

        if (match('*')) {
            // covers:
            // export * from "foo";
            specifiers.push(parseExportBatchSpecifier());

            if (!matchContextualKeyword('from')) {
                throwError({}, lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();

            return markerApply(marker, delegate.createExportDeclaration(false, null, specifiers, src));
        }

        expect('{');
        if (!match('}')) {
            do {
                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
                specifiers.push(parseExportSpecifier());
            } while (match(',') && lex());
        }
        expect('}');

        if (matchContextualKeyword('from')) {
            // covering:
            // export {default} from "foo";
            // export {foo} from "foo";
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } else if (isExportFromIdentifier) {
            // covering:
            // export {default}; // missing fromClause
            throwError({}, lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } else {
            // cover
            // export {foo};
            consumeSemicolon();
        }
        return markerApply(marker, delegate.createExportDeclaration(false, declaration, specifiers, src));
    }


    function parseImportSpecifier() {
        // import {<foo as bar>} ...;
        var id, name = null, marker = markerCreate();

        id = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            name = parseVariableIdentifier();
        }

        return markerApply(marker, delegate.createImportSpecifier(id, name));
    }

    function parseNamedImports() {
        var specifiers = [];
        // {foo, bar as bas}
        expect('{');
        if (!match('}')) {
            do {
                specifiers.push(parseImportSpecifier());
            } while (match(',') && lex());
        }
        expect('}');
        return specifiers;
    }

    function parseImportDefaultSpecifier() {
        // import <foo> ...;
        var id, marker = markerCreate();

        id = parseNonComputedProperty();

        return markerApply(marker, delegate.createImportDefaultSpecifier(id));
    }

    function parseImportNamespaceSpecifier() {
        // import <* as foo> ...;
        var id, marker = markerCreate();

        expect('*');
        if (!matchContextualKeyword('as')) {
            throwError({}, Messages.NoAsAfterImportNamespace);
        }
        lex();
        id = parseNonComputedProperty();

        return markerApply(marker, delegate.createImportNamespaceSpecifier(id));
    }

    function parseImportDeclaration() {
        var specifiers, src, marker = markerCreate(), isType = false, token2;

        expectKeyword('import');

        if (matchContextualKeyword('type')) {
            token2 = lookahead2();
            if ((token2.type === Token.Identifier && token2.value !== 'from') ||
                    (token2.type === Token.Punctuator &&
                        (token2.value === '{' || token2.value === '*'))) {
                isType = true;
                lex();
            }
        }

        specifiers = [];

        if (lookahead.type === Token.StringLiteral) {
            // covers:
            // import "foo";
            src = parseModuleSpecifier();
            consumeSemicolon();
            return markerApply(marker, delegate.createImportDeclaration(specifiers, src, isType));
        }

        if (!matchKeyword('default') && isIdentifierName(lookahead)) {
            // covers:
            // import foo
            // import foo, ...
            specifiers.push(parseImportDefaultSpecifier());
            if (match(',')) {
                lex();
            }
        }
        if (match('*')) {
            // covers:
            // import foo, * as foo
            // import * as foo
            specifiers.push(parseImportNamespaceSpecifier());
        } else if (match('{')) {
            // covers:
            // import foo, {bar}
            // import {bar}
            specifiers = specifiers.concat(parseNamedImports());
        }

        if (!matchContextualKeyword('from')) {
            throwError({}, lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return markerApply(marker, delegate.createImportDeclaration(specifiers, src, isType));
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        var marker = markerCreate();
        expect(';');
        return markerApply(marker, delegate.createEmptyStatement());
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var marker = markerCreate(), expr = parseExpression();
        consumeSemicolon();
        return markerApply(marker, delegate.createExpressionStatement(expr));
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate, marker = markerCreate();

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration, marker = markerCreate();

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return markerApply(marker, delegate.createDoWhileStatement(body, test));
    }

    function parseWhileStatement() {
        var test, body, oldInIteration, marker = markerCreate();

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return markerApply(marker, delegate.createWhileStatement(test, body));
    }

    function parseForVariableDeclaration() {
        var marker = markerCreate(),
            token = lex(),
            declarations = parseVariableDeclarationList();

        return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));
    }

    function parseForStatement(opts) {
        var init, test, update, left, right, body, operator, oldInIteration,
            marker = markerCreate();
        init = test = update = null;
        expectKeyword('for');

        // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each
        if (matchContextualKeyword('each')) {
            throwError({}, Messages.EachNotAllowed);
        }

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = true;

                if (init.declarations.length === 1) {
                    if (matchKeyword('in') || matchContextualKeyword('of')) {
                        operator = lookahead;
                        if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {
                            lex();
                            left = init;
                            right = parseExpression();
                            init = null;
                        }
                    }
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = true;

                if (matchContextualKeyword('of')) {
                    operator = lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isAssignableLeftHandSide(init)) {
                        throwError({}, Messages.InvalidLHSInForIn);
                    }
                    operator = lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        if (!(opts !== undefined && opts.ignoreBody)) {
            body = parseStatement();
        }

        state.inIteration = oldInIteration;

        if (typeof left === 'undefined') {
            return markerApply(marker, delegate.createForStatement(init, test, update, body));
        }

        if (operator.value === 'in') {
            return markerApply(marker, delegate.createForInStatement(left, right, body));
        }
        return markerApply(marker, delegate.createForOfStatement(left, right, body));
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var label = null, marker = markerCreate();

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 59) {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return markerApply(marker, delegate.createContinueStatement(null));
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return markerApply(marker, delegate.createContinueStatement(null));
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            if (!state.labelSet.has(label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return markerApply(marker, delegate.createContinueStatement(label));
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var label = null, marker = markerCreate();

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return markerApply(marker, delegate.createBreakStatement(null));
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return markerApply(marker, delegate.createBreakStatement(null));
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            if (!state.labelSet.has(label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return markerApply(marker, delegate.createBreakStatement(label));
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var argument = null, marker = markerCreate();

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 32) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return markerApply(marker, delegate.createReturnStatement(argument));
            }
        }

        if (peekLineTerminator()) {
            return markerApply(marker, delegate.createReturnStatement(null));
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return markerApply(marker, delegate.createReturnStatement(argument));
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body, marker = markerCreate();

        if (strict) {
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return markerApply(marker, delegate.createWithStatement(object, body));
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test,
            consequent = [],
            sourceElement,
            marker = markerCreate();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            consequent.push(sourceElement);
        }

        return markerApply(marker, delegate.createSwitchCase(test, consequent));
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound, marker = markerCreate();

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument, marker = markerCreate();

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return markerApply(marker, delegate.createThrowStatement(argument));
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, marker = markerCreate();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }

        param = parseExpression();
        // 12.14.1
        if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return markerApply(marker, delegate.createCatchClause(param, body));
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null, marker = markerCreate();

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        var marker = markerCreate();
        expectKeyword('debugger');

        consumeSemicolon();

        return markerApply(marker, delegate.createDebuggerStatement());
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            marker,
            expr,
            labeledBody;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement();
            case '{':
                return parseBlock();
            case '(':
                return parseExpressionStatement();
            default:
                break;
            }
        }

        if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement();
            case 'continue':
                return parseContinueStatement();
            case 'debugger':
                return parseDebuggerStatement();
            case 'do':
                return parseDoWhileStatement();
            case 'for':
                return parseForStatement();
            case 'function':
                return parseFunctionDeclaration();
            case 'class':
                return parseClassDeclaration();
            case 'if':
                return parseIfStatement();
            case 'return':
                return parseReturnStatement();
            case 'switch':
                return parseSwitchStatement();
            case 'throw':
                return parseThrowStatement();
            case 'try':
                return parseTryStatement();
            case 'var':
                return parseVariableStatement();
            case 'while':
                return parseWhileStatement();
            case 'with':
                return parseWithStatement();
            default:
                break;
            }
        }

        if (matchAsyncFuncExprOrDecl()) {
            return parseFunctionDeclaration();
        }

        marker = markerCreate();
        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            if (state.labelSet.has(expr.name)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet.set(expr.name, true);
            labeledBody = parseStatement();
            state.labelSet.delete(expr.name);
            return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));
        }

        consumeSemicolon();

        return markerApply(marker, delegate.createExpressionStatement(expr));
    }

    // 13 Function Definition

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return parseAssignmentExpression();
    }

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount,
            marker = markerCreate();

        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesizedCount = state.parenthesizedCount;

        state.labelSet = new StringMap();
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesizedCount;

        return markerApply(marker, delegate.createBlockStatement(sourceElements));
    }

    function validateParam(options, param, name) {
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (options.paramSet.has(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (options.paramSet.has(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet.set(name, true);
    }

    function parseParam(options) {
        var marker, token, rest, param, def;

        token = lookahead;
        if (token.value === '...') {
            token = lex();
            rest = true;
        }

        if (match('[')) {
            marker = markerCreate();
            param = parseArrayInitialiser();
            reinterpretAsDestructuredParameter(options, param);
            if (match(':')) {
                param.typeAnnotation = parseTypeAnnotation();
                markerApply(marker, param);
            }
        } else if (match('{')) {
            marker = markerCreate();
            if (rest) {
                throwError({}, Messages.ObjectPatternAsRestParameter);
            }
            param = parseObjectInitialiser();
            reinterpretAsDestructuredParameter(options, param);
            if (match(':')) {
                param.typeAnnotation = parseTypeAnnotation();
                markerApply(marker, param);
            }
        } else {
            param =
                rest
                ? parseTypeAnnotatableIdentifier(
                    false, /* requireTypeAnnotation */
                    false /* canBeOptionalParam */
                )
                : parseTypeAnnotatableIdentifier(
                    false, /* requireTypeAnnotation */
                    true /* canBeOptionalParam */
                );

            validateParam(options, token, token.value);
        }

        if (match('=')) {
            if (rest) {
                throwErrorTolerant(lookahead, Messages.DefaultRestParameter);
            }
            lex();
            def = parseAssignmentExpression();
            ++options.defaultCount;
        }

        if (rest) {
            if (!match(')')) {
                throwError({}, Messages.ParameterAfterRestParameter);
            }
            options.rest = param;
            return false;
        }

        options.params.push(param);
        options.defaults.push(def);
        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options, marker = markerCreate();

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            rest: null,
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = new StringMap();
            while (index < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        if (match(':')) {
            options.returnType = parseTypeAnnotation();
        }

        return markerApply(marker, options);
    }

    function parseFunctionDeclaration() {
        var id, body, token, tmp, firstRestricted, message, generator, isAsync,
            previousStrict, previousYieldAllowed, previousAwaitAllowed,
            marker = markerCreate(), typeParameters;

        isAsync = false;
        if (matchAsync()) {
            lex();
            isAsync = true;
        }

        expectKeyword('function');

        generator = false;
        if (match('*')) {
            lex();
            generator = true;
        }

        token = lookahead;

        id = parseVariableIdentifier();

        if (match('<')) {
            typeParameters = parseTypeParameterDeclaration();
        }

        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = generator;
        previousAwaitAllowed = state.awaitAllowed;
        state.awaitAllowed = isAsync;

        body = parseFunctionSourceElements();

        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && tmp.stricted) {
            throwErrorTolerant(tmp.stricted, message);
        }
        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;
        state.awaitAllowed = previousAwaitAllowed;

        return markerApply(
            marker,
            delegate.createFunctionDeclaration(
                id,
                tmp.params,
                tmp.defaults,
                body,
                tmp.rest,
                generator,
                false,
                isAsync,
                tmp.returnType,
                typeParameters
            )
        );
    }

    function parseFunctionExpression() {
        var token, id = null, firstRestricted, message, tmp, body, generator, isAsync,
            previousStrict, previousYieldAllowed, previousAwaitAllowed,
            marker = markerCreate(), typeParameters;

        isAsync = false;
        if (matchAsync()) {
            lex();
            isAsync = true;
        }

        expectKeyword('function');

        generator = false;

        if (match('*')) {
            lex();
            generator = true;
        }

        if (!match('(')) {
            if (!match('<')) {
                token = lookahead;
                id = parseVariableIdentifier();

                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        throwErrorTolerant(token, Messages.StrictFunctionName);
                    }
                } else {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictFunctionName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    }
                }
            }

            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
        }

        tmp = parseParams(firstRestricted);
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = generator;
        previousAwaitAllowed = state.awaitAllowed;
        state.awaitAllowed = isAsync;

        body = parseFunctionSourceElements();

        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && tmp.stricted) {
            throwErrorTolerant(tmp.stricted, message);
        }
        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;
        state.awaitAllowed = previousAwaitAllowed;

        return markerApply(
            marker,
            delegate.createFunctionExpression(
                id,
                tmp.params,
                tmp.defaults,
                body,
                tmp.rest,
                generator,
                false,
                isAsync,
                tmp.returnType,
                typeParameters
            )
        );
    }

    function parseYieldExpression() {
        var delegateFlag, expr, marker = markerCreate();

        expectKeyword('yield', !strict);

        delegateFlag = false;
        if (match('*')) {
            lex();
            delegateFlag = true;
        }

        expr = parseAssignmentExpression();

        return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));
    }

    function parseAwaitExpression() {
        var expr, marker = markerCreate();
        expectContextualKeyword('await');
        expr = parseAssignmentExpression();
        return markerApply(marker, delegate.createAwaitExpression(expr));
    }

    // 14 Functions and classes

    // 14.1 Functions is defined above (13 in ES5)
    // 14.2 Arrow Functions Definitions is defined in (7.3 assignments)

    // 14.3 Method Definitions
    // 14.3.7
    function specialMethod(methodDefinition) {
        return methodDefinition.kind === 'get' ||
               methodDefinition.kind === 'set' ||
               methodDefinition.value.generator;
    }

    function parseMethodDefinition(key, isStatic, generator, computed) {
        var token, param, propType,
            isAsync, typeParameters, tokenValue, returnType;

        propType = isStatic ? ClassPropertyType.static : ClassPropertyType.prototype;

        if (generator) {
            return delegate.createMethodDefinition(
                propType,
                '',
                key,
                parsePropertyMethodFunction({ generator: true }),
                computed
            );
        }

        tokenValue = key.type === 'Identifier' && key.name;

        if (tokenValue === 'get' && !match('(')) {
            key = parseObjectPropertyKey();

            expect('(');
            expect(')');
            if (match(':')) {
                returnType = parseTypeAnnotation();
            }
            return delegate.createMethodDefinition(
                propType,
                'get',
                key,
                parsePropertyFunction({ generator: false, returnType: returnType }),
                computed
            );
        }
        if (tokenValue === 'set' && !match('(')) {
            key = parseObjectPropertyKey();

            expect('(');
            token = lookahead;
            param = [ parseTypeAnnotatableIdentifier() ];
            expect(')');
            if (match(':')) {
                returnType = parseTypeAnnotation();
            }
            return delegate.createMethodDefinition(
                propType,
                'set',
                key,
                parsePropertyFunction({
                    params: param,
                    generator: false,
                    name: token,
                    returnType: returnType
                }),
                computed
            );
        }

        if (match('<')) {
            typeParameters = parseTypeParameterDeclaration();
        }

        isAsync = tokenValue === 'async' && !match('(');
        if (isAsync) {
            key = parseObjectPropertyKey();
        }

        return delegate.createMethodDefinition(
            propType,
            '',
            key,
            parsePropertyMethodFunction({
                generator: false,
                async: isAsync,
                typeParameters: typeParameters
            }),
            computed
        );
    }

    function parseClassProperty(key, computed, isStatic) {
        var typeAnnotation;

        typeAnnotation = parseTypeAnnotation();
        expect(';');

        return delegate.createClassProperty(
            key,
            typeAnnotation,
            computed,
            isStatic
        );
    }

    function parseClassElement() {
        var computed = false, generator = false, key, marker = markerCreate(),
            isStatic = false, possiblyOpenBracketToken;
        if (match(';')) {
            lex();
            return undefined;
        }

        if (lookahead.value === 'static') {
            lex();
            isStatic = true;
        }

        if (match('*')) {
            lex();
            generator = true;
        }

        possiblyOpenBracketToken = lookahead;
        if (matchContextualKeyword('get') || matchContextualKeyword('set')) {
            possiblyOpenBracketToken = lookahead2();
        }

        if (possiblyOpenBracketToken.type === Token.Punctuator
                && possiblyOpenBracketToken.value === '[') {
            computed = true;
        }

        key = parseObjectPropertyKey();

        if (!generator && lookahead.value === ':') {
            return markerApply(marker, parseClassProperty(key, computed, isStatic));
        }

        return markerApply(marker, parseMethodDefinition(
            key,
            isStatic,
            generator,
            computed
        ));
    }

    function parseClassBody() {
        var classElement, classElements = [], existingProps = {},
            marker = markerCreate(), propName, propType;

        existingProps[ClassPropertyType.static] = new StringMap();
        existingProps[ClassPropertyType.prototype] = new StringMap();

        expect('{');

        while (index < length) {
            if (match('}')) {
                break;
            }
            classElement = parseClassElement(existingProps);

            if (typeof classElement !== 'undefined') {
                classElements.push(classElement);

                propName = !classElement.computed && getFieldName(classElement.key);
                if (propName !== false) {
                    propType = classElement.static ?
                                ClassPropertyType.static :
                                ClassPropertyType.prototype;

                    if (classElement.type === Syntax.MethodDefinition) {
                        if (propName === 'constructor' && !classElement.static) {
                            if (specialMethod(classElement)) {
                                throwError(classElement, Messages.IllegalClassConstructorProperty);
                            }
                            if (existingProps[ClassPropertyType.prototype].has('constructor')) {
                                throwError(classElement.key, Messages.IllegalDuplicateClassProperty);
                            }
                        }
                        existingProps[propType].set(propName, true);
                    }
                }
            }
        }

        expect('}');

        return markerApply(marker, delegate.createClassBody(classElements));
    }

    function parseClassImplements() {
        var id, implemented = [], marker, typeParameters;
        if (strict) {
            expectKeyword('implements');
        } else {
            expectContextualKeyword('implements');
        }
        while (index < length) {
            marker = markerCreate();
            id = parseVariableIdentifier();
            if (match('<')) {
                typeParameters = parseTypeParameterInstantiation();
            } else {
                typeParameters = null;
            }
            implemented.push(markerApply(marker, delegate.createClassImplements(
                id,
                typeParameters
            )));
            if (!match(',')) {
                break;
            }
            expect(',');
        }
        return implemented;
    }

    function parseClassExpression() {
        var id, implemented, previousYieldAllowed, superClass = null,
            superTypeParameters, marker = markerCreate(), typeParameters,
            matchImplements;

        expectKeyword('class');

        matchImplements =
                strict
                ? matchKeyword('implements')
                : matchContextualKeyword('implements');

        if (!matchKeyword('extends') && !matchImplements && !match('{')) {
            id = parseVariableIdentifier();
        }

        if (match('<')) {
            typeParameters = parseTypeParameterDeclaration();
        }

        if (matchKeyword('extends')) {
            expectKeyword('extends');
            previousYieldAllowed = state.yieldAllowed;
            state.yieldAllowed = false;
            superClass = parseLeftHandSideExpressionAllowCall();
            if (match('<')) {
                superTypeParameters = parseTypeParameterInstantiation();
            }
            state.yieldAllowed = previousYieldAllowed;
        }

        if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {
            implemented = parseClassImplements();
        }

        return markerApply(marker, delegate.createClassExpression(
            id,
            superClass,
            parseClassBody(),
            typeParameters,
            superTypeParameters,
            implemented
        ));
    }

    function parseClassDeclaration() {
        var id, implemented, previousYieldAllowed, superClass = null,
            superTypeParameters, marker = markerCreate(), typeParameters;

        expectKeyword('class');

        id = parseVariableIdentifier();

        if (match('<')) {
            typeParameters = parseTypeParameterDeclaration();
        }

        if (matchKeyword('extends')) {
            expectKeyword('extends');
            previousYieldAllowed = state.yieldAllowed;
            state.yieldAllowed = false;
            superClass = parseLeftHandSideExpressionAllowCall();
            if (match('<')) {
                superTypeParameters = parseTypeParameterInstantiation();
            }
            state.yieldAllowed = previousYieldAllowed;
        }

        if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {
            implemented = parseClassImplements();
        }

        return markerApply(marker, delegate.createClassDeclaration(
            id,
            superClass,
            parseClassBody(),
            typeParameters,
            superTypeParameters,
            implemented
        ));
    }

    // 15 Program

    function parseSourceElement() {
        var token;
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            case 'export':
                throwErrorTolerant({}, Messages.IllegalExportDeclaration);
                return parseExportDeclaration();
            case 'import':
                throwErrorTolerant({}, Messages.IllegalImportDeclaration);
                return parseImportDeclaration();
            case 'interface':
                if (lookahead2().type === Token.Identifier) {
                    return parseInterface();
                }
                return parseStatement();
            default:
                return parseStatement();
            }
        }

        if (matchContextualKeyword('type')
                && lookahead2().type === Token.Identifier) {
            return parseTypeAlias();
        }

        if (matchContextualKeyword('interface')
                && lookahead2().type === Token.Identifier) {
            return parseInterface();
        }

        if (matchContextualKeyword('declare')) {
            token = lookahead2();
            if (token.type === Token.Keyword) {
                switch (token.value) {
                case 'class':
                    return parseDeclareClass();
                case 'function':
                    return parseDeclareFunction();
                case 'var':
                    return parseDeclareVariable();
                }
            } else if (token.type === Token.Identifier
                    && token.value === 'module') {
                return parseDeclareModule();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseProgramElement() {
        var isModule = extra.sourceType === 'module' || extra.sourceType === 'nonStrictModule';

        if (isModule && lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                return parseExportDeclaration();
            case 'import':
                return parseImportDeclaration();
            }
        }

        return parseSourceElement();
    }

    function parseProgramElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseProgramElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseProgramElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body, marker = markerCreate();
        strict = extra.sourceType === 'module';
        peek();
        body = parseProgramElements();
        return markerApply(marker, delegate.createProgram(body));
    }

    // 16 JSX

    XHTMLEntities = {
        quot: '\u0022',
        amp: '&',
        apos: '\u0027',
        lt: '<',
        gt: '>',
        nbsp: '\u00A0',
        iexcl: '\u00A1',
        cent: '\u00A2',
        pound: '\u00A3',
        curren: '\u00A4',
        yen: '\u00A5',
        brvbar: '\u00A6',
        sect: '\u00A7',
        uml: '\u00A8',
        copy: '\u00A9',
        ordf: '\u00AA',
        laquo: '\u00AB',
        not: '\u00AC',
        shy: '\u00AD',
        reg: '\u00AE',
        macr: '\u00AF',
        deg: '\u00B0',
        plusmn: '\u00B1',
        sup2: '\u00B2',
        sup3: '\u00B3',
        acute: '\u00B4',
        micro: '\u00B5',
        para: '\u00B6',
        middot: '\u00B7',
        cedil: '\u00B8',
        sup1: '\u00B9',
        ordm: '\u00BA',
        raquo: '\u00BB',
        frac14: '\u00BC',
        frac12: '\u00BD',
        frac34: '\u00BE',
        iquest: '\u00BF',
        Agrave: '\u00C0',
        Aacute: '\u00C1',
        Acirc: '\u00C2',
        Atilde: '\u00C3',
        Auml: '\u00C4',
        Aring: '\u00C5',
        AElig: '\u00C6',
        Ccedil: '\u00C7',
        Egrave: '\u00C8',
        Eacute: '\u00C9',
        Ecirc: '\u00CA',
        Euml: '\u00CB',
        Igrave: '\u00CC',
        Iacute: '\u00CD',
        Icirc: '\u00CE',
        Iuml: '\u00CF',
        ETH: '\u00D0',
        Ntilde: '\u00D1',
        Ograve: '\u00D2',
        Oacute: '\u00D3',
        Ocirc: '\u00D4',
        Otilde: '\u00D5',
        Ouml: '\u00D6',
        times: '\u00D7',
        Oslash: '\u00D8',
        Ugrave: '\u00D9',
        Uacute: '\u00DA',
        Ucirc: '\u00DB',
        Uuml: '\u00DC',
        Yacute: '\u00DD',
        THORN: '\u00DE',
        szlig: '\u00DF',
        agrave: '\u00E0',
        aacute: '\u00E1',
        acirc: '\u00E2',
        atilde: '\u00E3',
        auml: '\u00E4',
        aring: '\u00E5',
        aelig: '\u00E6',
        ccedil: '\u00E7',
        egrave: '\u00E8',
        eacute: '\u00E9',
        ecirc: '\u00EA',
        euml: '\u00EB',
        igrave: '\u00EC',
        iacute: '\u00ED',
        icirc: '\u00EE',
        iuml: '\u00EF',
        eth: '\u00F0',
        ntilde: '\u00F1',
        ograve: '\u00F2',
        oacute: '\u00F3',
        ocirc: '\u00F4',
        otilde: '\u00F5',
        ouml: '\u00F6',
        divide: '\u00F7',
        oslash: '\u00F8',
        ugrave: '\u00F9',
        uacute: '\u00FA',
        ucirc: '\u00FB',
        uuml: '\u00FC',
        yacute: '\u00FD',
        thorn: '\u00FE',
        yuml: '\u00FF',
        OElig: '\u0152',
        oelig: '\u0153',
        Scaron: '\u0160',
        scaron: '\u0161',
        Yuml: '\u0178',
        fnof: '\u0192',
        circ: '\u02C6',
        tilde: '\u02DC',
        Alpha: '\u0391',
        Beta: '\u0392',
        Gamma: '\u0393',
        Delta: '\u0394',
        Epsilon: '\u0395',
        Zeta: '\u0396',
        Eta: '\u0397',
        Theta: '\u0398',
        Iota: '\u0399',
        Kappa: '\u039A',
        Lambda: '\u039B',
        Mu: '\u039C',
        Nu: '\u039D',
        Xi: '\u039E',
        Omicron: '\u039F',
        Pi: '\u03A0',
        Rho: '\u03A1',
        Sigma: '\u03A3',
        Tau: '\u03A4',
        Upsilon: '\u03A5',
        Phi: '\u03A6',
        Chi: '\u03A7',
        Psi: '\u03A8',
        Omega: '\u03A9',
        alpha: '\u03B1',
        beta: '\u03B2',
        gamma: '\u03B3',
        delta: '\u03B4',
        epsilon: '\u03B5',
        zeta: '\u03B6',
        eta: '\u03B7',
        theta: '\u03B8',
        iota: '\u03B9',
        kappa: '\u03BA',
        lambda: '\u03BB',
        mu: '\u03BC',
        nu: '\u03BD',
        xi: '\u03BE',
        omicron: '\u03BF',
        pi: '\u03C0',
        rho: '\u03C1',
        sigmaf: '\u03C2',
        sigma: '\u03C3',
        tau: '\u03C4',
        upsilon: '\u03C5',
        phi: '\u03C6',
        chi: '\u03C7',
        psi: '\u03C8',
        omega: '\u03C9',
        thetasym: '\u03D1',
        upsih: '\u03D2',
        piv: '\u03D6',
        ensp: '\u2002',
        emsp: '\u2003',
        thinsp: '\u2009',
        zwnj: '\u200C',
        zwj: '\u200D',
        lrm: '\u200E',
        rlm: '\u200F',
        ndash: '\u2013',
        mdash: '\u2014',
        lsquo: '\u2018',
        rsquo: '\u2019',
        sbquo: '\u201A',
        ldquo: '\u201C',
        rdquo: '\u201D',
        bdquo: '\u201E',
        dagger: '\u2020',
        Dagger: '\u2021',
        bull: '\u2022',
        hellip: '\u2026',
        permil: '\u2030',
        prime: '\u2032',
        Prime: '\u2033',
        lsaquo: '\u2039',
        rsaquo: '\u203A',
        oline: '\u203E',
        frasl: '\u2044',
        euro: '\u20AC',
        image: '\u2111',
        weierp: '\u2118',
        real: '\u211C',
        trade: '\u2122',
        alefsym: '\u2135',
        larr: '\u2190',
        uarr: '\u2191',
        rarr: '\u2192',
        darr: '\u2193',
        harr: '\u2194',
        crarr: '\u21B5',
        lArr: '\u21D0',
        uArr: '\u21D1',
        rArr: '\u21D2',
        dArr: '\u21D3',
        hArr: '\u21D4',
        forall: '\u2200',
        part: '\u2202',
        exist: '\u2203',
        empty: '\u2205',
        nabla: '\u2207',
        isin: '\u2208',
        notin: '\u2209',
        ni: '\u220B',
        prod: '\u220F',
        sum: '\u2211',
        minus: '\u2212',
        lowast: '\u2217',
        radic: '\u221A',
        prop: '\u221D',
        infin: '\u221E',
        ang: '\u2220',
        and: '\u2227',
        or: '\u2228',
        cap: '\u2229',
        cup: '\u222A',
        'int': '\u222B',
        there4: '\u2234',
        sim: '\u223C',
        cong: '\u2245',
        asymp: '\u2248',
        ne: '\u2260',
        equiv: '\u2261',
        le: '\u2264',
        ge: '\u2265',
        sub: '\u2282',
        sup: '\u2283',
        nsub: '\u2284',
        sube: '\u2286',
        supe: '\u2287',
        oplus: '\u2295',
        otimes: '\u2297',
        perp: '\u22A5',
        sdot: '\u22C5',
        lceil: '\u2308',
        rceil: '\u2309',
        lfloor: '\u230A',
        rfloor: '\u230B',
        lang: '\u2329',
        rang: '\u232A',
        loz: '\u25CA',
        spades: '\u2660',
        clubs: '\u2663',
        hearts: '\u2665',
        diams: '\u2666'
    };

    function getQualifiedJSXName(object) {
        if (object.type === Syntax.JSXIdentifier) {
            return object.name;
        }
        if (object.type === Syntax.JSXNamespacedName) {
            return object.namespace.name + ':' + object.name.name;
        }
        /* istanbul ignore else */
        if (object.type === Syntax.JSXMemberExpression) {
            return (
                getQualifiedJSXName(object.object) + '.' +
                getQualifiedJSXName(object.property)
            );
        }
        /* istanbul ignore next */
        throwUnexpected(object);
    }

    function isJSXIdentifierStart(ch) {
        // exclude backslash (\)
        return (ch !== 92) && isIdentifierStart(ch);
    }

    function isJSXIdentifierPart(ch) {
        // exclude backslash (\) and add hyphen (-)
        return (ch !== 92) && (ch === 45 || isIdentifierPart(ch));
    }

    function scanJSXIdentifier() {
        var ch, start, value = '';

        start = index;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isJSXIdentifierPart(ch)) {
                break;
            }
            value += source[index++];
        }

        return {
            type: Token.JSXIdentifier,
            value: value,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanJSXEntity() {
        var ch, str = '', start = index, count = 0, code;
        ch = source[index];
        assert(ch === '&', 'Entity must start with an ampersand');
        index++;
        while (index < length && count++ < 10) {
            ch = source[index++];
            if (ch === ';') {
                break;
            }
            str += ch;
        }

        // Well-formed entity (ending was found).
        if (ch === ';') {
            // Numeric entity.
            if (str[0] === '#') {
                if (str[1] === 'x') {
                    code = +('0' + str.substr(1));
                } else {
                    // Removing leading zeros in order to avoid treating as octal in old browsers.
                    code = +str.substr(1).replace(Regex.LeadingZeros, '');
                }

                if (!isNaN(code)) {
                    return String.fromCharCode(code);
                }
            /* istanbul ignore else */
            } else if (XHTMLEntities[str]) {
                return XHTMLEntities[str];
            }
        }

        // Treat non-entity sequences as regular text.
        index = start + 1;
        return '&';
    }

    function scanJSXText(stopChars) {
        var ch, str = '', start;
        start = index;
        while (index < length) {
            ch = source[index];
            if (stopChars.indexOf(ch) !== -1) {
                break;
            }
            if (ch === '&') {
                str += scanJSXEntity();
            } else {
                index++;
                if (ch === '\r' && source[index] === '\n') {
                    str += ch;
                    ch = source[index];
                    index++;
                }
                if (isLineTerminator(ch.charCodeAt(0))) {
                    ++lineNumber;
                    lineStart = index;
                }
                str += ch;
            }
        }
        return {
            type: Token.JSXText,
            value: str,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanJSXStringLiteral() {
        var innerToken, quote, start;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        innerToken = scanJSXText([quote]);

        if (quote !== source[index]) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        ++index;

        innerToken.range = [start, index];

        return innerToken;
    }

    /**
     * Between JSX opening and closing tags (e.g. <foo>HERE</foo>), anything that
     * is not another JSX tag and is not an expression wrapped by {} is text.
     */
    function advanceJSXChild() {
        var ch = source.charCodeAt(index);

        // '<' 60, '>' 62, '{' 123, '}' 125
        if (ch !== 60 && ch !== 62 && ch !== 123 && ch !== 125) {
            return scanJSXText(['<', '>', '{', '}']);
        }

        return scanPunctuator();
    }

    function parseJSXIdentifier() {
        var token, marker = markerCreate();

        if (lookahead.type !== Token.JSXIdentifier) {
            throwUnexpected(lookahead);
        }

        token = lex();
        return markerApply(marker, delegate.createJSXIdentifier(token.value));
    }

    function parseJSXNamespacedName() {
        var namespace, name, marker = markerCreate();

        namespace = parseJSXIdentifier();
        expect(':');
        name = parseJSXIdentifier();

        return markerApply(marker, delegate.createJSXNamespacedName(namespace, name));
    }

    function parseJSXMemberExpression() {
        var marker = markerCreate(),
            expr = parseJSXIdentifier();

        while (match('.')) {
            lex();
            expr = markerApply(marker, delegate.createJSXMemberExpression(expr, parseJSXIdentifier()));
        }

        return expr;
    }

    function parseJSXElementName() {
        if (lookahead2().value === ':') {
            return parseJSXNamespacedName();
        }
        if (lookahead2().value === '.') {
            return parseJSXMemberExpression();
        }

        return parseJSXIdentifier();
    }

    function parseJSXAttributeName() {
        if (lookahead2().value === ':') {
            return parseJSXNamespacedName();
        }

        return parseJSXIdentifier();
    }

    function parseJSXAttributeValue() {
        var value, marker;
        if (match('{')) {
            value = parseJSXExpressionContainer();
            if (value.expression.type === Syntax.JSXEmptyExpression) {
                throwError(
                    value,
                    'JSX attributes must only be assigned a non-empty ' +
                        'expression'
                );
            }
        } else if (match('<')) {
            value = parseJSXElement();
        } else if (lookahead.type === Token.JSXText) {
            marker = markerCreate();
            value = markerApply(marker, delegate.createLiteral(lex()));
        } else {
            throwError({}, Messages.InvalidJSXAttributeValue);
        }
        return value;
    }

    function parseJSXEmptyExpression() {
        var marker = markerCreatePreserveWhitespace();
        while (source.charAt(index) !== '}') {
            index++;
        }
        return markerApply(marker, delegate.createJSXEmptyExpression());
    }

    function parseJSXExpressionContainer() {
        var expression, origInJSXChild, origInJSXTag, marker = markerCreate();

        origInJSXChild = state.inJSXChild;
        origInJSXTag = state.inJSXTag;
        state.inJSXChild = false;
        state.inJSXTag = false;

        expect('{');

        if (match('}')) {
            expression = parseJSXEmptyExpression();
        } else {
            expression = parseExpression();
        }

        state.inJSXChild = origInJSXChild;
        state.inJSXTag = origInJSXTag;

        expect('}');

        return markerApply(marker, delegate.createJSXExpressionContainer(expression));
    }

    function parseJSXSpreadAttribute() {
        var expression, origInJSXChild, origInJSXTag, marker = markerCreate();

        origInJSXChild = state.inJSXChild;
        origInJSXTag = state.inJSXTag;
        state.inJSXChild = false;
        state.inJSXTag = false;

        expect('{');
        expect('...');

        expression = parseAssignmentExpression();

        state.inJSXChild = origInJSXChild;
        state.inJSXTag = origInJSXTag;

        expect('}');

        return markerApply(marker, delegate.createJSXSpreadAttribute(expression));
    }

    function parseJSXAttribute() {
        var name, marker;

        if (match('{')) {
            return parseJSXSpreadAttribute();
        }

        marker = markerCreate();

        name = parseJSXAttributeName();

        // HTML empty attribute
        if (match('=')) {
            lex();
            return markerApply(marker, delegate.createJSXAttribute(name, parseJSXAttributeValue()));
        }

        return markerApply(marker, delegate.createJSXAttribute(name));
    }

    function parseJSXChild() {
        var token, marker;
        if (match('{')) {
            token = parseJSXExpressionContainer();
        } else if (lookahead.type === Token.JSXText) {
            marker = markerCreatePreserveWhitespace();
            token = markerApply(marker, delegate.createLiteral(lex()));
        } else if (match('<')) {
            token = parseJSXElement();
        } else {
            throwUnexpected(lookahead);
        }
        return token;
    }

    function parseJSXClosingElement() {
        var name, origInJSXChild, origInJSXTag, marker = markerCreate();
        origInJSXChild = state.inJSXChild;
        origInJSXTag = state.inJSXTag;
        state.inJSXChild = false;
        state.inJSXTag = true;
        expect('<');
        expect('/');
        name = parseJSXElementName();
        // Because advance() (called by lex() called by expect()) expects there
        // to be a valid token after >, it needs to know whether to look for a
        // standard JS token or an JSX text node
        state.inJSXChild = origInJSXChild;
        state.inJSXTag = origInJSXTag;
        expect('>');
        return markerApply(marker, delegate.createJSXClosingElement(name));
    }

    function parseJSXOpeningElement() {
        var name, attributes = [], selfClosing = false, origInJSXChild, origInJSXTag, marker = markerCreate();

        origInJSXChild = state.inJSXChild;
        origInJSXTag = state.inJSXTag;
        state.inJSXChild = false;
        state.inJSXTag = true;

        expect('<');

        name = parseJSXElementName();

        while (index < length &&
                lookahead.value !== '/' &&
                lookahead.value !== '>') {
            attributes.push(parseJSXAttribute());
        }

        state.inJSXTag = origInJSXTag;

        if (lookahead.value === '/') {
            expect('/');
            // Because advance() (called by lex() called by expect()) expects
            // there to be a valid token after >, it needs to know whether to
            // look for a standard JS token or an JSX text node
            state.inJSXChild = origInJSXChild;
            expect('>');
            selfClosing = true;
        } else {
            state.inJSXChild = true;
            expect('>');
        }
        return markerApply(marker, delegate.createJSXOpeningElement(name, attributes, selfClosing));
    }

    function parseJSXElement() {
        var openingElement, closingElement = null, children = [], origInJSXChild, origInJSXTag, marker = markerCreate();

        origInJSXChild = state.inJSXChild;
        origInJSXTag = state.inJSXTag;
        openingElement = parseJSXOpeningElement();

        if (!openingElement.selfClosing) {
            while (index < length) {
                state.inJSXChild = false; // Call lookahead2() with inJSXChild = false because </ should not be considered in the child
                if (lookahead.value === '<' && lookahead2().value === '/') {
                    break;
                }
                state.inJSXChild = true;
                children.push(parseJSXChild());
            }
            state.inJSXChild = origInJSXChild;
            state.inJSXTag = origInJSXTag;
            closingElement = parseJSXClosingElement();
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                throwError({}, Messages.ExpectedJSXClosingTag, getQualifiedJSXName(openingElement.name));
            }
        }

        // When (erroneously) writing two adjacent tags like
        //
        //     var x = <div>one</div><div>two</div>;
        //
        // the default error message is a bit incomprehensible. Since it's
        // rarely (never?) useful to write a less-than sign after an JSX
        // element, we disallow it here in the parser in order to provide a
        // better error message. (In the rare case that the less-than operator
        // was intended, the left tag can be wrapped in parentheses.)
        if (!origInJSXChild && match('<')) {
            throwError(lookahead, Messages.AdjacentJSXElements);
        }

        return markerApply(marker, delegate.createJSXElement(openingElement, closingElement, children));
    }

    function parseTypeAlias() {
        var id, marker = markerCreate(), typeParameters = null, right;
        expectContextualKeyword('type');
        id = parseVariableIdentifier();
        if (match('<')) {
            typeParameters = parseTypeParameterDeclaration();
        }
        expect('=');
        right = parseType();
        consumeSemicolon();
        return markerApply(marker, delegate.createTypeAlias(id, typeParameters, right));
    }

    function parseInterfaceExtends() {
        var marker = markerCreate(), id, typeParameters = null;

        id = parseVariableIdentifier();
        if (match('<')) {
            typeParameters = parseTypeParameterInstantiation();
        }

        return markerApply(marker, delegate.createInterfaceExtends(
            id,
            typeParameters
        ));
    }

    function parseInterfaceish(marker, allowStatic) {
        var body, bodyMarker, extended = [], id,
            typeParameters = null;

        id = parseVariableIdentifier();
        if (match('<')) {
            typeParameters = parseTypeParameterDeclaration();
        }

        if (matchKeyword('extends')) {
            expectKeyword('extends');

            while (index < length) {
                extended.push(parseInterfaceExtends());
                if (!match(',')) {
                    break;
                }
                expect(',');
            }
        }

        bodyMarker = markerCreate();
        body = markerApply(bodyMarker, parseObjectType(allowStatic));

        return markerApply(marker, delegate.createInterface(
            id,
            typeParameters,
            body,
            extended
        ));
    }

    function parseInterface() {
        var marker = markerCreate();

        if (strict) {
            expectKeyword('interface');
        } else {
            expectContextualKeyword('interface');
        }

        return parseInterfaceish(marker, /* allowStatic */false);
    }

    function parseDeclareClass() {
        var marker = markerCreate(), ret;
        expectContextualKeyword('declare');
        expectKeyword('class');

        ret = parseInterfaceish(marker, /* allowStatic */true);
        ret.type = Syntax.DeclareClass;
        return ret;
    }

    function parseDeclareFunction() {
        var id, idMarker,
            marker = markerCreate(), params, returnType, rest, tmp,
            typeParameters = null, value, valueMarker;

        expectContextualKeyword('declare');
        expectKeyword('function');
        idMarker = markerCreate();
        id = parseVariableIdentifier();

        valueMarker = markerCreate();
        if (match('<')) {
            typeParameters = parseTypeParameterDeclaration();
        }
        expect('(');
        tmp = parseFunctionTypeParams();
        params = tmp.params;
        rest = tmp.rest;
        expect(')');

        expect(':');
        returnType = parseType();

        value = markerApply(valueMarker, delegate.createFunctionTypeAnnotation(
            params,
            returnType,
            rest,
            typeParameters
        ));

        id.typeAnnotation = markerApply(valueMarker, delegate.createTypeAnnotation(
            value
        ));
        markerApply(idMarker, id);

        consumeSemicolon();

        return markerApply(marker, delegate.createDeclareFunction(
            id
        ));
    }

    function parseDeclareVariable() {
        var id, marker = markerCreate();
        expectContextualKeyword('declare');
        expectKeyword('var');
        id = parseTypeAnnotatableIdentifier();

        consumeSemicolon();

        return markerApply(marker, delegate.createDeclareVariable(
            id
        ));
    }

    function parseDeclareModule() {
        var body = [], bodyMarker, id, idMarker, marker = markerCreate(), token;
        expectContextualKeyword('declare');
        expectContextualKeyword('module');

        if (lookahead.type === Token.StringLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            idMarker = markerCreate();
            id = markerApply(idMarker, delegate.createLiteral(lex()));
        } else {
            id = parseVariableIdentifier();
        }

        bodyMarker = markerCreate();
        expect('{');
        while (index < length && !match('}')) {
            token = lookahead2();
            switch (token.value) {
            case 'class':
                body.push(parseDeclareClass());
                break;
            case 'function':
                body.push(parseDeclareFunction());
                break;
            case 'var':
                body.push(parseDeclareVariable());
                break;
            default:
                throwUnexpected(lookahead);
            }
        }
        expect('}');

        return markerApply(marker, delegate.createDeclareModule(
            id,
            markerApply(bodyMarker, delegate.createBlockStatement(body))
        ));
    }

    function collectToken() {
        var loc, token, range, value, entry;

        /* istanbul ignore else */
        if (!state.inJSXChild) {
            skipComment();
        }

        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = extra.advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            range = [token.range[0], token.range[1]];
            value = source.slice(token.range[0], token.range[1]);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: range,
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = extra.scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (!extra.tokenize) {
            /* istanbul ignore next */
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function patch() {
        if (typeof extra.tokens !== 'undefined') {
            extra.advance = advance;
            extra.scanRegExp = scanRegExp;

            advance = collectToken;
            scanRegExp = collectRegex;
        }
    }

    function unpatch() {
        if (typeof extra.scanRegExp === 'function') {
            advance = extra.advance;
            scanRegExp = extra.scanRegExp;
        }
    }

    // This is used to modify the delegate.

    function extend(object, properties) {
        var entry, result = {};

        for (entry in object) {
            /* istanbul ignore else */
            if (object.hasOwnProperty(entry)) {
                result[entry] = object[entry];
            }
        }

        for (entry in properties) {
            /* istanbul ignore else */
            if (properties.hasOwnProperty(entry)) {
                result[entry] = properties[entry];
            }
        }

        return result;
    }

    function tokenize(code, options) {
        var toString,
            token,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowKeyword: true,
            allowIn: true,
            labelSet: new StringMap(),
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        patch();

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            token = lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    token = lex();
                } catch (lexError) {
                    token = lookahead;
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowKeyword: false,
            allowIn: true,
            labelSet: new StringMap(),
            parenthesizedCount: 0,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            inJSXChild: false,
            inJSXTag: false,
            inType: false,
            lastCommentStart: -1,
            yieldAllowed: false,
            awaitAllowed: false
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                delegate = extend(delegate, {
                    'postProcess': function (node) {
                        node.loc.source = toString(options.source);
                        return node;
                    }
                });
            }

            extra.sourceType = options.sourceType;
            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }

        patch();
        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '13001.1001.0-dev-harmony-fb';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
   /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map.js":[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/source-map-consumer.js","./source-map/source-map-generator":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/source-map-generator.js","./source-map/source-node":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/source-node.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/array-set.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/util.js","amdefine":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/base64-vlq.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/base64.js","amdefine":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/base64.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/binary-search.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/source-map-consumer.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.slice()
        .sort(util.compareByGeneratedPositions);
      smc.__originalMappings = aSourceMap._mappings.slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      util.compareByGeneratedPositions);

      if (mapping) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions);

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/array-set.js","./base64-vlq":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/base64-vlq.js","./binary-search":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/binary-search.js","./util":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/util.js","amdefine":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/source-map-generator.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. To create a new one, you must pass an object
   * with the following properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: An optional root for all URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    this._file = util.getArg(aArgs, 'file');
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile) {
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            // Copy mapping
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, original.source);
            } else {
              mapping.source = original.source;
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          orginal: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions);

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/array-set.js","./base64-vlq":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/base64-vlq.js","./util":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/util.js","amdefine":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/source-node.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // The generated code
      // Processed fragments are removed from this array.
      var remainingLines = aGeneratedCode.split('\n');

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping === null) {
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(remainingLines.shift() + "\n");
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
        } else {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate full lines with "lastMapping"
            do {
              code += remainingLines.shift() + "\n";
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } while (lastGeneratedLine < mapping.generatedLine);
            // When we reached the correct line, we add code until we
            // reach the correct column too.
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              code += nextLine.substr(0, mapping.generatedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            // Create the SourceNode.
            addMappingWithCode(lastMapping, code);
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
          }
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      // Associate the remaining code in the current line with "lastMapping"
      // and add the remaining lines without any mapping
      addMappingWithCode(lastMapping, remainingLines.join("\n"));

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i] instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.split('').forEach(function (ch) {
        if (ch === '\n') {
          generated.line++;
          generated.column = 0;
        } else {
          generated.column++;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/source-map-generator.js","./util":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/util.js","amdefine":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map/util.js":[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
  var dataUrlRegexp = /^data:.+\,.+/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[3],
      host: match[4],
      port: match[6],
      path: match[7]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = aParsedUrl.scheme + "://";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@"
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  function join(aRoot, aPath) {
    var url;

    if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
      url.path = aPath;
      return urlGenerate(url);
    }

    return aRoot.replace(/\/$/, '') + '/' + aPath;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, '');

    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js":[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/msx/node_modules/jstransform/node_modules/source-map/node_modules/amdefine/amdefine.js")

},{"_process":"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/process/browser.js","path":"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/path-browserify/index.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/docblock.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var docblockRe = /^\s*(\/\*\*(.|\r?\n)*?\*\/)/;
var ltrimRe = /^\s*/;
/**
 * @param {String} contents
 * @return {String}
 */
function extract(contents) {
  var match = contents.match(docblockRe);
  if (match) {
    return match[0].replace(ltrimRe, '') || '';
  }
  return '';
}


var commentStartRe = /^\/\*\*?/;
var commentEndRe = /\*+\/$/;
var wsRe = /[\t ]+/g;
var stringStartRe = /(\r?\n|^) *\*/g;
var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;

/**
 * @param {String} contents
 * @return {Array}
 */
function parse(docblock) {
  docblock = docblock
    .replace(commentStartRe, '')
    .replace(commentEndRe, '')
    .replace(wsRe, ' ')
    .replace(stringStartRe, '$1');

  // Normalize multi-line directives
  var prev = '';
  while (prev != docblock) {
    prev = docblock;
    docblock = docblock.replace(multilineRe, "\n$1 $2\n");
  }
  docblock = docblock.trim();

  var result = [];
  var match;
  while (match = propertyRe.exec(docblock)) {
    result.push([match[1], match[2]]);
  }

  return result;
}

/**
 * Same as parse but returns an object of prop: value instead of array of paris
 * If a property appers more than once the last one will be returned
 *
 * @param {String} contents
 * @return {Object}
 */
function parseAsObject(docblock) {
  var pairs = parse(docblock);
  var result = {};
  for (var i = 0; i < pairs.length; i++) {
    result[pairs[i][0]] = pairs[i][1];
  }
  return result;
}


exports.extract = extract;
exports.parse = parse;
exports.parseAsObject = parseAsObject;

},{}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/jstransform.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*jslint node: true*/
"use strict";

var esprima = require('esprima-fb');
var utils = require('./utils');

var getBoundaryNode = utils.getBoundaryNode;
var declareIdentInScope = utils.declareIdentInLocalScope;
var initScopeMetadata = utils.initScopeMetadata;
var Syntax = esprima.Syntax;

/**
 * @param {object} node
 * @param {object} parentNode
 * @return {boolean}
 */
function _nodeIsClosureScopeBoundary(node, parentNode) {
  if (node.type === Syntax.Program) {
    return true;
  }

  var parentIsFunction =
    parentNode.type === Syntax.FunctionDeclaration
    || parentNode.type === Syntax.FunctionExpression
    || parentNode.type === Syntax.ArrowFunctionExpression;

  var parentIsCurlylessArrowFunc =
    parentNode.type === Syntax.ArrowFunctionExpression
    && node === parentNode.body;

  return parentIsFunction
         && (node.type === Syntax.BlockStatement || parentIsCurlylessArrowFunc);
}

function _nodeIsBlockScopeBoundary(node, parentNode) {
  if (node.type === Syntax.Program) {
    return false;
  }

  return node.type === Syntax.BlockStatement
         && parentNode.type === Syntax.CatchClause;
}

/**
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function traverse(node, path, state) {
  /*jshint -W004*/
  // Create a scope stack entry if this is the first node we've encountered in
  // its local scope
  var startIndex = null;
  var parentNode = path[0];
  if (!Array.isArray(node) && state.localScope.parentNode !== parentNode) {
    if (_nodeIsClosureScopeBoundary(node, parentNode)) {
      var scopeIsStrict = state.scopeIsStrict;
      if (!scopeIsStrict
          && (node.type === Syntax.BlockStatement
              || node.type === Syntax.Program)) {
          scopeIsStrict =
            node.body.length > 0
            && node.body[0].type === Syntax.ExpressionStatement
            && node.body[0].expression.type === Syntax.Literal
            && node.body[0].expression.value === 'use strict';
      }

      if (node.type === Syntax.Program) {
        startIndex = state.g.buffer.length;
        state = utils.updateState(state, {
          scopeIsStrict: scopeIsStrict
        });
      } else {
        startIndex = state.g.buffer.length + 1;
        state = utils.updateState(state, {
          localScope: {
            parentNode: parentNode,
            parentScope: state.localScope,
            identifiers: {},
            tempVarIndex: 0,
            tempVars: []
          },
          scopeIsStrict: scopeIsStrict
        });

        // All functions have an implicit 'arguments' object in scope
        declareIdentInScope('arguments', initScopeMetadata(node), state);

        // Include function arg identifiers in the scope boundaries of the
        // function
        if (parentNode.params.length > 0) {
          var param;
          var metadata = initScopeMetadata(parentNode, path.slice(1), path[0]);
          for (var i = 0; i < parentNode.params.length; i++) {
            param = parentNode.params[i];
            if (param.type === Syntax.Identifier) {
              declareIdentInScope(param.name, metadata, state);
            }
          }
        }

        // Include rest arg identifiers in the scope boundaries of their
        // functions
        if (parentNode.rest) {
          var metadata = initScopeMetadata(
            parentNode,
            path.slice(1),
            path[0]
          );
          declareIdentInScope(parentNode.rest.name, metadata, state);
        }

        // Named FunctionExpressions scope their name within the body block of
        // themselves only
        if (parentNode.type === Syntax.FunctionExpression && parentNode.id) {
          var metaData =
            initScopeMetadata(parentNode, path.parentNodeslice, parentNode);
          declareIdentInScope(parentNode.id.name, metaData, state);
        }
      }

      // Traverse and find all local identifiers in this closure first to
      // account for function/variable declaration hoisting
      collectClosureIdentsAndTraverse(node, path, state);
    }

    if (_nodeIsBlockScopeBoundary(node, parentNode)) {
      startIndex = state.g.buffer.length;
      state = utils.updateState(state, {
        localScope: {
          parentNode: parentNode,
          parentScope: state.localScope,
          identifiers: {},
          tempVarIndex: 0,
          tempVars: []
        }
      });

      if (parentNode.type === Syntax.CatchClause) {
        var metadata = initScopeMetadata(
          parentNode,
          path.slice(1),
          parentNode
        );
        declareIdentInScope(parentNode.param.name, metadata, state);
      }
      collectBlockIdentsAndTraverse(node, path, state);
    }
  }

  // Only catchup() before and after traversing a child node
  function traverser(node, path, state) {
    node.range && utils.catchup(node.range[0], state);
    traverse(node, path, state);
    node.range && utils.catchup(node.range[1], state);
  }

  utils.analyzeAndTraverse(walker, traverser, node, path, state);

  // Inject temp variables into the scope.
  if (startIndex !== null) {
    utils.injectTempVarDeclarations(state, startIndex);
  }
}

function collectClosureIdentsAndTraverse(node, path, state) {
  utils.analyzeAndTraverse(
    visitLocalClosureIdentifiers,
    collectClosureIdentsAndTraverse,
    node,
    path,
    state
  );
}

function collectBlockIdentsAndTraverse(node, path, state) {
  utils.analyzeAndTraverse(
    visitLocalBlockIdentifiers,
    collectBlockIdentsAndTraverse,
    node,
    path,
    state
  );
}

function visitLocalClosureIdentifiers(node, path, state) {
  var metaData;
  switch (node.type) {
    case Syntax.ArrowFunctionExpression:
    case Syntax.FunctionExpression:
      // Function expressions don't get their names (if there is one) added to
      // the closure scope they're defined in
      return false;
    case Syntax.ClassDeclaration:
    case Syntax.ClassExpression:
    case Syntax.FunctionDeclaration:
      if (node.id) {
        metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);
        declareIdentInScope(node.id.name, metaData, state);
      }
      return false;
    case Syntax.VariableDeclarator:
      // Variables have function-local scope
      if (path[0].kind === 'var') {
        metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);
        declareIdentInScope(node.id.name, metaData, state);
      }
      break;
  }
}

function visitLocalBlockIdentifiers(node, path, state) {
  // TODO: Support 'let' here...maybe...one day...or something...
  if (node.type === Syntax.CatchClause) {
    return false;
  }
}

function walker(node, path, state) {
  var visitors = state.g.visitors;
  for (var i = 0; i < visitors.length; i++) {
    if (visitors[i].test(node, path, state)) {
      return visitors[i](traverse, node, path, state);
    }
  }
}

var _astCache = {};

function getAstForSource(source, options) {
  if (_astCache[source] && !options.disableAstCache) {
    return _astCache[source];
  }
  var ast = esprima.parse(source, {
    comment: true,
    loc: true,
    range: true,
    sourceType: options.sourceType
  });
  if (!options.disableAstCache) {
    _astCache[source] = ast;
  }
  return ast;
}

/**
 * Applies all available transformations to the source
 * @param {array} visitors
 * @param {string} source
 * @param {?object} options
 * @return {object}
 */
function transform(visitors, source, options) {
  options = options || {};
  var ast;
  try {
    ast = getAstForSource(source, options);
    } catch (e) {
    e.message = 'Parse Error: ' + e.message;
    throw e;
  }
  var state = utils.createState(source, ast, options);
  state.g.visitors = visitors;

  if (options.sourceMap) {
    var SourceMapGenerator = require('source-map').SourceMapGenerator;
    state.g.sourceMap = new SourceMapGenerator({file: options.filename || 'transformed.js'});
  }

  traverse(ast, [], state);
  utils.catchup(source.length, state);

  var ret = {code: state.g.buffer, extra: state.g.extra};
  if (options.sourceMap) {
    ret.sourceMap = state.g.sourceMap;
    ret.sourceMapFilename =  options.filename || 'source.js';
  }
  return ret;
}

exports.transform = transform;
exports.Syntax = Syntax;

},{"./utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js","source-map":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/source-map/lib/source-map.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*jslint node: true*/
var Syntax = require('esprima-fb').Syntax;
var leadingIndentRegexp = /(^|\n)( {2}|\t)/g;
var nonWhiteRegexp = /(\S)/g;

/**
 * A `state` object represents the state of the parser. It has "local" and
 * "global" parts. Global contains parser position, source, etc. Local contains
 * scope based properties like current class name. State should contain all the
 * info required for transformation. It's the only mandatory object that is
 * being passed to every function in transform chain.
 *
 * @param  {string} source
 * @param  {object} transformOptions
 * @return {object}
 */
function createState(source, rootNode, transformOptions) {
  return {
    /**
     * A tree representing the current local scope (and its lexical scope chain)
     * Useful for tracking identifiers from parent scopes, etc.
     * @type {Object}
     */
    localScope: {
      parentNode: rootNode,
      parentScope: null,
      identifiers: {},
      tempVarIndex: 0,
      tempVars: []
    },
    /**
     * The name (and, if applicable, expression) of the super class
     * @type {Object}
     */
    superClass: null,
    /**
     * The namespace to use when munging identifiers
     * @type {String}
     */
    mungeNamespace: '',
    /**
     * Ref to the node for the current MethodDefinition
     * @type {Object}
     */
    methodNode: null,
    /**
     * Ref to the node for the FunctionExpression of the enclosing
     * MethodDefinition
     * @type {Object}
     */
    methodFuncNode: null,
    /**
     * Name of the enclosing class
     * @type {String}
     */
    className: null,
    /**
     * Whether we're currently within a `strict` scope
     * @type {Bool}
     */
    scopeIsStrict: null,
    /**
     * Indentation offset
     * @type {Number}
     */
    indentBy: 0,
    /**
     * Global state (not affected by updateState)
     * @type {Object}
     */
    g: {
      /**
       * A set of general options that transformations can consider while doing
       * a transformation:
       *
       * - minify
       *   Specifies that transformation steps should do their best to minify
       *   the output source when possible. This is useful for places where
       *   minification optimizations are possible with higher-level context
       *   info than what jsxmin can provide.
       *
       *   For example, the ES6 class transform will minify munged private
       *   variables if this flag is set.
       */
      opts: transformOptions,
      /**
       * Current position in the source code
       * @type {Number}
       */
      position: 0,
      /**
       * Auxiliary data to be returned by transforms
       * @type {Object}
       */
      extra: {},
      /**
       * Buffer containing the result
       * @type {String}
       */
      buffer: '',
      /**
       * Source that is being transformed
       * @type {String}
       */
      source: source,

      /**
       * Cached parsed docblock (see getDocblock)
       * @type {object}
       */
      docblock: null,

      /**
       * Whether the thing was used
       * @type {Boolean}
       */
      tagNamespaceUsed: false,

      /**
       * If using bolt xjs transformation
       * @type {Boolean}
       */
      isBolt: undefined,

      /**
       * Whether to record source map (expensive) or not
       * @type {SourceMapGenerator|null}
       */
      sourceMap: null,

      /**
       * Filename of the file being processed. Will be returned as a source
       * attribute in the source map
       */
      sourceMapFilename: 'source.js',

      /**
       * Only when source map is used: last line in the source for which
       * source map was generated
       * @type {Number}
       */
      sourceLine: 1,

      /**
       * Only when source map is used: last line in the buffer for which
       * source map was generated
       * @type {Number}
       */
      bufferLine: 1,

      /**
       * The top-level Program AST for the original file.
       */
      originalProgramAST: null,

      sourceColumn: 0,
      bufferColumn: 0
    }
  };
}

/**
 * Updates a copy of a given state with "update" and returns an updated state.
 *
 * @param  {object} state
 * @param  {object} update
 * @return {object}
 */
function updateState(state, update) {
  var ret = Object.create(state);
  Object.keys(update).forEach(function(updatedKey) {
    ret[updatedKey] = update[updatedKey];
  });
  return ret;
}

/**
 * Given a state fill the resulting buffer from the original source up to
 * the end
 *
 * @param {number} end
 * @param {object} state
 * @param {?function} contentTransformer Optional callback to transform newly
 *                                       added content.
 */
function catchup(end, state, contentTransformer) {
  if (end < state.g.position) {
    // cannot move backwards
    return;
  }
  var source = state.g.source.substring(state.g.position, end);
  var transformed = updateIndent(source, state);
  if (state.g.sourceMap && transformed) {
    // record where we are
    state.g.sourceMap.addMapping({
      generated: { line: state.g.bufferLine, column: state.g.bufferColumn },
      original: { line: state.g.sourceLine, column: state.g.sourceColumn },
      source: state.g.sourceMapFilename
    });

    // record line breaks in transformed source
    var sourceLines = source.split('\n');
    var transformedLines = transformed.split('\n');
    // Add line break mappings between last known mapping and the end of the
    // added piece. So for the code piece
    //  (foo, bar);
    // > var x = 2;
    // > var b = 3;
    //   var c =
    // only add lines marked with ">": 2, 3.
    for (var i = 1; i < sourceLines.length - 1; i++) {
      state.g.sourceMap.addMapping({
        generated: { line: state.g.bufferLine, column: 0 },
        original: { line: state.g.sourceLine, column: 0 },
        source: state.g.sourceMapFilename
      });
      state.g.sourceLine++;
      state.g.bufferLine++;
    }
    // offset for the last piece
    if (sourceLines.length > 1) {
      state.g.sourceLine++;
      state.g.bufferLine++;
      state.g.sourceColumn = 0;
      state.g.bufferColumn = 0;
    }
    state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;
    state.g.bufferColumn +=
      transformedLines[transformedLines.length - 1].length;
  }
  state.g.buffer +=
    contentTransformer ? contentTransformer(transformed) : transformed;
  state.g.position = end;
}

/**
 * Returns original source for an AST node.
 * @param {object} node
 * @param {object} state
 * @return {string}
 */
function getNodeSourceText(node, state) {
  return state.g.source.substring(node.range[0], node.range[1]);
}

function _replaceNonWhite(value) {
  return value.replace(nonWhiteRegexp, ' ');
}

/**
 * Removes all non-whitespace characters
 */
function _stripNonWhite(value) {
  return value.replace(nonWhiteRegexp, '');
}

/**
 * Finds the position of the next instance of the specified syntactic char in
 * the pending source.
 *
 * NOTE: This will skip instances of the specified char if they sit inside a
 *       comment body.
 *
 * NOTE: This function also assumes that the buffer's current position is not
 *       already within a comment or a string. This is rarely the case since all
 *       of the buffer-advancement utility methods tend to be used on syntactic
 *       nodes' range values -- but it's a small gotcha that's worth mentioning.
 */
function getNextSyntacticCharOffset(char, state) {
  var pendingSource = state.g.source.substring(state.g.position);
  var pendingSourceLines = pendingSource.split('\n');

  var charOffset = 0;
  var line;
  var withinBlockComment = false;
  var withinString = false;
  lineLoop: while ((line = pendingSourceLines.shift()) !== undefined) {
    var lineEndPos = charOffset + line.length;
    charLoop: for (; charOffset < lineEndPos; charOffset++) {
      var currChar = pendingSource[charOffset];
      if (currChar === '"' || currChar === '\'') {
        withinString = !withinString;
        continue charLoop;
      } else if (withinString) {
        continue charLoop;
      } else if (charOffset + 1 < lineEndPos) {
        var nextTwoChars = currChar + line[charOffset + 1];
        if (nextTwoChars === '//') {
          charOffset = lineEndPos + 1;
          continue lineLoop;
        } else if (nextTwoChars === '/*') {
          withinBlockComment = true;
          charOffset += 1;
          continue charLoop;
        } else if (nextTwoChars === '*/') {
          withinBlockComment = false;
          charOffset += 1;
          continue charLoop;
        }
      }

      if (!withinBlockComment && currChar === char) {
        return charOffset + state.g.position;
      }
    }

    // Account for '\n'
    charOffset++;
    withinString = false;
  }

  throw new Error('`' + char + '` not found!');
}

/**
 * Catches up as `catchup` but replaces non-whitespace chars with spaces.
 */
function catchupWhiteOut(end, state) {
  catchup(end, state, _replaceNonWhite);
}

/**
 * Catches up as `catchup` but removes all non-whitespace characters.
 */
function catchupWhiteSpace(end, state) {
  catchup(end, state, _stripNonWhite);
}

/**
 * Removes all non-newline characters
 */
var reNonNewline = /[^\n]/g;
function stripNonNewline(value) {
  return value.replace(reNonNewline, function() {
    return '';
  });
}

/**
 * Catches up as `catchup` but removes all non-newline characters.
 *
 * Equivalent to appending as many newlines as there are in the original source
 * between the current position and `end`.
 */
function catchupNewlines(end, state) {
  catchup(end, state, stripNonNewline);
}


/**
 * Same as catchup but does not touch the buffer
 *
 * @param  {number} end
 * @param  {object} state
 */
function move(end, state) {
  // move the internal cursors
  if (state.g.sourceMap) {
    if (end < state.g.position) {
      state.g.position = 0;
      state.g.sourceLine = 1;
      state.g.sourceColumn = 0;
    }

    var source = state.g.source.substring(state.g.position, end);
    var sourceLines = source.split('\n');
    if (sourceLines.length > 1) {
      state.g.sourceLine += sourceLines.length - 1;
      state.g.sourceColumn = 0;
    }
    state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;
  }
  state.g.position = end;
}

/**
 * Appends a string of text to the buffer
 *
 * @param {string} str
 * @param {object} state
 */
function append(str, state) {
  if (state.g.sourceMap && str) {
    state.g.sourceMap.addMapping({
      generated: { line: state.g.bufferLine, column: state.g.bufferColumn },
      original: { line: state.g.sourceLine, column: state.g.sourceColumn },
      source: state.g.sourceMapFilename
    });
    var transformedLines = str.split('\n');
    if (transformedLines.length > 1) {
      state.g.bufferLine += transformedLines.length - 1;
      state.g.bufferColumn = 0;
    }
    state.g.bufferColumn +=
      transformedLines[transformedLines.length - 1].length;
  }
  state.g.buffer += str;
}

/**
 * Update indent using state.indentBy property. Indent is measured in
 * double spaces. Updates a single line only.
 *
 * @param {string} str
 * @param {object} state
 * @return {string}
 */
function updateIndent(str, state) {
  /*jshint -W004*/
  var indentBy = state.indentBy;
  if (indentBy < 0) {
    for (var i = 0; i < -indentBy; i++) {
      str = str.replace(leadingIndentRegexp, '$1');
    }
  } else {
    for (var i = 0; i < indentBy; i++) {
      str = str.replace(leadingIndentRegexp, '$1$2$2');
    }
  }
  return str;
}

/**
 * Calculates indent from the beginning of the line until "start" or the first
 * character before start.
 * @example
 *   "  foo.bar()"
 *         ^
 *       start
 *   indent will be "  "
 *
 * @param  {number} start
 * @param  {object} state
 * @return {string}
 */
function indentBefore(start, state) {
  var end = start;
  start = start - 1;

  while (start > 0 && state.g.source[start] != '\n') {
    if (!state.g.source[start].match(/[ \t]/)) {
      end = start;
    }
    start--;
  }
  return state.g.source.substring(start + 1, end);
}

function getDocblock(state) {
  if (!state.g.docblock) {
    var docblock = require('./docblock');
    state.g.docblock =
      docblock.parseAsObject(docblock.extract(state.g.source));
  }
  return state.g.docblock;
}

function identWithinLexicalScope(identName, state, stopBeforeNode) {
  var currScope = state.localScope;
  while (currScope) {
    if (currScope.identifiers[identName] !== undefined) {
      return true;
    }

    if (stopBeforeNode && currScope.parentNode === stopBeforeNode) {
      break;
    }

    currScope = currScope.parentScope;
  }
  return false;
}

function identInLocalScope(identName, state) {
  return state.localScope.identifiers[identName] !== undefined;
}

/**
 * @param {object} boundaryNode
 * @param {?array} path
 * @return {?object} node
 */
function initScopeMetadata(boundaryNode, path, node) {
  return {
    boundaryNode: boundaryNode,
    bindingPath: path,
    bindingNode: node
  };
}

function declareIdentInLocalScope(identName, metaData, state) {
  state.localScope.identifiers[identName] = {
    boundaryNode: metaData.boundaryNode,
    path: metaData.bindingPath,
    node: metaData.bindingNode,
    state: Object.create(state)
  };
}

function getLexicalBindingMetadata(identName, state) {
  var currScope = state.localScope;
  while (currScope) {
    if (currScope.identifiers[identName] !== undefined) {
      return currScope.identifiers[identName];
    }

    currScope = currScope.parentScope;
  }
}

function getLocalBindingMetadata(identName, state) {
  return state.localScope.identifiers[identName];
}

/**
 * Apply the given analyzer function to the current node. If the analyzer
 * doesn't return false, traverse each child of the current node using the given
 * traverser function.
 *
 * @param {function} analyzer
 * @param {function} traverser
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function analyzeAndTraverse(analyzer, traverser, node, path, state) {
  if (node.type) {
    if (analyzer(node, path, state) === false) {
      return;
    }
    path.unshift(node);
  }

  getOrderedChildren(node).forEach(function(child) {
    traverser(child, path, state);
  });

  node.type && path.shift();
}

/**
 * It is crucial that we traverse in order, or else catchup() on a later
 * node that is processed out of order can move the buffer past a node
 * that we haven't handled yet, preventing us from modifying that node.
 *
 * This can happen when a node has multiple properties containing children.
 * For example, XJSElement nodes have `openingElement`, `closingElement` and
 * `children`. If we traverse `openingElement`, then `closingElement`, then
 * when we get to `children`, the buffer has already caught up to the end of
 * the closing element, after the children.
 *
 * This is basically a Schwartzian transform. Collects an array of children,
 * each one represented as [child, startIndex]; sorts the array by start
 * index; then traverses the children in that order.
 */
function getOrderedChildren(node) {
  var queue = [];
  for (var key in node) {
    if (node.hasOwnProperty(key)) {
      enqueueNodeWithStartIndex(queue, node[key]);
    }
  }
  queue.sort(function(a, b) { return a[1] - b[1]; });
  return queue.map(function(pair) { return pair[0]; });
}

/**
 * Helper function for analyzeAndTraverse which queues up all of the children
 * of the given node.
 *
 * Children can also be found in arrays, so we basically want to merge all of
 * those arrays together so we can sort them and then traverse the children
 * in order.
 *
 * One example is the Program node. It contains `body` and `comments`, both
 * arrays. Lexographically, comments are interspersed throughout the body
 * nodes, but esprima's AST groups them together.
 */
function enqueueNodeWithStartIndex(queue, node) {
  if (typeof node !== 'object' || node === null) {
    return;
  }
  if (node.range) {
    queue.push([node, node.range[0]]);
  } else if (Array.isArray(node)) {
    for (var ii = 0; ii < node.length; ii++) {
      enqueueNodeWithStartIndex(queue, node[ii]);
    }
  }
}

/**
 * Checks whether a node or any of its sub-nodes contains
 * a syntactic construct of the passed type.
 * @param {object} node - AST node to test.
 * @param {string} type - node type to lookup.
 */
function containsChildOfType(node, type) {
  return containsChildMatching(node, function(node) {
    return node.type === type;
  });
}

function containsChildMatching(node, matcher) {
  var foundMatchingChild = false;
  function nodeTypeAnalyzer(node) {
    if (matcher(node) === true) {
      foundMatchingChild = true;
      return false;
    }
  }
  function nodeTypeTraverser(child, path, state) {
    if (!foundMatchingChild) {
      foundMatchingChild = containsChildMatching(child, matcher);
    }
  }
  analyzeAndTraverse(
    nodeTypeAnalyzer,
    nodeTypeTraverser,
    node,
    []
  );
  return foundMatchingChild;
}

var scopeTypes = {};
scopeTypes[Syntax.ArrowFunctionExpression] = true;
scopeTypes[Syntax.FunctionExpression] = true;
scopeTypes[Syntax.FunctionDeclaration] = true;
scopeTypes[Syntax.Program] = true;

function getBoundaryNode(path) {
  for (var ii = 0; ii < path.length; ++ii) {
    if (scopeTypes[path[ii].type]) {
      return path[ii];
    }
  }
  throw new Error(
    'Expected to find a node with one of the following types in path:\n' +
    JSON.stringify(Object.keys(scopeTypes))
  );
}

function getTempVar(tempVarIndex) {
  return '$__' + tempVarIndex;
}

function injectTempVar(state) {
  var tempVar = '$__' + (state.localScope.tempVarIndex++);
  state.localScope.tempVars.push(tempVar);
  return tempVar;
}

function injectTempVarDeclarations(state, index) {
  if (state.localScope.tempVars.length) {
    state.g.buffer =
      state.g.buffer.slice(0, index) +
      'var ' + state.localScope.tempVars.join(', ') + ';' +
      state.g.buffer.slice(index);
    state.localScope.tempVars = [];
  }
}

exports.analyzeAndTraverse = analyzeAndTraverse;
exports.append = append;
exports.catchup = catchup;
exports.catchupNewlines = catchupNewlines;
exports.catchupWhiteOut = catchupWhiteOut;
exports.catchupWhiteSpace = catchupWhiteSpace;
exports.containsChildMatching = containsChildMatching;
exports.containsChildOfType = containsChildOfType;
exports.createState = createState;
exports.declareIdentInLocalScope = declareIdentInLocalScope;
exports.getBoundaryNode = getBoundaryNode;
exports.getDocblock = getDocblock;
exports.getLexicalBindingMetadata = getLexicalBindingMetadata;
exports.getLocalBindingMetadata = getLocalBindingMetadata;
exports.getNextSyntacticCharOffset = getNextSyntacticCharOffset;
exports.getNodeSourceText = getNodeSourceText;
exports.getOrderedChildren = getOrderedChildren;
exports.getTempVar = getTempVar;
exports.identInLocalScope = identInLocalScope;
exports.identWithinLexicalScope = identWithinLexicalScope;
exports.indentBefore = indentBefore;
exports.initScopeMetadata = initScopeMetadata;
exports.injectTempVar = injectTempVar;
exports.injectTempVarDeclarations = injectTempVarDeclarations;
exports.move = move;
exports.scopeTypes = scopeTypes;
exports.updateIndent = updateIndent;
exports.updateState = updateState;

},{"./docblock":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/docblock.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-arrow-function-visitors.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global exports:true*/

/**
 * Desugars ES6 Arrow functions to ES3 function expressions.
 * If the function contains `this` expression -- automatically
 * binds the function to current value of `this`.
 *
 * Single parameter, simple expression:
 *
 * [1, 2, 3].map(x => x * x);
 *
 * [1, 2, 3].map(function(x) { return x * x; });
 *
 * Several parameters, complex block:
 *
 * this.users.forEach((user, idx) => {
 *   return this.isActive(idx) && this.send(user);
 * });
 *
 * this.users.forEach(function(user, idx) {
 *   return this.isActive(idx) && this.send(user);
 * }.bind(this));
 *
 */
var restParamVisitors = require('./es6-rest-param-visitors');
var destructuringVisitors = require('./es6-destructuring-visitors');

var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');

/**
 * @public
 */
function visitArrowFunction(traverse, node, path, state) {
  var notInExpression = (path[0].type === Syntax.ExpressionStatement);

  // Wrap a function into a grouping operator, if it's not
  // in the expression position.
  if (notInExpression) {
    utils.append('(', state);
  }

  utils.append('function', state);
  renderParams(traverse, node, path, state);

  // Skip arrow.
  utils.catchupWhiteSpace(node.body.range[0], state);

  var renderBody = node.body.type == Syntax.BlockStatement
    ? renderStatementBody
    : renderExpressionBody;

  path.unshift(node);
  renderBody(traverse, node, path, state);
  path.shift();

  // Bind the function only if `this` value is used
  // inside it or inside any sub-expression.
  var containsBindingSyntax =
    utils.containsChildMatching(node.body, function(node) {
      return node.type === Syntax.ThisExpression
             || (node.type === Syntax.Identifier
                 && node.name === "super");
    });

  if (containsBindingSyntax) {
    utils.append('.bind(this)', state);
  }

  utils.catchupWhiteSpace(node.range[1], state);

  // Close wrapper if not in the expression.
  if (notInExpression) {
    utils.append(')', state);
  }

  return false;
}

function renderParams(traverse, node, path, state) {
  // To preserve inline typechecking directives, we
  // distinguish between parens-free and paranthesized single param.
  if (isParensFreeSingleParam(node, state) || !node.params.length) {
    utils.append('(', state);
  }
  if (node.params.length !== 0) {
    path.unshift(node);
    traverse(node.params, path, state);
    path.unshift();
  }
  utils.append(')', state);
}

function isParensFreeSingleParam(node, state) {
  return node.params.length === 1 &&
    state.g.source[state.g.position] !== '(';
}

function renderExpressionBody(traverse, node, path, state) {
  // Wrap simple expression bodies into a block
  // with explicit return statement.
  utils.append('{', state);

  // Special handling of rest param.
  if (node.rest) {
    utils.append(
      restParamVisitors.renderRestParamSetup(node, state),
      state
    );
  }

  // Special handling of destructured params.
  destructuringVisitors.renderDestructuredComponents(
    node,
    utils.updateState(state, {
      localScope: {
        parentNode: state.parentNode,
        parentScope: state.parentScope,
        identifiers: state.identifiers,
        tempVarIndex: 0
      }
    })
  );

  utils.append('return ', state);
  renderStatementBody(traverse, node, path, state);
  utils.append(';}', state);
}

function renderStatementBody(traverse, node, path, state) {
  traverse(node.body, path, state);
  utils.catchup(node.body.range[1], state);
}

visitArrowFunction.test = function(node, path, state) {
  return node.type === Syntax.ArrowFunctionExpression;
};

exports.visitorList = [
  visitArrowFunction
];


},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","./es6-destructuring-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-destructuring-visitors.js","./es6-rest-param-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-rest-param-visitors.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-call-spread-visitors.js":[function(require,module,exports){
/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 */
/*global exports:true*/

/**
 * Implements ES6 call spread.
 *
 * instance.method(a, b, c, ...d)
 *
 * instance.method.apply(instance, [a, b, c].concat(d))
 *
 */

var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');

function process(traverse, node, path, state) {
  utils.move(node.range[0], state);
  traverse(node, path, state);
  utils.catchup(node.range[1], state);
}

function visitCallSpread(traverse, node, path, state) {
  utils.catchup(node.range[0], state);

  if (node.type === Syntax.NewExpression) {
    // Input  = new Set(1, 2, ...list)
    // Output = new (Function.prototype.bind.apply(Set, [null, 1, 2].concat(list)))
    utils.append('new (Function.prototype.bind.apply(', state);
    process(traverse, node.callee, path, state);
  } else if (node.callee.type === Syntax.MemberExpression) {
    // Input  = get().fn(1, 2, ...more)
    // Output = (_ = get()).fn.apply(_, [1, 2].apply(more))
    var tempVar = utils.injectTempVar(state);
    utils.append('(' + tempVar + ' = ', state);
    process(traverse, node.callee.object, path, state);
    utils.append(')', state);
    if (node.callee.property.type === Syntax.Identifier) {
      utils.append('.', state);
      process(traverse, node.callee.property, path, state);
    } else {
      utils.append('[', state);
      process(traverse, node.callee.property, path, state);
      utils.append(']', state);
    }
    utils.append('.apply(' + tempVar, state);
  } else {
    // Input  = max(1, 2, ...list)
    // Output = max.apply(null, [1, 2].concat(list))
    var needsToBeWrappedInParenthesis =
      node.callee.type === Syntax.FunctionDeclaration ||
      node.callee.type === Syntax.FunctionExpression;
    if (needsToBeWrappedInParenthesis) {
      utils.append('(', state);
    }
    process(traverse, node.callee, path, state);
    if (needsToBeWrappedInParenthesis) {
      utils.append(')', state);
    }
    utils.append('.apply(null', state);
  }
  utils.append(', ', state);

  var args = node.arguments.slice();
  var spread = args.pop();
  if (args.length || node.type === Syntax.NewExpression) {
    utils.append('[', state);
    if (node.type === Syntax.NewExpression) {
      utils.append('null' + (args.length ? ', ' : ''), state);
    }
    while (args.length) {
      var arg = args.shift();
      utils.move(arg.range[0], state);
      traverse(arg, path, state);
      if (args.length) {
        utils.catchup(args[0].range[0], state);
      } else {
        utils.catchup(arg.range[1], state);
      }
    }
    utils.append('].concat(', state);
    process(traverse, spread.argument, path, state);
    utils.append(')', state);
  } else {
    process(traverse, spread.argument, path, state);
  }
  utils.append(node.type === Syntax.NewExpression ? '))' : ')', state);

  utils.move(node.range[1], state);
  return false;
}

visitCallSpread.test = function(node, path, state) {
  return (
    (
      node.type === Syntax.CallExpression ||
      node.type === Syntax.NewExpression
    ) &&
    node.arguments.length > 0 &&
    node.arguments[node.arguments.length - 1].type === Syntax.SpreadElement
  );
};

exports.visitorList = [
  visitCallSpread,
];

},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-class-visitors.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * @typechecks
 */
'use strict';

var base62 = require('base62');
var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');
var reservedWordsHelper = require('./reserved-words-helper');

var declareIdentInLocalScope = utils.declareIdentInLocalScope;
var initScopeMetadata = utils.initScopeMetadata;

var SUPER_PROTO_IDENT_PREFIX = '____SuperProtoOf';

var _anonClassUUIDCounter = 0;
var _mungedSymbolMaps = {};

function resetSymbols() {
  _anonClassUUIDCounter = 0;
  _mungedSymbolMaps = {};
}

/**
 * Used to generate a unique class for use with code-gens for anonymous class
 * expressions.
 *
 * @param {object} state
 * @return {string}
 */
function _generateAnonymousClassName(state) {
  var mungeNamespace = state.mungeNamespace || '';
  return '____Class' + mungeNamespace + base62.encode(_anonClassUUIDCounter++);
}

/**
 * Given an identifier name, munge it using the current state's mungeNamespace.
 *
 * @param {string} identName
 * @param {object} state
 * @return {string}
 */
function _getMungedName(identName, state) {
  var mungeNamespace = state.mungeNamespace;
  var shouldMinify = state.g.opts.minify;

  if (shouldMinify) {
    if (!_mungedSymbolMaps[mungeNamespace]) {
      _mungedSymbolMaps[mungeNamespace] = {
        symbolMap: {},
        identUUIDCounter: 0
      };
    }

    var symbolMap = _mungedSymbolMaps[mungeNamespace].symbolMap;
    if (!symbolMap[identName]) {
      symbolMap[identName] =
        base62.encode(_mungedSymbolMaps[mungeNamespace].identUUIDCounter++);
    }
    identName = symbolMap[identName];
  }
  return '$' + mungeNamespace + identName;
}

/**
 * Extracts super class information from a class node.
 *
 * Information includes name of the super class and/or the expression string
 * (if extending from an expression)
 *
 * @param {object} node
 * @param {object} state
 * @return {object}
 */
function _getSuperClassInfo(node, state) {
  var ret = {
    name: null,
    expression: null
  };
  if (node.superClass) {
    if (node.superClass.type === Syntax.Identifier) {
      ret.name = node.superClass.name;
    } else {
      // Extension from an expression
      ret.name = _generateAnonymousClassName(state);
      ret.expression = state.g.source.substring(
        node.superClass.range[0],
        node.superClass.range[1]
      );
    }
  }
  return ret;
}

/**
 * Used with .filter() to find the constructor method in a list of
 * MethodDefinition nodes.
 *
 * @param {object} classElement
 * @return {boolean}
 */
function _isConstructorMethod(classElement) {
  return classElement.type === Syntax.MethodDefinition &&
         classElement.key.type === Syntax.Identifier &&
         classElement.key.name === 'constructor';
}

/**
 * @param {object} node
 * @param {object} state
 * @return {boolean}
 */
function _shouldMungeIdentifier(node, state) {
  return (
    !!state.methodFuncNode &&
    !utils.getDocblock(state).hasOwnProperty('preventMunge') &&
    /^_(?!_)/.test(node.name)
  );
}

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitClassMethod(traverse, node, path, state) {
  if (!state.g.opts.es5 && (node.kind === 'get' || node.kind === 'set')) {
    throw new Error(
      'This transform does not support ' + node.kind + 'ter methods for ES6 ' +
      'classes. (line: ' + node.loc.start.line + ', col: ' +
      node.loc.start.column + ')'
    );
  }
  state = utils.updateState(state, {
    methodNode: node
  });
  utils.catchup(node.range[0], state);
  path.unshift(node);
  traverse(node.value, path, state);
  path.shift();
  return false;
}
visitClassMethod.test = function(node, path, state) {
  return node.type === Syntax.MethodDefinition;
};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitClassFunctionExpression(traverse, node, path, state) {
  var methodNode = path[0];
  var isGetter = methodNode.kind === 'get';
  var isSetter = methodNode.kind === 'set';

  state = utils.updateState(state, {
    methodFuncNode: node
  });

  if (methodNode.key.name === 'constructor') {
    utils.append('function ' + state.className, state);
  } else {
    var methodAccessorComputed = false;
    var methodAccessor;
    var prototypeOrStatic = methodNode.static ? '' : '.prototype';
    var objectAccessor = state.className + prototypeOrStatic;

    if (methodNode.key.type === Syntax.Identifier) {
      // foo() {}
      methodAccessor = methodNode.key.name;
      if (_shouldMungeIdentifier(methodNode.key, state)) {
        methodAccessor = _getMungedName(methodAccessor, state);
      }
      if (isGetter || isSetter) {
        methodAccessor = JSON.stringify(methodAccessor);
      } else if (reservedWordsHelper.isReservedWord(methodAccessor)) {
        methodAccessorComputed = true;
        methodAccessor = JSON.stringify(methodAccessor);
      }
    } else if (methodNode.key.type === Syntax.Literal) {
      // 'foo bar'() {}  | get 'foo bar'() {} | set 'foo bar'() {}
      methodAccessor = JSON.stringify(methodNode.key.value);
      methodAccessorComputed = true;
    }

    if (isSetter || isGetter) {
      utils.append(
        'Object.defineProperty(' +
          objectAccessor + ',' +
          methodAccessor + ',' +
          '{configurable:true,' +
          methodNode.kind + ':function',
        state
      );
    } else {
      if (state.g.opts.es3) {
        if (methodAccessorComputed) {
          methodAccessor = '[' + methodAccessor + ']';
        } else {
          methodAccessor = '.' + methodAccessor;
        }
        utils.append(
          objectAccessor +
          methodAccessor + '=function' + (node.generator ? '*' : ''),
          state
        );
      } else {
        if (!methodAccessorComputed) {
          methodAccessor = JSON.stringify(methodAccessor);
        }
        utils.append(
          'Object.defineProperty(' +
            objectAccessor + ',' +
            methodAccessor + ',' +
            '{writable:true,configurable:true,' +
            'value:function' + (node.generator ? '*' : ''),
          state
        );
      }
    }
  }
  utils.move(methodNode.key.range[1], state);
  utils.append('(', state);

  var params = node.params;
  if (params.length > 0) {
    utils.catchupNewlines(params[0].range[0], state);
    for (var i = 0; i < params.length; i++) {
      utils.catchup(node.params[i].range[0], state);
      path.unshift(node);
      traverse(params[i], path, state);
      path.shift();
    }
  }

  var closingParenPosition = utils.getNextSyntacticCharOffset(')', state);
  utils.catchupWhiteSpace(closingParenPosition, state);

  var openingBracketPosition = utils.getNextSyntacticCharOffset('{', state);
  utils.catchup(openingBracketPosition + 1, state);

  if (!state.scopeIsStrict) {
    utils.append('"use strict";', state);
    state = utils.updateState(state, {
      scopeIsStrict: true
    });
  }
  utils.move(node.body.range[0] + '{'.length, state);

  path.unshift(node);
  traverse(node.body, path, state);
  path.shift();
  utils.catchup(node.body.range[1], state);

  if (methodNode.key.name !== 'constructor') {
    if (isGetter || isSetter || !state.g.opts.es3) {
      utils.append('})', state);
    }
    utils.append(';', state);
  }
  return false;
}
visitClassFunctionExpression.test = function(node, path, state) {
  return node.type === Syntax.FunctionExpression
         && path[0].type === Syntax.MethodDefinition;
};

function visitClassMethodParam(traverse, node, path, state) {
  var paramName = node.name;
  if (_shouldMungeIdentifier(node, state)) {
    paramName = _getMungedName(node.name, state);
  }
  utils.append(paramName, state);
  utils.move(node.range[1], state);
}
visitClassMethodParam.test = function(node, path, state) {
  if (!path[0] || !path[1]) {
    return;
  }

  var parentFuncExpr = path[0];
  var parentClassMethod = path[1];

  return parentFuncExpr.type === Syntax.FunctionExpression
         && parentClassMethod.type === Syntax.MethodDefinition
         && node.type === Syntax.Identifier;
};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function _renderClassBody(traverse, node, path, state) {
  var className = state.className;
  var superClass = state.superClass;

  // Set up prototype of constructor on same line as `extends` for line-number
  // preservation. This relies on function-hoisting if a constructor function is
  // defined in the class body.
  if (superClass.name) {
    // If the super class is an expression, we need to memoize the output of the
    // expression into the generated class name variable and use that to refer
    // to the super class going forward. Example:
    //
    //   class Foo extends mixin(Bar, Baz) {}
    //     --transforms to--
    //   function Foo() {} var ____Class0Blah = mixin(Bar, Baz);
    if (superClass.expression !== null) {
      utils.append(
        'var ' + superClass.name + '=' + superClass.expression + ';',
        state
      );
    }

    var keyName = superClass.name + '____Key';
    var keyNameDeclarator = '';
    if (!utils.identWithinLexicalScope(keyName, state)) {
      keyNameDeclarator = 'var ';
      declareIdentInLocalScope(keyName, initScopeMetadata(node), state);
    }
    utils.append(
      'for(' + keyNameDeclarator + keyName + ' in ' + superClass.name + '){' +
        'if(' + superClass.name + '.hasOwnProperty(' + keyName + ')){' +
          className + '[' + keyName + ']=' +
            superClass.name + '[' + keyName + '];' +
        '}' +
      '}',
      state
    );

    var superProtoIdentStr = SUPER_PROTO_IDENT_PREFIX + superClass.name;
    if (!utils.identWithinLexicalScope(superProtoIdentStr, state)) {
      utils.append(
        'var ' + superProtoIdentStr + '=' + superClass.name + '===null?' +
        'null:' + superClass.name + '.prototype;',
        state
      );
      declareIdentInLocalScope(superProtoIdentStr, initScopeMetadata(node), state);
    }

    utils.append(
      className + '.prototype=Object.create(' + superProtoIdentStr + ');',
      state
    );
    utils.append(
      className + '.prototype.constructor=' + className + ';',
      state
    );
    utils.append(
      className + '.__superConstructor__=' + superClass.name + ';',
      state
    );
  }

  // If there's no constructor method specified in the class body, create an
  // empty constructor function at the top (same line as the class keyword)
  if (!node.body.body.filter(_isConstructorMethod).pop()) {
    utils.append('function ' + className + '(){', state);
    if (!state.scopeIsStrict) {
      utils.append('"use strict";', state);
    }
    if (superClass.name) {
      utils.append(
        'if(' + superClass.name + '!==null){' +
        superClass.name + '.apply(this,arguments);}',
        state
      );
    }
    utils.append('}', state);
  }

  utils.move(node.body.range[0] + '{'.length, state);
  traverse(node.body, path, state);
  utils.catchupWhiteSpace(node.range[1], state);
}

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitClassDeclaration(traverse, node, path, state) {
  var className = node.id.name;
  var superClass = _getSuperClassInfo(node, state);

  state = utils.updateState(state, {
    mungeNamespace: className,
    className: className,
    superClass: superClass
  });

  _renderClassBody(traverse, node, path, state);

  return false;
}
visitClassDeclaration.test = function(node, path, state) {
  return node.type === Syntax.ClassDeclaration;
};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitClassExpression(traverse, node, path, state) {
  var className = node.id && node.id.name || _generateAnonymousClassName(state);
  var superClass = _getSuperClassInfo(node, state);

  utils.append('(function(){', state);

  state = utils.updateState(state, {
    mungeNamespace: className,
    className: className,
    superClass: superClass
  });

  _renderClassBody(traverse, node, path, state);

  utils.append('return ' + className + ';})()', state);
  return false;
}
visitClassExpression.test = function(node, path, state) {
  return node.type === Syntax.ClassExpression;
};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitPrivateIdentifier(traverse, node, path, state) {
  utils.append(_getMungedName(node.name, state), state);
  utils.move(node.range[1], state);
}
visitPrivateIdentifier.test = function(node, path, state) {
  if (node.type === Syntax.Identifier && _shouldMungeIdentifier(node, state)) {
    // Always munge non-computed properties of MemberExpressions
    // (a la preventing access of properties of unowned objects)
    if (path[0].type === Syntax.MemberExpression && path[0].object !== node
        && path[0].computed === false) {
      return true;
    }

    // Always munge identifiers that were declared within the method function
    // scope
    if (utils.identWithinLexicalScope(node.name, state, state.methodFuncNode)) {
      return true;
    }

    // Always munge private keys on object literals defined within a method's
    // scope.
    if (path[0].type === Syntax.Property
        && path[1].type === Syntax.ObjectExpression) {
      return true;
    }

    // Always munge function parameters
    if (path[0].type === Syntax.FunctionExpression
        || path[0].type === Syntax.FunctionDeclaration
        || path[0].type === Syntax.ArrowFunctionExpression) {
      for (var i = 0; i < path[0].params.length; i++) {
        if (path[0].params[i] === node) {
          return true;
        }
      }
    }
  }
  return false;
};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitSuperCallExpression(traverse, node, path, state) {
  var superClassName = state.superClass.name;

  if (node.callee.type === Syntax.Identifier) {
    if (_isConstructorMethod(state.methodNode)) {
      utils.append(superClassName + '.call(', state);
    } else {
      var protoProp = SUPER_PROTO_IDENT_PREFIX + superClassName;
      if (state.methodNode.key.type === Syntax.Identifier) {
        protoProp += '.' + state.methodNode.key.name;
      } else if (state.methodNode.key.type === Syntax.Literal) {
        protoProp += '[' + JSON.stringify(state.methodNode.key.value) + ']';
      }
      utils.append(protoProp + ".call(", state);
    }
    utils.move(node.callee.range[1], state);
  } else if (node.callee.type === Syntax.MemberExpression) {
    utils.append(SUPER_PROTO_IDENT_PREFIX + superClassName, state);
    utils.move(node.callee.object.range[1], state);

    if (node.callee.computed) {
      // ["a" + "b"]
      utils.catchup(node.callee.property.range[1] + ']'.length, state);
    } else {
      // .ab
      utils.append('.' + node.callee.property.name, state);
    }

    utils.append('.call(', state);
    utils.move(node.callee.range[1], state);
  }

  utils.append('this', state);
  if (node.arguments.length > 0) {
    utils.append(',', state);
    utils.catchupWhiteSpace(node.arguments[0].range[0], state);
    traverse(node.arguments, path, state);
  }

  utils.catchupWhiteSpace(node.range[1], state);
  utils.append(')', state);
  return false;
}
visitSuperCallExpression.test = function(node, path, state) {
  if (state.superClass && node.type === Syntax.CallExpression) {
    var callee = node.callee;
    if (callee.type === Syntax.Identifier && callee.name === 'super'
        || callee.type == Syntax.MemberExpression
           && callee.object.name === 'super') {
      return true;
    }
  }
  return false;
};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitSuperMemberExpression(traverse, node, path, state) {
  var superClassName = state.superClass.name;

  utils.append(SUPER_PROTO_IDENT_PREFIX + superClassName, state);
  utils.move(node.object.range[1], state);
}
visitSuperMemberExpression.test = function(node, path, state) {
  return state.superClass
         && node.type === Syntax.MemberExpression
         && node.object.type === Syntax.Identifier
         && node.object.name === 'super';
};

exports.resetSymbols = resetSymbols;

exports.visitorList = [
  visitClassDeclaration,
  visitClassExpression,
  visitClassFunctionExpression,
  visitClassMethod,
  visitClassMethodParam,
  visitPrivateIdentifier,
  visitSuperCallExpression,
  visitSuperMemberExpression
];

},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","./reserved-words-helper":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/reserved-words-helper.js","base62":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/base62/base62.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-destructuring-visitors.js":[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*global exports:true*/

/**
 * Implements ES6 destructuring assignment and pattern matchng.
 *
 * function init({port, ip, coords: [x, y]}) {
 *   return (x && y) ? {id, port} : {ip};
 * };
 *
 * function init($__0) {
 *   var
 *    port = $__0.port,
 *    ip = $__0.ip,
 *    $__1 = $__0.coords,
 *    x = $__1[0],
 *    y = $__1[1];
 *   return (x && y) ? {id, port} : {ip};
 * }
 *
 * var x, {ip, port} = init({ip, port});
 *
 * var x, $__0 = init({ip, port}), ip = $__0.ip, port = $__0.port;
 *
 */
var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');

var reservedWordsHelper = require('./reserved-words-helper');
var restParamVisitors = require('./es6-rest-param-visitors');
var restPropertyHelpers = require('./es7-rest-property-helpers');

// -------------------------------------------------------
// 1. Structured variable declarations.
//
// var [a, b] = [b, a];
// var {x, y} = {y, x};
// -------------------------------------------------------

function visitStructuredVariable(traverse, node, path, state) {
  // Allocate new temp for the pattern.
  utils.append(utils.getTempVar(state.localScope.tempVarIndex) + '=', state);
  // Skip the pattern and assign the init to the temp.
  utils.catchupWhiteSpace(node.init.range[0], state);
  traverse(node.init, path, state);
  utils.catchup(node.init.range[1], state);
  // Render the destructured data.
  utils.append(',' + getDestructuredComponents(node.id, state), state);
  state.localScope.tempVarIndex++;
  return false;
}

visitStructuredVariable.test = function(node, path, state) {
  return node.type === Syntax.VariableDeclarator &&
    isStructuredPattern(node.id);
};

function isStructuredPattern(node) {
  return node.type === Syntax.ObjectPattern ||
    node.type === Syntax.ArrayPattern;
}

// Main function which does actual recursive destructuring
// of nested complex structures.
function getDestructuredComponents(node, state) {
  var tmpIndex = state.localScope.tempVarIndex;
  var components = [];
  var patternItems = getPatternItems(node);

  for (var idx = 0; idx < patternItems.length; idx++) {
    var item = patternItems[idx];
    if (!item) {
      continue;
    }

    if (item.type === Syntax.SpreadElement) {
      // Spread/rest of an array.
      // TODO(dmitrys): support spread in the middle of a pattern
      // and also for function param patterns: [x, ...xs, y]
      components.push(item.argument.name +
        '=Array.prototype.slice.call(' +
        utils.getTempVar(tmpIndex) + ',' + idx + ')'
      );
      continue;
    }

    if (item.type === Syntax.SpreadProperty) {
      var restExpression = restPropertyHelpers.renderRestExpression(
        utils.getTempVar(tmpIndex),
        patternItems
      );
      components.push(item.argument.name + '=' + restExpression);
      continue;
    }

    // Depending on pattern type (Array or Object), we get
    // corresponding pattern item parts.
    var accessor = getPatternItemAccessor(node, item, tmpIndex, idx);
    var value = getPatternItemValue(node, item);

    // TODO(dmitrys): implement default values: {x, y=5}
    if (value.type === Syntax.Identifier) {
      // Simple pattern item.
      components.push(value.name + '=' + accessor);
    } else {
      // Complex sub-structure.
      components.push(
        utils.getTempVar(++state.localScope.tempVarIndex) + '=' + accessor +
        ',' + getDestructuredComponents(value, state)
      );
    }
  }

  return components.join(',');
}

function getPatternItems(node) {
  return node.properties || node.elements;
}

function getPatternItemAccessor(node, patternItem, tmpIndex, idx) {
  var tmpName = utils.getTempVar(tmpIndex);
  if (node.type === Syntax.ObjectPattern) {
    if (reservedWordsHelper.isReservedWord(patternItem.key.name)) {
      return tmpName + '["' + patternItem.key.name + '"]';
    } else if (patternItem.key.type === Syntax.Literal) {
      return tmpName + '[' + JSON.stringify(patternItem.key.value) + ']';
    } else if (patternItem.key.type === Syntax.Identifier) {
      return tmpName + '.' + patternItem.key.name;
    }
  } else if (node.type === Syntax.ArrayPattern) {
    return tmpName + '[' + idx + ']';
  }
}

function getPatternItemValue(node, patternItem) {
  return node.type === Syntax.ObjectPattern
    ? patternItem.value
    : patternItem;
}

// -------------------------------------------------------
// 2. Assignment expression.
//
// [a, b] = [b, a];
// ({x, y} = {y, x});
// -------------------------------------------------------

function visitStructuredAssignment(traverse, node, path, state) {
  var exprNode = node.expression;
  utils.append('var ' + utils.getTempVar(state.localScope.tempVarIndex) + '=', state);

  utils.catchupWhiteSpace(exprNode.right.range[0], state);
  traverse(exprNode.right, path, state);
  utils.catchup(exprNode.right.range[1], state);

  utils.append(
    ';' + getDestructuredComponents(exprNode.left, state) + ';',
    state
  );

  utils.catchupWhiteSpace(node.range[1], state);
  state.localScope.tempVarIndex++;
  return false;
}

visitStructuredAssignment.test = function(node, path, state) {
  // We consider the expression statement rather than just assignment
  // expression to cover case with object patters which should be
  // wrapped in grouping operator: ({x, y} = {y, x});
  return node.type === Syntax.ExpressionStatement &&
    node.expression.type === Syntax.AssignmentExpression &&
    isStructuredPattern(node.expression.left);
};

// -------------------------------------------------------
// 3. Structured parameter.
//
// function foo({x, y}) { ... }
// -------------------------------------------------------

function visitStructuredParameter(traverse, node, path, state) {
  utils.append(utils.getTempVar(getParamIndex(node, path)), state);
  utils.catchupWhiteSpace(node.range[1], state);
  return true;
}

function getParamIndex(paramNode, path) {
  var funcNode = path[0];
  var tmpIndex = 0;
  for (var k = 0; k < funcNode.params.length; k++) {
    var param = funcNode.params[k];
    if (param === paramNode) {
      break;
    }
    if (isStructuredPattern(param)) {
      tmpIndex++;
    }
  }
  return tmpIndex;
}

visitStructuredParameter.test = function(node, path, state) {
  return isStructuredPattern(node) && isFunctionNode(path[0]);
};

function isFunctionNode(node) {
  return (node.type == Syntax.FunctionDeclaration ||
    node.type == Syntax.FunctionExpression ||
    node.type == Syntax.MethodDefinition ||
    node.type == Syntax.ArrowFunctionExpression);
}

// -------------------------------------------------------
// 4. Function body for structured parameters.
//
// function foo({x, y}) { x; y; }
// -------------------------------------------------------

function visitFunctionBodyForStructuredParameter(traverse, node, path, state) {
  var funcNode = path[0];

  utils.catchup(funcNode.body.range[0] + 1, state);
  renderDestructuredComponents(funcNode, state);

  if (funcNode.rest) {
    utils.append(
      restParamVisitors.renderRestParamSetup(funcNode, state),
      state
    );
  }

  return true;
}

function renderDestructuredComponents(funcNode, state) {
  var destructuredComponents = [];

  for (var k = 0; k < funcNode.params.length; k++) {
    var param = funcNode.params[k];
    if (isStructuredPattern(param)) {
      destructuredComponents.push(
        getDestructuredComponents(param, state)
      );
      state.localScope.tempVarIndex++;
    }
  }

  if (destructuredComponents.length) {
    utils.append('var ' + destructuredComponents.join(',') + ';', state);
  }
}

visitFunctionBodyForStructuredParameter.test = function(node, path, state) {
  return node.type === Syntax.BlockStatement && isFunctionNode(path[0]);
};

exports.visitorList = [
  visitStructuredVariable,
  visitStructuredAssignment,
  visitStructuredParameter,
  visitFunctionBodyForStructuredParameter
];

exports.renderDestructuredComponents = renderDestructuredComponents;


},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","./es6-rest-param-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-rest-param-visitors.js","./es7-rest-property-helpers":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es7-rest-property-helpers.js","./reserved-words-helper":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/reserved-words-helper.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-object-concise-method-visitors.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * Desugars concise methods of objects to function expressions.
 *
 * var foo = {
 *   method(x, y) { ... }
 * };
 *
 * var foo = {
 *   method: function(x, y) { ... }
 * };
 *
 */

var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');
var reservedWordsHelper = require('./reserved-words-helper');

function visitObjectConciseMethod(traverse, node, path, state) {
  var isGenerator = node.value.generator;
  if (isGenerator) {
    utils.catchupWhiteSpace(node.range[0] + 1, state);
  }
  if (node.computed) { // [<expr>]() { ...}
    utils.catchup(node.key.range[1] + 1, state);
  } else if (reservedWordsHelper.isReservedWord(node.key.name)) {
    utils.catchup(node.key.range[0], state);
    utils.append('"', state);
    utils.catchup(node.key.range[1], state);
    utils.append('"', state);
  }

  utils.catchup(node.key.range[1], state);
  utils.append(
    ':function' + (isGenerator ? '*' : ''),
    state
  );
  path.unshift(node);
  traverse(node.value, path, state);
  path.shift();
  return false;
}

visitObjectConciseMethod.test = function(node, path, state) {
  return node.type === Syntax.Property &&
    node.value.type === Syntax.FunctionExpression &&
    node.method === true;
};

exports.visitorList = [
  visitObjectConciseMethod
];

},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","./reserved-words-helper":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/reserved-words-helper.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-object-short-notation-visitors.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node: true*/

/**
 * Desugars ES6 Object Literal short notations into ES3 full notation.
 *
 * // Easier return values.
 * function foo(x, y) {
 *   return {x, y}; // {x: x, y: y}
 * };
 *
 * // Destructuring.
 * function init({port, ip, coords: {x, y}}) { ... }
 *
 */
var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');

/**
 * @public
 */
function visitObjectLiteralShortNotation(traverse, node, path, state) {
  utils.catchup(node.key.range[1], state);
  utils.append(':' + node.key.name, state);
  return false;
}

visitObjectLiteralShortNotation.test = function(node, path, state) {
  return node.type === Syntax.Property &&
    node.kind === 'init' &&
    node.shorthand === true &&
    path[0].type !== Syntax.ObjectPattern;
};

exports.visitorList = [
  visitObjectLiteralShortNotation
];


},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-rest-param-visitors.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * Desugars ES6 rest parameters into an ES3 arguments array.
 *
 * function printf(template, ...args) {
 *   args.forEach(...);
 * }
 *
 * We could use `Array.prototype.slice.call`, but that usage of arguments causes
 * functions to be deoptimized in V8, so instead we use a for-loop.
 *
 * function printf(template) {
 *   for (var args = [], $__0 = 1, $__1 = arguments.length; $__0 < $__1; $__0++)
 *     args.push(arguments[$__0]);
 *   args.forEach(...);
 * }
 *
 */
var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');



function _nodeIsFunctionWithRestParam(node) {
  return (node.type === Syntax.FunctionDeclaration
          || node.type === Syntax.FunctionExpression
          || node.type === Syntax.ArrowFunctionExpression)
         && node.rest;
}

function visitFunctionParamsWithRestParam(traverse, node, path, state) {
  if (node.parametricType) {
    utils.catchup(node.parametricType.range[0], state);
    path.unshift(node);
    traverse(node.parametricType, path, state);
    path.shift();
  }

  // Render params.
  if (node.params.length) {
    path.unshift(node);
    traverse(node.params, path, state);
    path.shift();
  } else {
    // -3 is for ... of the rest.
    utils.catchup(node.rest.range[0] - 3, state);
  }
  utils.catchupWhiteSpace(node.rest.range[1], state);

  path.unshift(node);
  traverse(node.body, path, state);
  path.shift();

  return false;
}

visitFunctionParamsWithRestParam.test = function(node, path, state) {
  return _nodeIsFunctionWithRestParam(node);
};

function renderRestParamSetup(functionNode, state) {
  var idx = state.localScope.tempVarIndex++;
  var len = state.localScope.tempVarIndex++;

  return 'for (var ' + functionNode.rest.name + '=[],' +
    utils.getTempVar(idx) + '=' + functionNode.params.length + ',' +
    utils.getTempVar(len) + '=arguments.length;' +
    utils.getTempVar(idx) + '<' +  utils.getTempVar(len) + ';' +
    utils.getTempVar(idx) + '++) ' +
    functionNode.rest.name + '.push(arguments[' + utils.getTempVar(idx) + ']);';
}

function visitFunctionBodyWithRestParam(traverse, node, path, state) {
  utils.catchup(node.range[0] + 1, state);
  var parentNode = path[0];
  utils.append(renderRestParamSetup(parentNode, state), state);
  return true;
}

visitFunctionBodyWithRestParam.test = function(node, path, state) {
  return node.type === Syntax.BlockStatement
         && _nodeIsFunctionWithRestParam(path[0]);
};

exports.renderRestParamSetup = renderRestParamSetup;
exports.visitorList = [
  visitFunctionParamsWithRestParam,
  visitFunctionBodyWithRestParam
];

},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-template-visitors.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * @typechecks
 */
'use strict';

var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');

/**
 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-12.1.9
 */
function visitTemplateLiteral(traverse, node, path, state) {
  var templateElements = node.quasis;

  utils.append('(', state);
  for (var ii = 0; ii < templateElements.length; ii++) {
    var templateElement = templateElements[ii];
    if (templateElement.value.raw !== '') {
      utils.append(getCookedValue(templateElement), state);
      if (!templateElement.tail) {
        // + between element and substitution
        utils.append(' + ', state);
      }
      // maintain line numbers
      utils.move(templateElement.range[0], state);
      utils.catchupNewlines(templateElement.range[1], state);
    } else {  // templateElement.value.raw === ''
      // Concatenat adjacent substitutions, e.g. `${x}${y}`. Empty templates
      // appear before the first and after the last element - nothing to add in
      // those cases.
      if (ii > 0 && !templateElement.tail) {
        // + between substitution and substitution
        utils.append(' + ', state);
      }
    }

    utils.move(templateElement.range[1], state);
    if (!templateElement.tail) {
      var substitution = node.expressions[ii];
      if (substitution.type === Syntax.Identifier ||
          substitution.type === Syntax.MemberExpression ||
          substitution.type === Syntax.CallExpression) {
        utils.catchup(substitution.range[1], state);
      } else {
        utils.append('(', state);
        traverse(substitution, path, state);
        utils.catchup(substitution.range[1], state);
        utils.append(')', state);
      }
      // if next templateElement isn't empty...
      if (templateElements[ii + 1].value.cooked !== '') {
        utils.append(' + ', state);
      }
    }
  }
  utils.move(node.range[1], state);
  utils.append(')', state);
  return false;
}

visitTemplateLiteral.test = function(node, path, state) {
  return node.type === Syntax.TemplateLiteral;
};

/**
 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-12.2.6
 */
function visitTaggedTemplateExpression(traverse, node, path, state) {
  var template = node.quasi;
  var numQuasis = template.quasis.length;

  // print the tag
  utils.move(node.tag.range[0], state);
  traverse(node.tag, path, state);
  utils.catchup(node.tag.range[1], state);

  // print array of template elements
  utils.append('(function() { var siteObj = [', state);
  for (var ii = 0; ii < numQuasis; ii++) {
    utils.append(getCookedValue(template.quasis[ii]), state);
    if (ii !== numQuasis - 1) {
      utils.append(', ', state);
    }
  }
  utils.append(']; siteObj.raw = [', state);
  for (ii = 0; ii < numQuasis; ii++) {
    utils.append(getRawValue(template.quasis[ii]), state);
    if (ii !== numQuasis - 1) {
      utils.append(', ', state);
    }
  }
  utils.append(
    ']; Object.freeze(siteObj.raw); Object.freeze(siteObj); return siteObj; }()',
    state
  );

  // print substitutions
  if (numQuasis > 1) {
    for (ii = 0; ii < template.expressions.length; ii++) {
      var expression = template.expressions[ii];
      utils.append(', ', state);

      // maintain line numbers by calling catchupWhiteSpace over the whole
      // previous TemplateElement
      utils.move(template.quasis[ii].range[0], state);
      utils.catchupNewlines(template.quasis[ii].range[1], state);

      utils.move(expression.range[0], state);
      traverse(expression, path, state);
      utils.catchup(expression.range[1], state);
    }
  }

  // print blank lines to push the closing ) down to account for the final
  // TemplateElement.
  utils.catchupNewlines(node.range[1], state);

  utils.append(')', state);

  return false;
}

visitTaggedTemplateExpression.test = function(node, path, state) {
  return node.type === Syntax.TaggedTemplateExpression;
};

function getCookedValue(templateElement) {
  return JSON.stringify(templateElement.value.cooked);
}

function getRawValue(templateElement) {
  return JSON.stringify(templateElement.value.raw);
}

exports.visitorList = [
  visitTemplateLiteral,
  visitTaggedTemplateExpression
];

},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es7-rest-property-helpers.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * Desugars ES7 rest properties into ES5 object iteration.
 */

var Syntax = require('esprima-fb').Syntax;

// TODO: This is a pretty massive helper, it should only be defined once, in the
// transform's runtime environment. We don't currently have a runtime though.
var restFunction =
  '(function(source, exclusion) {' +
    'var rest = {};' +
    'var hasOwn = Object.prototype.hasOwnProperty;' +
    'if (source == null) {' +
      'throw new TypeError();' +
    '}' +
    'for (var key in source) {' +
      'if (hasOwn.call(source, key) && !hasOwn.call(exclusion, key)) {' +
        'rest[key] = source[key];' +
      '}' +
    '}' +
    'return rest;' +
  '})';

function getPropertyNames(properties) {
  var names = [];
  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (property.type === Syntax.SpreadProperty) {
      continue;
    }
    if (property.type === Syntax.Identifier) {
      names.push(property.name);
    } else {
      names.push(property.key.name);
    }
  }
  return names;
}

function getRestFunctionCall(source, exclusion) {
  return restFunction + '(' + source + ',' + exclusion + ')';
}

function getSimpleShallowCopy(accessorExpression) {
  // This could be faster with 'Object.assign({}, ' + accessorExpression + ')'
  // but to unify code paths and avoid a ES6 dependency we use the same
  // helper as for the exclusion case.
  return getRestFunctionCall(accessorExpression, '{}');
}

function renderRestExpression(accessorExpression, excludedProperties) {
  var excludedNames = getPropertyNames(excludedProperties);
  if (!excludedNames.length) {
    return getSimpleShallowCopy(accessorExpression);
  }
  return getRestFunctionCall(
    accessorExpression,
    '{' + excludedNames.join(':1,') + ':1}'
  );
}

exports.renderRestExpression = renderRestExpression;

},{"esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es7-spread-property-visitors.js":[function(require,module,exports){
/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 */
/*global exports:true*/

/**
 * Implements ES7 object spread property.
 * https://gist.github.com/sebmarkbage/aa849c7973cb4452c547
 *
 * { ...a, x: 1 }
 *
 * Object.assign({}, a, {x: 1 })
 *
 */

var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');

function visitObjectLiteralSpread(traverse, node, path, state) {
  utils.catchup(node.range[0], state);

  utils.append('Object.assign({', state);

  // Skip the original {
  utils.move(node.range[0] + 1, state);

  var previousWasSpread = false;

  for (var i = 0; i < node.properties.length; i++) {
    var property = node.properties[i];
    if (property.type === Syntax.SpreadProperty) {

      // Close the previous object or initial object
      if (!previousWasSpread) {
        utils.append('}', state);
      }

      if (i === 0) {
        // Normally there will be a comma when we catch up, but not before
        // the first property.
        utils.append(',', state);
      }

      utils.catchup(property.range[0], state);

      // skip ...
      utils.move(property.range[0] + 3, state);

      traverse(property.argument, path, state);

      utils.catchup(property.range[1], state);

      previousWasSpread = true;

    } else {

      utils.catchup(property.range[0], state);

      if (previousWasSpread) {
        utils.append('{', state);
      }

      traverse(property, path, state);

      utils.catchup(property.range[1], state);

      previousWasSpread = false;

    }
  }

  // Strip any non-whitespace between the last item and the end.
  // We only catch up on whitespace so that we ignore any trailing commas which
  // are stripped out for IE8 support. Unfortunately, this also strips out any
  // trailing comments.
  utils.catchupWhiteSpace(node.range[1] - 1, state);

  // Skip the trailing }
  utils.move(node.range[1], state);

  if (!previousWasSpread) {
    utils.append('}', state);
  }

  utils.append(')', state);
  return false;
}

visitObjectLiteralSpread.test = function(node, path, state) {
  if (node.type !== Syntax.ObjectExpression) {
    return false;
  }
  // Tight loop optimization
  var hasAtLeastOneSpreadProperty = false;
  for (var i = 0; i < node.properties.length; i++) {
    var property = node.properties[i];
    if (property.type === Syntax.SpreadProperty) {
      hasAtLeastOneSpreadProperty = true;
    } else if (property.kind !== 'init') {
      return false;
    }
  }
  return hasAtLeastOneSpreadProperty;
};

exports.visitorList = [
  visitObjectLiteralSpread
];

},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/reserved-words-helper.js":[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var KEYWORDS = [
  'break', 'do', 'in', 'typeof', 'case', 'else', 'instanceof', 'var', 'catch',
  'export', 'new', 'void', 'class', 'extends', 'return', 'while', 'const',
  'finally', 'super', 'with', 'continue', 'for', 'switch', 'yield', 'debugger',
  'function', 'this', 'default', 'if', 'throw', 'delete', 'import', 'try'
];

var FUTURE_RESERVED_WORDS = [
  'enum', 'await', 'implements', 'package', 'protected', 'static', 'interface',
  'private', 'public'
];

var LITERALS = [
  'null',
  'true',
  'false'
];

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-reserved-words
var RESERVED_WORDS = [].concat(
  KEYWORDS,
  FUTURE_RESERVED_WORDS,
  LITERALS
);

var reservedWordsMap = Object.create(null);
RESERVED_WORDS.forEach(function(k) {
    reservedWordsMap[k] = true;
});

/**
 * This list should not grow as new reserved words are introdued. This list is
 * of words that need to be quoted because ES3-ish browsers do not allow their
 * use as identifier names.
 */
var ES3_FUTURE_RESERVED_WORDS = [
  'enum', 'implements', 'package', 'protected', 'static', 'interface',
  'private', 'public'
];

var ES3_RESERVED_WORDS = [].concat(
  KEYWORDS,
  ES3_FUTURE_RESERVED_WORDS,
  LITERALS
);

var es3ReservedWordsMap = Object.create(null);
ES3_RESERVED_WORDS.forEach(function(k) {
    es3ReservedWordsMap[k] = true;
});

exports.isReservedWord = function(word) {
  return !!reservedWordsMap[word];
};

exports.isES3ReservedWord = function(word) {
  return !!es3ReservedWordsMap[word];
};

},{}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/reserved-words-visitors.js":[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/*global exports:true*/

var Syntax = require('esprima-fb').Syntax;
var utils = require('../src/utils');
var reserverdWordsHelper = require('./reserved-words-helper');

/**
 * Code adapted from https://github.com/spicyj/es3ify
 * The MIT License (MIT)
 * Copyright (c) 2014 Ben Alpert
 */

function visitProperty(traverse, node, path, state) {
  utils.catchup(node.key.range[0], state);
  utils.append('"', state);
  utils.catchup(node.key.range[1], state);
  utils.append('"', state);
  utils.catchup(node.value.range[0], state);
  traverse(node.value, path, state);
  return false;
}

visitProperty.test = function(node) {
  return node.type === Syntax.Property &&
    node.key.type === Syntax.Identifier &&
    !node.method &&
    !node.shorthand &&
    !node.computed &&
    reserverdWordsHelper.isES3ReservedWord(node.key.name);
};

function visitMemberExpression(traverse, node, path, state) {
  traverse(node.object, path, state);
  utils.catchup(node.property.range[0] - 1, state);
  utils.append('[', state);
  utils.catchupWhiteSpace(node.property.range[0], state);
  utils.append('"', state);
  utils.catchup(node.property.range[1], state);
  utils.append('"]', state);
  return false;
}

visitMemberExpression.test = function(node) {
  return node.type === Syntax.MemberExpression &&
    node.property.type === Syntax.Identifier &&
    reserverdWordsHelper.isES3ReservedWord(node.property.name);
};

exports.visitorList = [
  visitProperty,
  visitMemberExpression
];

},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","./reserved-words-helper":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/reserved-words-helper.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/type-syntax.js":[function(require,module,exports){
var esprima = require('esprima-fb');
var utils = require('../src/utils');

var Syntax = esprima.Syntax;

function _isFunctionNode(node) {
  return node.type === Syntax.FunctionDeclaration
         || node.type === Syntax.FunctionExpression
         || node.type === Syntax.ArrowFunctionExpression;
}

function visitClassProperty(traverse, node, path, state) {
  utils.catchup(node.range[0], state);
  utils.catchupWhiteOut(node.range[1], state);
  return false;
}
visitClassProperty.test = function(node, path, state) {
  return node.type === Syntax.ClassProperty;
};

function visitTypeAlias(traverse, node, path, state) {
  utils.catchupWhiteOut(node.range[1], state);
  return false;
}
visitTypeAlias.test = function(node, path, state) {
  return node.type === Syntax.TypeAlias;
};

function visitTypeCast(traverse, node, path, state) {
  path.unshift(node);
  traverse(node.expression, path, state);
  path.shift();

  utils.catchup(node.typeAnnotation.range[0], state);
  utils.catchupWhiteOut(node.typeAnnotation.range[1], state);
  return false;
}
visitTypeCast.test = function(node, path, state) {
  return node.type === Syntax.TypeCastExpression;
};

function visitInterfaceDeclaration(traverse, node, path, state) {
  utils.catchupWhiteOut(node.range[1], state);
  return false;
}
visitInterfaceDeclaration.test = function(node, path, state) {
  return node.type === Syntax.InterfaceDeclaration;
};

function visitDeclare(traverse, node, path, state) {
  utils.catchupWhiteOut(node.range[1], state);
  return false;
}
visitDeclare.test = function(node, path, state) {
  switch (node.type) {
    case Syntax.DeclareVariable:
    case Syntax.DeclareFunction:
    case Syntax.DeclareClass:
    case Syntax.DeclareModule:
      return true;
  }
  return false;
};

function visitFunctionParametricAnnotation(traverse, node, path, state) {
  utils.catchup(node.range[0], state);
  utils.catchupWhiteOut(node.range[1], state);
  return false;
}
visitFunctionParametricAnnotation.test = function(node, path, state) {
  return node.type === Syntax.TypeParameterDeclaration
         && path[0]
         && _isFunctionNode(path[0])
         && node === path[0].typeParameters;
};

function visitFunctionReturnAnnotation(traverse, node, path, state) {
  utils.catchup(node.range[0], state);
  utils.catchupWhiteOut(node.range[1], state);
  return false;
}
visitFunctionReturnAnnotation.test = function(node, path, state) {
  return path[0] && _isFunctionNode(path[0]) && node === path[0].returnType;
};

function visitOptionalFunctionParameterAnnotation(traverse, node, path, state) {
  utils.catchup(node.range[0] + node.name.length, state);
  utils.catchupWhiteOut(node.range[1], state);
  return false;
}
visitOptionalFunctionParameterAnnotation.test = function(node, path, state) {
  return node.type === Syntax.Identifier
         && node.optional
         && path[0]
         && _isFunctionNode(path[0]);
};

function visitTypeAnnotatedIdentifier(traverse, node, path, state) {
  utils.catchup(node.typeAnnotation.range[0], state);
  utils.catchupWhiteOut(node.typeAnnotation.range[1], state);
  return false;
}
visitTypeAnnotatedIdentifier.test = function(node, path, state) {
  return node.type === Syntax.Identifier && node.typeAnnotation;
};

function visitTypeAnnotatedObjectOrArrayPattern(traverse, node, path, state) {
  utils.catchup(node.typeAnnotation.range[0], state);
  utils.catchupWhiteOut(node.typeAnnotation.range[1], state);
  return false;
}
visitTypeAnnotatedObjectOrArrayPattern.test = function(node, path, state) {
  var rightType = node.type === Syntax.ObjectPattern
                || node.type === Syntax.ArrayPattern;
  return rightType && node.typeAnnotation;
};

/**
 * Methods cause trouble, since esprima parses them as a key/value pair, where
 * the location of the value starts at the method body. For example
 * { bar(x:number,...y:Array<number>):number {} }
 * is parsed as
 * { bar: function(x: number, ...y:Array<number>): number {} }
 * except that the location of the FunctionExpression value is 40-something,
 * which is the location of the function body. This means that by the time we
 * visit the params, rest param, and return type organically, we've already
 * catchup()'d passed them.
 */
function visitMethod(traverse, node, path, state) {
  path.unshift(node);
  traverse(node.key, path, state);

  path.unshift(node.value);
  traverse(node.value.params, path, state);
  node.value.rest && traverse(node.value.rest, path, state);
  node.value.returnType && traverse(node.value.returnType, path, state);
  traverse(node.value.body, path, state);

  path.shift();

  path.shift();
  return false;
}

visitMethod.test = function(node, path, state) {
  return (node.type === "Property" && (node.method || node.kind === "set" || node.kind === "get"))
      || (node.type === "MethodDefinition");
};

function visitImportType(traverse, node, path, state) {
  utils.catchupWhiteOut(node.range[1], state);
  return false;
}
visitImportType.test = function(node, path, state) {
  return node.type === 'ImportDeclaration'
         && node.isType;
};

exports.visitorList = [
  visitClassProperty,
  visitDeclare,
  visitImportType,
  visitInterfaceDeclaration,
  visitFunctionParametricAnnotation,
  visitFunctionReturnAnnotation,
  visitMethod,
  visitOptionalFunctionParameterAnnotation,
  visitTypeAlias,
  visitTypeCast,
  visitTypeAnnotatedIdentifier,
  visitTypeAnnotatedObjectOrArrayPattern
];

},{"../src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js","esprima-fb":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/node_modules/esprima-fb/esprima.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/transforms/jsx.js":[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
/*global exports:true*/
'use strict';
var Syntax = require('jstransform').Syntax;
var utils = require('jstransform/src/utils');

function commaAfterLastParen(value) {
  var state = 'normal';
  var commaPos = 0;
  for (var i = 0; i < value.length; ++i) {
    if (state === 'normal') {
      if (value.substr(i, 2) === '//') {
        state = 'singleline';
        i += 1;
      } else if (value.substr(i, 2) === '/*') {
        state = 'multiline';
        i += 1;
      } else if (value.charAt(i).trim() !== '') {
        commaPos = i + 1;
      }
    } else if (state === 'singleline' && value.charAt(i) === '\n') {
      state = 'normal';
    } else if (state === 'multiline' &&
        value.charAt(i) === '*' &&
        i + 1 < value.length &&
        value.charAt(i + 1) === '/') {
      i += 1;
      state = 'normal';
    }
  }
  return value.substring(0, commaPos) + ', ' + trimLeft(value.substring(commaPos));
}

function renderJSXLiteral(object, isLast, state, start, end) {
  var lines = object.value.split(/\r\n|\n|\r/);

  if (start) {
    utils.append(start, state);
  }

  var lastNonEmptyLine = 0;

  lines.forEach(function(line, index) {
    if (line.match(/[^ \t]/)) {
      lastNonEmptyLine = index;
    }
  });

  lines.forEach(function(line, index) {
    var isFirstLine = index === 0;
    var isLastLine = index === lines.length - 1;
    var isLastNonEmptyLine = index === lastNonEmptyLine;

    // replace rendered whitespace tabs with spaces
    var trimmedLine = line.replace(/\t/g, ' ');

    // trim whitespace touching a newline
    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, '');
    }
    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, '');
    }

    if (!isFirstLine) {
    utils.append(line.match(/^[ \t]*/)[0], state);
    }

    if (trimmedLine || isLastNonEmptyLine) {
      utils.append(
        JSON.stringify(trimmedLine) +
        (!isLastNonEmptyLine ? ' + \' \' +' : ''),
        state);

      if (isLastNonEmptyLine) {
        if (end) {
          utils.append(end, state);
        }
        if (!isLast) {
          utils.append(', ', state);
        }
      }

      // only restore tail whitespace if line had literals
      if (trimmedLine && !isLastLine) {
        utils.append(line.match(/[ \t]*$/)[0], state);
      }
    }

    if (!isLastLine) {
      utils.append('\n', state);
    }
  });

  utils.move(object.range[1], state);
}

function renderJSXExpressionContainer(traverse, object, isLast, path, state) {
  // Plus 1 to skip `{`.
  utils.move(object.range[0] + 1, state);
  utils.catchup(object.expression.range[0], state);
  traverse(object.expression, path, state);

  if (!isLast && object.expression.type !== Syntax.JSXEmptyExpression) {
    // If we need to append a comma, make sure to do so after the expression.
    utils.catchup(object.expression.range[1], state, trimLeft);
    utils.catchup(object.range[1] - 1, state, commaAfterLastParen);
  } else {
  // Minus 1 to skip `}`.
  utils.catchup(object.range[1] - 1, state, trimLeft);
  }
  utils.move(object.range[1], state);
  return false;
}

function quoteAttrName(attr) {
  // Quote invalid JS identifiers.
  if (!/^[a-z_$][a-z\d_$]*$/i.test(attr)) {
    return '"' + attr + '"';
  }
  return attr;
}

function trimLeft(value) {
  return value.replace(/^[ ]+/, '');
}

exports.renderJSXExpressionContainer = renderJSXExpressionContainer;
exports.renderJSXLiteral = renderJSXLiteral;
exports.quoteAttrName = quoteAttrName;
exports.trimLeft = trimLeft;

},{"jstransform":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/jstransform.js","jstransform/src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/transforms/react.js":[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
'use strict';

/*global exports:true*/

var Syntax = require('jstransform').Syntax;
var utils = require('jstransform/src/utils');

var renderJSXExpressionContainer = require('./jsx').renderJSXExpressionContainer;
var renderJSXLiteral = require('./jsx').renderJSXLiteral;
var quoteAttrName = require('./jsx').quoteAttrName;

var trimLeft = require('./jsx').trimLeft;

/**
 * Customized desugar processor for React JSX. Currently:
 *
 * <X> </X> => React.createElement(X, null)
 * <X prop="1" /> => React.createElement(X, {prop: '1'}, null)
 * <X prop="2"><Y /></X> => React.createElement(X, {prop:'2'},
 *   React.createElement(Y, null)
 * )
 * <div /> => React.createElement("div", null)
 */

/**
 * Removes all non-whitespace/parenthesis characters
 */
var reNonWhiteParen = /([^\s\(\)])/g;
function stripNonWhiteParen(value) {
  return value.replace(reNonWhiteParen, '');
}

var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}

// We assume that the Mithril runtime is already in scope
var mParts = {
  startTag: 'm(',
  endTag: ')',
  startAttrs: ', ',
  startChildren: ', [',
  endChildren: ']'
};

var componentParts = {
  startTag: 'm.component(',
  endTag: ')',
  startAttrs: ', ',
  startChildren: ', [',
  endChildren: ']'
};

var precompileParts = {
  startTag: '{tag: ',
  endTag: '}',
  startAttrs: ', attrs: ',
  startChildren: ', children: [',
  endChildren: ']'
};

function visitReactTag(precompile, traverse, object, path, state) {
  var parts = precompile ? precompileParts : mParts;
  var openingElement = object.openingElement;
  var nameObject = openingElement.name;
  var attributesObject = openingElement.attributes;

  utils.catchup(openingElement.range[0], state, trimLeft);

  if (nameObject.type === Syntax.JSXNamespacedName && nameObject.namespace) {
    throw new Error('Namespace tags are not supported. JSX is not XML.');
  }

  var hasAttributes = attributesObject.length;

  var hasAtLeastOneSpreadProperty = attributesObject.some(function(attr) {
    return attr.type === Syntax.JSXSpreadAttribute;
  });

  // filter out whitespace
  var childrenToRender = object.children.filter(function(child) {
    return !(child.type === Syntax.Literal
             && typeof child.value === 'string'
             && child.value.match(/^[ \t]*[\r\n][ \t\r\n]*$/));
  });

  var lastRenderableIndex;

  childrenToRender.forEach(function(child, index) {
    if (child.type !== Syntax.JSXExpressionContainer ||
        child.expression.type !== Syntax.JSXEmptyExpression) {
      lastRenderableIndex = index;
    }
  });

  var hasChildren = lastRenderableIndex !== undefined;

  if (nameObject.type === Syntax.JSXIdentifier && isTagName(nameObject.name)) {
    utils.append(parts.startTag, state);
    utils.append('"' + nameObject.name + '"', state);
    utils.move(nameObject.range[1], state);
  } else {
    parts = componentParts;
    // Use utils.catchup in this case so we can easily handle
    // JSXMemberExpressions which look like Foo.Bar.Baz. This also handles
    // JSXIdentifiers that aren't fallback tags.
    if (hasAttributes || hasChildren) {
      utils.append(parts.startTag, state);
    }
    utils.move(nameObject.range[0], state);
    utils.catchup(nameObject.range[1], state);
  }

  // Mithril expects an "attrs" property on pre-compiled templates
  if (hasAttributes || parts === precompileParts || parts === componentParts && hasChildren) {
    utils.append(parts.startAttrs, state)
  }

  if (hasAtLeastOneSpreadProperty) {
    // We assume that Object.assign is available to merge spread attributes
    utils.append('Object.assign({', state);
  } else if (hasAttributes) {
    utils.append('{', state);
  } else if (parts === precompileParts || parts === componentParts && hasChildren) {
    utils.append('{}', state);
  }

  // keep track of if the previous attribute was a spread attribute
  var previousWasSpread = false;

  // write attributes
  attributesObject.forEach(function(attr, index) {
    var isLast = index === attributesObject.length - 1;

    if (attr.type === Syntax.JSXSpreadAttribute) {
      // Close the previous object or initial object
      if (!previousWasSpread) {
        utils.append('}, ', state);
      }

      // Move to the expression start, ignoring everything except parenthesis
      // and whitespace.
      utils.catchup(attr.range[0], state, stripNonWhiteParen);
      // Plus 1 to skip `{`.
      utils.move(attr.range[0] + 1, state);
      utils.catchup(attr.argument.range[0], state, stripNonWhiteParen);

      traverse(attr.argument, path, state);

      utils.catchup(attr.argument.range[1], state);

      // Move to the end, ignoring parenthesis and the closing `}`
      utils.catchup(attr.range[1] - 1, state, stripNonWhiteParen);

      if (!isLast) {
        utils.append(',', state);
      }

      utils.move(attr.range[1], state);

      previousWasSpread = true;

      return;
    }

    // If the next attribute is a spread, we're effective last in this object
    if (!isLast) {
      isLast = attributesObject[index + 1].type === Syntax.JSXSpreadAttribute;
    }

    if (attr.name.namespace) {
      throw new Error(
         'Namespace attributes are not supported. JSX is not XML.');
    }
    var name = attr.name.name;

    utils.catchup(attr.range[0], state, trimLeft);

    if (previousWasSpread) {
      utils.append('{', state);
    }

    utils.append(quoteAttrName(name), state);
    utils.append(':', state);

    if (!attr.value) {
      state.g.buffer += 'true';
      state.g.position = attr.name.range[1];
      if (!isLast) {
        utils.append(',', state);
      }
    } else {
      utils.move(attr.name.range[1], state);
      // Use catchupNewlines to skip over the '=' in the attribute
      utils.catchupNewlines(attr.value.range[0], state);
      if (attr.value.type === Syntax.Literal) {
        renderJSXLiteral(attr.value, isLast, state);
      } else {
        renderJSXExpressionContainer(traverse, attr.value, isLast, path, state);
      }
    }

    utils.catchup(attr.range[1], state, trimLeft);

    previousWasSpread = false;
  });

  if (!openingElement.selfClosing) {
    utils.catchup(openingElement.range[1] - 1, state, trimLeft);
    utils.move(openingElement.range[1], state);
  }

  if (hasAttributes && !previousWasSpread) {
    utils.append('}', state);
  }

  if (hasAtLeastOneSpreadProperty) {
    utils.append(')', state);
  }

  if (childrenToRender.length > 0) {
    if (lastRenderableIndex !== undefined) {
      utils.append(parts.startChildren, state);
    }

    childrenToRender.forEach(function(child, index) {
      utils.catchup(child.range[0], state, trimLeft);

      var isLast = index >= lastRenderableIndex;

      if (child.type === Syntax.Literal) {
        renderJSXLiteral(child, isLast, state);
      } else if (child.type === Syntax.JSXExpressionContainer) {
        renderJSXExpressionContainer(traverse, child, isLast, path, state);
      } else {
        traverse(child, path, state);
        if (!isLast) {
          utils.append(', ', state);
        }
      }

      utils.catchup(child.range[1], state, trimLeft);
    });
  }

  if (openingElement.selfClosing) {
    // everything up to />
    utils.catchup(openingElement.range[1] - 2, state, trimLeft);
    utils.move(openingElement.range[1], state);
  } else {
    // everything up to </ sdflksjfd>
    utils.catchup(object.closingElement.range[0], state, trimLeft);
    utils.move(object.closingElement.range[1], state);
  }

  if (hasChildren) {
    utils.append(parts.endChildren, state);
  }
  if (parts !== componentParts || hasAttributes || hasChildren) {
    utils.append(parts.endTag, state);
  }
  return false;
}

visitReactTag.test = function(object, path, state) {
  return object.type === Syntax.JSXElement;
};

exports.visitorList = [
  visitReactTag
];

},{"./jsx":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/transforms/jsx.js","jstransform":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/jstransform.js","jstransform/src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/transforms/reactDisplayName.js":[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
/*global exports:true*/
'use strict';

var Syntax = require('jstransform').Syntax;
var utils = require('jstransform/src/utils');

function shouldAddDisplayName(object) {
  if (object &&
      object.type === Syntax.CallExpression &&
      object.callee.type === Syntax.MemberExpression &&
      object.callee.object.type === Syntax.Identifier &&
      object.callee.object.name === 'React' &&
      object.callee.property.type === Syntax.Identifier &&
      object.callee.property.name === 'createClass' &&
      object.arguments.length === 1 &&
      object.arguments[0].type === Syntax.ObjectExpression) {
    // Verify that the displayName property isn't already set
    var properties = object.arguments[0].properties;
    var safe = properties.every(function(property) {
      var value = property.key.type === Syntax.Identifier ?
        property.key.name :
        property.key.value;
      return value !== 'displayName';
    });
    return safe;
  }
  return false;
}

/**
 * If `expr` is an Identifier or MemberExpression node made of identifiers and
 * dot accesses, return a list of the identifier parts. Other nodes return null.
 *
 * Examples:
 *
 * MyComponent -> ['MyComponent']
 * namespace.MyComponent -> ['namespace', 'MyComponent']
 * namespace['foo'] -> null
 * namespace['foo'].bar -> ['bar']
 */
function flattenIdentifierOrMemberExpression(expr) {
  if (expr.type === Syntax.Identifier) {
    return [expr.name];
  } else if (expr.type === Syntax.MemberExpression) {
    if (!expr.computed && expr.property.type === Syntax.Identifier) {
      var flattenedObject = flattenIdentifierOrMemberExpression(expr.object);
      if (flattenedObject) {
        flattenedObject.push(expr.property.name);
        return flattenedObject;
      } else {
        return [expr.property.name];
    }
  }
  }
  return null;
}

/**
 * Transforms the following:
 *
 * var MyComponent = React.createClass({
 *    render: ...
 * });
 *
 * into:
 *
 * var MyComponent = React.createClass({
 *    displayName: 'MyComponent',
 *    render: ...
 * });
 *
 * Also catches:
 *
 * MyComponent = React.createClass(...);
 * namespace.MyComponent = React.createClass(...);
 * exports.MyComponent = React.createClass(...);
 * module.exports = {MyComponent: React.createClass(...)};
 */
function visitReactDisplayName(traverse, object, path, state) {
  var left, right;

  if (object.type === Syntax.AssignmentExpression) {
    left = object.left;
    right = object.right;
  } else if (object.type === Syntax.Property) {
    left = object.key;
    right = object.value;
  } else if (object.type === Syntax.VariableDeclarator) {
    left = object.id;
    right = object.init;
  }

  if (right && shouldAddDisplayName(right)) {
    var displayNamePath = flattenIdentifierOrMemberExpression(left);
    if (displayNamePath) {
      if (displayNamePath.length > 1 && displayNamePath[0] === 'exports') {
        displayNamePath.shift();
      }

      var displayName = displayNamePath.join('.');

      utils.catchup(right.arguments[0].range[0] + 1, state);
      utils.append('displayName: "' + displayName + '",', state);
  }
  }
}

visitReactDisplayName.test = function(object, path, state) {
    return (
      object.type === Syntax.AssignmentExpression ||
      object.type === Syntax.Property ||
      object.type === Syntax.VariableDeclarator
    );
};

exports.visitorList = [
  visitReactDisplayName
];

},{"jstransform":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/jstransform.js","jstransform/src/utils":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/src/utils.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/visitors.js":[function(require,module,exports){
/*global exports:true*/

'use strict';

var es6ArrowFunctions =
  require('jstransform/visitors/es6-arrow-function-visitors');
var es6Classes = require('jstransform/visitors/es6-class-visitors');
var es6Destructuring =
  require('jstransform/visitors/es6-destructuring-visitors');
var es6ObjectConciseMethod =
  require('jstransform/visitors/es6-object-concise-method-visitors');
var es6ObjectShortNotation =
  require('jstransform/visitors/es6-object-short-notation-visitors');
var es6RestParameters = require('jstransform/visitors/es6-rest-param-visitors');
var es6Templates = require('jstransform/visitors/es6-template-visitors');
var es6CallSpread =
  require('jstransform/visitors/es6-call-spread-visitors');
var es7SpreadProperty =
  require('jstransform/visitors/es7-spread-property-visitors');
var react = require('./transforms/react');
var reactDisplayName = require('./transforms/reactDisplayName');
var reservedWords = require('jstransform/visitors/reserved-words-visitors');

/**
 * Map from transformName => orderedListOfVisitors.
 */
var transformVisitors = {
  'es6-arrow-functions': es6ArrowFunctions.visitorList,
  'es6-classes': es6Classes.visitorList,
  'es6-destructuring': es6Destructuring.visitorList,
  'es6-object-concise-method': es6ObjectConciseMethod.visitorList,
  'es6-object-short-notation': es6ObjectShortNotation.visitorList,
  'es6-rest-params': es6RestParameters.visitorList,
  'es6-templates': es6Templates.visitorList,
  'es6-call-spread': es6CallSpread.visitorList,
  'es7-spread-property': es7SpreadProperty.visitorList,
  'react': react.visitorList.concat(reactDisplayName.visitorList),
  'reserved-words': reservedWords.visitorList
};

var transformSets = {
  'harmony': [
    'es6-arrow-functions',
    'es6-object-concise-method',
    'es6-object-short-notation',
    'es6-classes',
    'es6-rest-params',
    'es6-templates',
    'es6-destructuring',
    'es6-call-spread',
    'es7-spread-property'
  ],
  'es3': [
    'reserved-words'
  ],
  'react': [
    'react'
  ]
};

/**
 * Specifies the order in which each transform should run.
 */
var transformRunOrder = [
  'reserved-words',
  'es6-arrow-functions',
  'es6-object-concise-method',
  'es6-object-short-notation',
  'es6-classes',
  'es6-rest-params',
  'es6-templates',
  'es6-destructuring',
  'es6-call-spread',
  'es7-spread-property',
  'react'
];

/**
 * Given a list of transform names, return the ordered list of visitors to be
 * passed to the transform() function.
 *
 * @param {array?} excludes
 * @return {array}
 */
function getAllVisitors(excludes) {
  var ret = [];
  for (var i = 0, il = transformRunOrder.length; i < il; i++) {
    if (!excludes || excludes.indexOf(transformRunOrder[i]) === -1) {
      ret = ret.concat(transformVisitors[transformRunOrder[i]]);
    }
  }
  return ret;
}

/**
 * Given a list of visitor set names, return the ordered list of visitors to be
 * passed to jstransform.
 *
 * @param {array}
 * @return {array}
 */
function getVisitorsBySet(sets) {
  var visitorsToInclude = sets.reduce(function(visitors, set) {
    if (!transformSets.hasOwnProperty(set)) {
      throw new Error('Unknown visitor set: ' + set);
    }
    transformSets[set].forEach(function(visitor) {
      visitors[visitor] = true;
    });
    return visitors;
  }, {});

  var visitorList = [];
  for (var i = 0; i < transformRunOrder.length; i++) {
    if (visitorsToInclude.hasOwnProperty(transformRunOrder[i])) {
      visitorList = visitorList.concat(transformVisitors[transformRunOrder[i]]);
    }
  }

  return visitorList;
}

exports.getVisitorsBySet = getVisitorsBySet;
exports.getAllVisitors = getAllVisitors;
exports.transformVisitors = transformVisitors;

},{"./transforms/react":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/transforms/react.js","./transforms/reactDisplayName":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/fbtransform/transforms/reactDisplayName.js","jstransform/visitors/es6-arrow-function-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-arrow-function-visitors.js","jstransform/visitors/es6-call-spread-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-call-spread-visitors.js","jstransform/visitors/es6-class-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-class-visitors.js","jstransform/visitors/es6-destructuring-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-destructuring-visitors.js","jstransform/visitors/es6-object-concise-method-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-object-concise-method-visitors.js","jstransform/visitors/es6-object-short-notation-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-object-short-notation-visitors.js","jstransform/visitors/es6-rest-param-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-rest-param-visitors.js","jstransform/visitors/es6-template-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es6-template-visitors.js","jstransform/visitors/es7-spread-property-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/es7-spread-property-visitors.js","jstransform/visitors/reserved-words-visitors":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/node_modules/jstransform/visitors/reserved-words-visitors.js"}],"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/vendor/inline-source-map.js":[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';
/*eslint-disable no-undef*/
var Buffer = require('buffer').Buffer;

function inlineSourceMap(sourceMap, sourceCode, sourceFilename) {
  // This can be used with a sourcemap that has already has toJSON called on it.
  // Check first.
  var json = sourceMap;
  if (typeof sourceMap.toJSON === 'function') {
    json = sourceMap.toJSON();
  }
  json.sources = [sourceFilename];
  json.sourcesContent = [sourceCode];
  var base64 = Buffer(JSON.stringify(json)).toString('base64');
  return '//# sourceMappingURL=data:application/json;base64,' + base64;
}

module.exports = inlineSourceMap;

},{"buffer":"/home/siva/Documents/projects/carnatic_mithril/node_modules/browserify/node_modules/buffer/index.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/Korvais/korvaiDetail.js":[function(require,module,exports){
var AppLayout = require('../common/layouts/app_layout.js');
var API = require('../common/services/api_service.js');
var Korvai = require('../common/models/korvai.js');
var KorvaiRenderService = require('../common/services/korvai_render_service.js');

var KorvaiDetailPage = {};

KorvaiDetailPage.controller = function() {
  var vm = this;

  m.startComputation();
  API('GET', '/korvais/' + m.route.param('korvai_id')).then(function(korvaiData) {
    vm.korvai = new Korvai(korvaiData);
    m.endComputation();
  });
};

KorvaiDetailPage.view = AppLayout(function(ctrl) {
  var korvaiHtml = KorvaiRenderService.toMsx(ctrl.korvai.content());

  return (
    {tag: "div", attrs: {id:"KorvaiDetail"}, children: [
      {tag: "h1", attrs: {}, children: ["Korvai #", ctrl.korvai.id()]}, 
      korvaiHtml
    ]}
  );
});

module.exports = KorvaiDetailPage;
},{"../common/layouts/app_layout.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/layouts/app_layout.js","../common/models/korvai.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/korvai.js","../common/services/api_service.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/services/api_service.js","../common/services/korvai_render_service.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/services/korvai_render_service.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/Korvais/korvaiList.js":[function(require,module,exports){
var AppLayout = require('../common/layouts/app_layout.js');
var CurrentUser = require('../common/models/current_user.js');

var ProfileKorvaisPage = {};

ProfileKorvaisPage.controller = function() {
  this.korvais = CurrentUser.korvais();

  this.goToKorvai = function(korvaiId) {
    return function() {
      m.route('/korvais/' + korvaiId);
    }
  };
};

ProfileKorvaisPage.view = AppLayout(function(ctrl) {
  var korvais = ctrl.korvais().map(function(korvai, index) {
    var title = "Thalam: " + korvai.thalam() + ", Matras after: " + korvai.matras_after();

    return (
      {tag: "div", attrs: {class:"panel panel-primary", onclick:ctrl.goToKorvai(korvai.id())}, children: [
        {tag: "div", attrs: {class:"panel-heading"}, children: [
          {tag: "h3", attrs: {class:"panel-title"}, children: [title]}
        ]}, 
        {tag: "div", attrs: {class:"panel-body"}, children: [
          korvai.content()
        ]}
      ]}
    );
  });

  return (
    {tag: "div", attrs: {id:"ProfileKorvais"}, children: [
      {tag: "h1", attrs: {}, children: ["Korvais View"]}, {tag: "br", attrs: {}}, 
      korvais
    ]}
  );
});

module.exports = ProfileKorvaisPage;
},{"../common/layouts/app_layout.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/layouts/app_layout.js","../common/models/current_user.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/current_user.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/Login/login.js":[function(require,module,exports){
var CurrentUser = require('../common/models/current_user.js');
var AuthService = require('../common/services/auth_service.js');

var LoginPage = {};

LoginPage.controller = function() {
  var vm = this;

  vm.email = m.prop('');
  vm.password = m.prop('');
  vm.alerts = m.prop([]);

  vm.login = function(e) {
    e.preventDefault();

    if(vm.email() && vm.password()) {
      AuthService.login(vm.email(), vm.password()).then(function() {
        console.log('Current user model: ', CurrentUser);
        vm.alerts().push("Login success!");
      }, function() {
        vm.alerts().push("Login failure!");
      });
    } else {
      vm.alerts().push("Fields cannot be empty");
    }
  }
};

LoginPage.view = function(ctrl) {
  var alerts = ctrl.alerts().map(function(msg, index) {
    return (
      {tag: "div", attrs: {class:"alert alert-warning alert-dismissible", role:"alert"}, children: [
        {tag: "button", attrs: {type:"button", class:"close", "data-dismiss":"alert", "aria-label":"Close"}, children: [{tag: "span", attrs: {"aria-hidden":"true"}, children: ["×"]}]}, 
        msg
      ]}
    );
  });

  return (
    {tag: "div", attrs: {id:"Login"}, children: [
      {tag: "div", attrs: {class:"container"}, children: [
        {tag: "form", attrs: {class:"form-signin", onsubmit:ctrl.login}, children: [
          {tag: "h2", attrs: {class:"form-signin-heading"}, children: ["Please sign in"]}, 

          {tag: "label", attrs: {for:"inputEmail", class:"sr-only"}, children: ["Email address"]}, 
          {tag: "input", attrs: {
            type:"email", 
            id:"inputEmail", 
            class:"form-control", 
            placeholder:"Email address", 
            onchange:m.withAttr('value', ctrl.email), 
            value:ctrl.email(), 
            required:true,autofocus:true}}, 

          {tag: "label", attrs: {for:"inputPassword", class:"sr-only"}, children: ["Password"]}, 
          {tag: "input", attrs: {
            type:"password", 
            id:"inputPassword", 
            class:"form-control", 
            placeholder:"Password", 
            onchange:m.withAttr('value', ctrl.password), 
            value:ctrl.password(), 
            required:true}}, 

          {tag: "div", attrs: {class:"checkbox"}, children: [
            {tag: "label", attrs: {}, children: [
              {tag: "input", attrs: {type:"checkbox", value:"remember-me"}}, " Remember me"
            ]}
          ]}, 

          {tag: "button", attrs: {class:"btn btn-lg btn-primary btn-block", type:"submit"}, children: ["Sign in"]}
        ]}, 

        alerts
      ]}
    ]}
  );
};

module.exports = LoginPage;
},{"../common/models/current_user.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/current_user.js","../common/services/auth_service.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/services/auth_service.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/Profile/profile.js":[function(require,module,exports){
var AppLayout = require('../common/layouts/app_layout.js');
var CurrentUser = require('../common/models/current_user.js');

var ProfilePage = {};

ProfilePage.controller = function() {
  this.userId = CurrentUser.id();
  this.gravatarUrl = 'http://www.gravatar.com/avatar/' + CryptoJS.MD5(CurrentUser.email()) + '?d=mm&s=256';
};

ProfilePage.view = AppLayout(function(ctrl) {
  return (
    {tag: "div", attrs: {class:"container", id:"Profile"}, children: [
      {tag: "div", attrs: {class:"row"}, children: [
        {tag: "div", attrs: {class:"col-md-8 col-xs-10"}, children: [
          {tag: "div", attrs: {class:"well panel panel-default"}, children: [
            {tag: "div", attrs: {class:"panel-body"}, children: [
              {tag: "div", attrs: {class:"row"}, children: [
                {tag: "div", attrs: {class:"col-xs-12 col-sm-4 text-center"}, children: [
                  {tag: "img", attrs: {src:ctrl.gravatarUrl, alt:"Profile picture", class:"center-block img-circle img-thumbnail img-responsive"}}, 
                  {tag: "ul", attrs: {class:"list-inline ratings text-center", title:"Ratings"}, children: [
                    {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: [{tag: "span", attrs: {class:"fa fa-star fa-lg"}}]}]}, 
                    {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: [{tag: "span", attrs: {class:"fa fa-star fa-lg"}}]}]}, 
                    {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: [{tag: "span", attrs: {class:"fa fa-star fa-lg"}}]}]}, 
                    {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: [{tag: "span", attrs: {class:"fa fa-star fa-lg"}}]}]}, 
                    {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: [{tag: "span", attrs: {class:"fa fa-star fa-lg"}}]}]}
                  ]}
                ]}, 

                {tag: "div", attrs: {class:"col-xs-12 col-sm-8"}, children: [
                  {tag: "h2", attrs: {}, children: [ctrl.userId]}, 
                  {tag: "p", attrs: {}, children: [{tag: "strong", attrs: {}, children: ["About: "]}, " Web Designer / UI Expert. "]}, 
                  {tag: "p", attrs: {}, children: [{tag: "strong", attrs: {}, children: ["Hobbies: "]}, " Read, out with friends, listen to music, draw and learn new things. "]}, 
                  {tag: "p", attrs: {}, children: [{tag: "strong", attrs: {}, children: ["Skills: "]}, 
                    {tag: "span", attrs: {class:"label label-info tags"}, children: ["html5"]}, 
                    {tag: "span", attrs: {class:"label label-info tags"}, children: ["css3"]}, 
                    {tag: "span", attrs: {class:"label label-info tags"}, children: ["jquery"]}, 
                    {tag: "span", attrs: {class:"label label-info tags"}, children: ["bootstrap3"]}
                  ]}
                ]}, 

                {tag: "div", attrs: {class:"clearfix"}}, 
                {tag: "div", attrs: {class:"col-xs-12 col-sm-4"}, children: [
                  {tag: "h2", attrs: {}, children: [{tag: "strong", attrs: {}, children: [" 20,7K "]}]}, 
                  {tag: "p", attrs: {}, children: [{tag: "small", attrs: {}, children: ["Followers"]}]}, 
                  {tag: "button", attrs: {class:"btn btn-success btn-block"}, children: [{tag: "span", attrs: {class:"fa fa-plus-circle"}}, " Follow "]}
                ]}, 

                {tag: "div", attrs: {class:"col-xs-12 col-sm-4"}, children: [
                  {tag: "h2", attrs: {}, children: [{tag: "strong", attrs: {}, children: ["245"]}]}, 
                  {tag: "p", attrs: {}, children: [{tag: "small", attrs: {}, children: ["Following"]}]}, 
                  {tag: "button", attrs: {class:"btn btn-info btn-block"}, children: [{tag: "span", attrs: {class:"fa fa-user"}}, " View Profile "]}
                ]}, 

                {tag: "div", attrs: {class:"col-xs-12 col-sm-4"}, children: [
                  {tag: "h2", attrs: {}, children: [{tag: "strong", attrs: {}, children: ["43"]}]}, 
                  {tag: "p", attrs: {}, children: [{tag: "small", attrs: {}, children: ["Snippets"]}]}, 
                  {tag: "button", attrs: {type:"button", class:"btn btn-primary btn-block"}, children: [{tag: "span", attrs: {class:"fa fa-gear"}}, " Options "]}
                ]}
              ]}
            ]}
          ]}
        ]}
      ]}
    ]}
  );
});

module.exports = ProfilePage;
},{"../common/layouts/app_layout.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/layouts/app_layout.js","../common/models/current_user.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/current_user.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/app.js":[function(require,module,exports){
var LoginPage = require('./Login/login.js');
var ProfilePage = require('./Profile/profile.js');
var ProfileKorvaisPage = require('./Korvais/korvaiList.js');
var KorvaiDetailPage = require('./Korvais/korvaiDetail.js');

var CurrentUser = require('./common/models/current_user.js');

var Authenticated = function(module) {
  return {
    controller: function() { return new Authenticated.controller(module); },
    view: Authenticated.view
  };
};

Authenticated.controller = function(module) {
  if(!CurrentUser.id()) m.route('/login');
  else this.content = module.view.bind(this, new module.controller);
};

Authenticated.view = function(ctrl) {
  return m("#Authenticated", ctrl.content());
};

// helpers

String.prototype.repeat = function(num) {
  return new Array(num + 1).join(this);
};

String.prototype.replaceAll = function(find, replace) {
  return this.replace(new RegExp(find, 'g'), replace);
};

Array.prototype.removeDuplicates = function() {
  return this.reduce(function(accum, current) {
    if(accum.indexOf(current) < 0) accum.push(current);
    return accum;
  }, []);
};

// routes

m.route.mode = 'hash';
m.route(document.getElementById('app'), '/login', {
  '/login': LoginPage,

  '/korvais': Authenticated(ProfileKorvaisPage),
  '/korvais/:korvai_id': Authenticated(KorvaiDetailPage),

  '/me': Authenticated(ProfilePage)
});
},{"./Korvais/korvaiDetail.js":"/home/siva/Documents/projects/carnatic_mithril/src/Korvais/korvaiDetail.js","./Korvais/korvaiList.js":"/home/siva/Documents/projects/carnatic_mithril/src/Korvais/korvaiList.js","./Login/login.js":"/home/siva/Documents/projects/carnatic_mithril/src/Login/login.js","./Profile/profile.js":"/home/siva/Documents/projects/carnatic_mithril/src/Profile/profile.js","./common/models/current_user.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/current_user.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/common/layouts/app_layout.js":[function(require,module,exports){
var CurrentUser = require('../models/current_user.js');

var Header = {};

Header.controller = function() {
  this.userId = CurrentUser.id();
};

Header.view = function(ctrl) {
  return (
    {tag: "nav", attrs: {class:"navbar navbar-inverse navbar-fixed-top", id:"Header"}, children: [
      {tag: "div", attrs: {class:"container-fluid"}, children: [
        {tag: "div", attrs: {class:"navbar-header"}, children: [
          {tag: "button", attrs: {type:"button", class:"navbar-toggle collapsed", "data-toggle":"collapse", "data-target":"#navbar", "aria-expanded":"false", "aria-controls":"navbar"}, children: [
            {tag: "span", attrs: {class:"sr-only"}, children: ["Toggle navigation"]}, 
            {tag: "span", attrs: {class:"icon-bar"}}, 
            {tag: "span", attrs: {class:"icon-bar"}}, 
            {tag: "span", attrs: {class:"icon-bar"}}
          ]}, 
          {tag: "a", attrs: {class:"navbar-brand", href:"#", id:"logo"}, children: ["Carnatic"]}
        ]}, 

        {tag: "div", attrs: {id:"navbar", class:"navbar-collapse collapse"}, children: [
          {tag: "ul", attrs: {class:"nav navbar-nav navbar-right"}, children: [
            {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: ["Dashboard"]}]}, 
            {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: ["Settings"]}]}, 
            {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: ["Profile"]}]}, 
            {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#"}, children: ["Help"]}]}, 
            {tag: "li", attrs: {class:"divider"}}, 
            {tag: "li", attrs: {}, children: [{tag: "a", attrs: {href:"#/me"}, children: [ctrl.userId]}]}
          ]}
        ]}
      ]}
    ]}
  );
};

var AppLayout = function(view) {
  return function(ctrl) {
    return (
      {tag: "div", attrs: {id:"AppLayout"}, children: [
        Header, 
        {tag: "div", attrs: {class:"container-fluid"}, children: [
          view(ctrl)
        ]}
      ]}
    );
  };
};

module.exports = AppLayout;
},{"../models/current_user.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/current_user.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/common/models/current_user.js":[function(require,module,exports){
var API = require('../services/api_service.js');
var Korvai = require('../models/korvai.js');
var Profile = require('../models/profile.js');

var CurrentUser = (function(){
  var localUserData = JSON.parse(localStorage.getItem('carnatic-currentUser')) || {};

  return {
    id: m.prop(localUserData.id || ''),
    email: m.prop(localUserData.email || ''),
    auth_token: m.prop(localUserData.auth_token || '')
  };
}());

CurrentUser.reset = function(userData) {
  CurrentUser.id(userData.id);
  CurrentUser.email(userData.email);
  CurrentUser.auth_token(userData.auth_token);
  localStorage.setItem('carnatic-currentUser', JSON.stringify(userData));
};

CurrentUser.profile = function() {
  return API('GET', '/users/' + CurrentUser.id() + '/profile').then(function(profile) {
    return new Profile(profile);
  });
};

CurrentUser.korvais = function() {
  return API('GET', '/users/' + CurrentUser.id() + '/korvais').then(function(korvais) {
    return korvais.map(function(k, index) {return new Korvai(k)});
  });
};

module.exports = CurrentUser;
},{"../models/korvai.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/korvai.js","../models/profile.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/profile.js","../services/api_service.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/services/api_service.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/common/models/korvai.js":[function(require,module,exports){
var Korvai = function(data) {
  this.id = m.prop(data.id || 0);
  this.user_id = m.prop(data.user_id || 0);
  this.content = m.prop(data.content || '');
  this.thalam = m.prop(data.thalam || 32);
  this.matras_after = m.prop(data.matrasAfter || 0);
  this.created_at = m.prop(data.created_at || '');
};

module.exports = Korvai;
},{}],"/home/siva/Documents/projects/carnatic_mithril/src/common/models/profile.js":[function(require,module,exports){
var Profile = function(data) {
  this.id = m.prop(data.id || 0);
  this.user_id = m.prop(data.user_id || 0);
  this.name = m.prop(data.name || '');
  this.picture_url = m.prop(data.picture_url || 32);
  this.created_at = m.prop(data.created_at || '');
};

module.exports = Profile;
},{}],"/home/siva/Documents/projects/carnatic_mithril/src/common/services/api_service.js":[function(require,module,exports){
// requires method (e.g. GET, POST, etc.)
// requires url (e.g. '/users/1')
// optional data (javascript object)
// optional auth_token (if authentication is required)
var API = function(method, url, data, auth_token) {
  var xhrConfig = function(xhr) {
    if(auth_token) xhr.setRequestHeader('Authentication: Token ', auth_token);
  };

  return m.request({
    method: method,
    url: 'http://localhost:3000' + url,
    data: data || {},
    config: xhrConfig
  });
};

module.exports = API;
},{}],"/home/siva/Documents/projects/carnatic_mithril/src/common/services/auth_service.js":[function(require,module,exports){
var CurrentUser = require('../models/current_user.js');

var AuthService = {
  login: function(email, password) {
    m.startComputation();

    return m.request({method: 'POST', url: 'http://localhost:3000/users/login', data: {
      email: email,
      password: password
    }}).then(function(userData) {
      console.log("login success: ", userData);
      CurrentUser.reset(userData);
      m.endComputation();
    }, function(error) {
      console.log("login failure: ", error);
      m.endComputation();
    });
  }
};

module.exports = AuthService;
},{"../models/current_user.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/models/current_user.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/common/services/korvai_render_service.js":[function(require,module,exports){
var MatrasService = require('./matras_service.js');
var msx = require('msx');

var KorvaiRenderService = {
  toMsx: function(korvai) {
    return eval('(' + msx.transform(this.renderHTML(korvai)) + ')');
  },

  renderHTML: function(korvai) {
    return '<div id="korvai-content">' + this.korvaiToHTML(korvai) + '</div>';
  },

  // -------- PRIVATE --------

  convertRepeater: function(r) {
    var lastSlash = r.lastIndexOf("/");
    if(lastSlash == -1) return;

    var rString = r.substring(0, lastSlash);
    var repeaters = MatrasService.findModifiers(rString, "(", ")");

    for(var i = 0; i < repeaters.length; i++)
      rString = this.replaceRepeater(rString, repeaters[i]);

    return '<span class="modifier-bracket">(</span>' + rString + '<span class="modifier-bracket">)</span> ×' + r.slice(lastSlash + 1);
  },

  replaceRepeater: function(str, r) {
    return str.replace("(" + r + ")", this.convertRepeater(r));
  },

  convertNadai: function(n) {
    var lastSlash = n.lastIndexOf("/");
    if(lastSlash == -1) return;

    var nString = n.substring(0, lastSlash);
    return '<span class="modifier-bracket">[</span>' + nString + '<span class="modifier-bracket">]</span> → ' + this.numberToNadai(parseInt(n.slice(lastSlash + 1)));
  },

  numberToNadai: function(num) {
    switch(num) {
      case 3:
        return "thisram";
      case 4:
        return "chatusram";
      case 5:
        return "kandam";
      case 6:
        return "mael thisram";
      case 7:
        return "misram";
      case 8:
        return "mael chatusram";
      case 9:
        return "sankeernam";
    }
  },

  grabContent: function(content) {
    content = content.replaceAll("<br>", "\n");
    var div = document.createElement("div");
    div.innerHTML = content;
    content = div.textContent || div.innerText || "";
    return content;
  },

  korvaiToHTML: function(korvai) {
    if(korvai == "" || korvai == null) return "";
    
    // TODO: understand why you need 4 backslashes for the newline replace
    korvai = korvai.replaceAll(",", " , ").replaceAll(";", " ; ").replaceAll("\\\\n", " \n ");
    var korvaiWords = korvai.match(/([a-zA-Z]+)/g).removeDuplicates();

    for(var i = 0; i < korvaiWords.length; i++) {
      var word = korvaiWords[i];
      korvai = korvai.replaceAll("\\b" + word + "\\b", " " + word + "<sup>" + MatrasService.wordMatras(word) + "</sup> ");
    }

    var repeaters = MatrasService.findModifiers(korvai, "(", ")");
    for(var i = 0; i < repeaters.length; i++) {
      var r = repeaters[i];
      korvai = korvai.replace("(" + r + ")", this.convertRepeater(r));
    }

    var nadais = MatrasService.findModifiers(korvai, "[", "]")
    for(var i = 0; i < nadais[i]; i++) {
      var n = nadais[i];
      korvai = korvai.replace("[" + n + "]", this.convertNadai(n));
    }

    korvai = korvai.replaceAll("\n", "<br />");

    return korvai;
  }
};

module.exports = KorvaiRenderService;
},{"./matras_service.js":"/home/siva/Documents/projects/carnatic_mithril/src/common/services/matras_service.js","msx":"/home/siva/Documents/projects/carnatic_mithril/node_modules/msx/main.js"}],"/home/siva/Documents/projects/carnatic_mithril/src/common/services/matras_service.js":[function(require,module,exports){
var MatrasService = {
  // findModifiers(str, oBracket, cBracket) produces an array of all the
  // content of the "modifiers" in the given korvai string, where a modifier
  // is either a repeater or nadai
  // a repeater is of the form "(thathinkinathom /3)" with parentheses
  // a nadai is of the form "[thathinkinathom /3]" with square brackets
  // TODO: clean this up, it's very messy
  findModifiers: function(str, oBracket, cBracket) {
    var endPos = -1;
    var modifiers = [];

    while(true) {
      while(str.charAt(endPos + 1) != oBracket && endPos < str.length) endPos++;
      if(endPos == str.length) break;

      var openBrackets = 0;
      var startPos = endPos;

      while(true) {
        chr = str.charAt(++endPos);

        if(chr == oBracket) openBrackets++;
        else if(chr == cBracket) openBrackets--;

        if(!(openBrackets > 0 && endPos < str.length)) break;
      }

      if(endPos == str.length) break;

      modifiers.push(str.substring(startPos + 2, endPos));
    }

    return modifiers;
  },

  // repeatString(r) consumes a repeater (as defined above)
  // and produces the repeated sequence as a string (or false if not found)
  // e.g. (thathinkinathom /3) produces "thathinkinathom thathinkinathom thathinkinathom "
  repeatString: function(r) {
    var lastSlash = r.lastIndexOf("/");
    if(lastSlash == -1) return false;

    var rString = r.substring(0, lastSlash);
    var repeaters = this.findModifiers(rString, "(", ")");

    for(var i = 0; i < repeaters.length; i++)
      rString = this.replaceRepeater(rString, repeaters[i]);

    var numOfRepeats = parseInt(r.slice(lastSlash + 1));

    try {
      return rString.repeat(numOfRepeats);
    } catch(error) {
      console.error("ERROR: Invalid repeater syntax: ", error);
      return rString;
    }
  },

  // replaceRepeater(str, r) replaces the occurrences of the repeater
  // in the given string
  replaceRepeater: function(str, r) {
    return str.replace("(" + r + ")", this.repeatString(r));
  },

  // repeaterMatras(r) counts the number of matras in the given repeater
  repeaterMatras: function(r) {
    return this.matrasWithoutModifiers(this.repeatString(r));
  },

  nadaiMatras: function(n) {
    var lastSlash = n.lastIndexOf("/");
    if(lastSlash == -1) return;

    var nString = n.substring(0, lastSlash);

    return this.countMatras(nString, false) * 4 / parseInt(n.slice(lastSlash + 1));
  },

  wordMatras: function(word) {
    var vowels = word.match(/[aeiou]/g);
    if(vowels) return vowels.length;
    else return 0;
  },

  matrasWithoutModifiers: function(korvai) {
    var matras = 0;
    var korvaiWords = korvai.replace(/(\r\n|\n|\r)/gm, ' ').split(' ');

    for(var i = 0; i < korvaiWords.length; i++)
      matras += this.wordMatras(korvaiWords[i]);

    var commas = korvai.match(/,/g);
    matras += (commas ? commas.length : 0);

    var semicolons = korvai.match(/;/g);
    matras += (semicolons ? semicolons.length * 2 : 0);

    return matras;
  },

  // countMatras(korvai) counts the number of matras in the korvai
  // TODO: this only works for 2nd speed
  countMatras: function(korvai, hasNadais) {
    var div = document.createElement("div");
    div.innerHTML = korvai;
    korvai = div.textContent || div.innerText || '';

    var matras = 0;

    if(hasNadais) {
      var nadais = this.findModifiers(korvai, "[", "]");

      for(var i = 0; i < nadais.length; i++) {
        matras += this.nadaiMatras(nadais[i]);
        korvai = korvai.replace("[" + nadais[i] + "]", '');
      }
    }

    var repeaters = this.findModifiers(korvai, "(", ")");

    for(var i = 0; i < repeaters.length; i++) {
      matras += this.repeaterMatras(repeaters[i]);
      korvai = korvai.replace("(" + r + ")", '');
    }

    matras += this.matrasWithoutModifiers(korvai);
    return matras;
  }
};

module.exports = MatrasService;
},{}]},{},["/home/siva/Documents/projects/carnatic_mithril/src/app.js"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbm9kZV9tb2R1bGVzL2pzdHJhbnNmb3JtL25vZGVfbW9kdWxlcy9iYXNlNjIvYmFzZTYyLmpzIiwibm9kZV9tb2R1bGVzL21zeC9ub2RlX21vZHVsZXMvanN0cmFuc2Zvcm0vbm9kZV9tb2R1bGVzL2VzcHJpbWEtZmIvZXNwcmltYS5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbm9kZV9tb2R1bGVzL2pzdHJhbnNmb3JtL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLmpzIiwibm9kZV9tb2R1bGVzL21zeC9ub2RlX21vZHVsZXMvanN0cmFuc2Zvcm0vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYXJyYXktc2V0LmpzIiwibm9kZV9tb2R1bGVzL21zeC9ub2RlX21vZHVsZXMvanN0cmFuc2Zvcm0vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LXZscS5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbm9kZV9tb2R1bGVzL2pzdHJhbnNmb3JtL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbm9kZV9tb2R1bGVzL2pzdHJhbnNmb3JtL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2JpbmFyeS1zZWFyY2guanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwibm9kZV9tb2R1bGVzL21zeC9ub2RlX21vZHVsZXMvanN0cmFuc2Zvcm0vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2Utbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbm9kZV9tb2R1bGVzL2pzdHJhbnNmb3JtL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS9zcmMvZG9jYmxvY2suanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS9zcmMvanN0cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtYXJyb3ctZnVuY3Rpb24tdmlzaXRvcnMuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtY2FsbC1zcHJlYWQtdmlzaXRvcnMuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtY2xhc3MtdmlzaXRvcnMuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtZGVzdHJ1Y3R1cmluZy12aXNpdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbm9kZV9tb2R1bGVzL2pzdHJhbnNmb3JtL3Zpc2l0b3JzL2VzNi1vYmplY3QtY29uY2lzZS1tZXRob2QtdmlzaXRvcnMuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtb2JqZWN0LXNob3J0LW5vdGF0aW9uLXZpc2l0b3JzLmpzIiwibm9kZV9tb2R1bGVzL21zeC9ub2RlX21vZHVsZXMvanN0cmFuc2Zvcm0vdmlzaXRvcnMvZXM2LXJlc3QtcGFyYW0tdmlzaXRvcnMuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtdGVtcGxhdGUtdmlzaXRvcnMuanMiLCJub2RlX21vZHVsZXMvbXN4L25vZGVfbW9kdWxlcy9qc3RyYW5zZm9ybS92aXNpdG9ycy9lczctcmVzdC1wcm9wZXJ0eS1oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL21zeC9ub2RlX21vZHVsZXMvanN0cmFuc2Zvcm0vdmlzaXRvcnMvZXM3LXNwcmVhZC1wcm9wZXJ0eS12aXNpdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbm9kZV9tb2R1bGVzL2pzdHJhbnNmb3JtL3Zpc2l0b3JzL3Jlc2VydmVkLXdvcmRzLWhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvbm9kZV9tb2R1bGVzL2pzdHJhbnNmb3JtL3Zpc2l0b3JzL3Jlc2VydmVkLXdvcmRzLXZpc2l0b3JzLmpzIiwibm9kZV9tb2R1bGVzL21zeC9ub2RlX21vZHVsZXMvanN0cmFuc2Zvcm0vdmlzaXRvcnMvdHlwZS1zeW50YXguanMiLCJub2RlX21vZHVsZXMvbXN4L3ZlbmRvci9mYnRyYW5zZm9ybS90cmFuc2Zvcm1zL2pzeC5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvdmVuZG9yL2ZidHJhbnNmb3JtL3RyYW5zZm9ybXMvcmVhY3QuanMiLCJub2RlX21vZHVsZXMvbXN4L3ZlbmRvci9mYnRyYW5zZm9ybS90cmFuc2Zvcm1zL3JlYWN0RGlzcGxheU5hbWUuanMiLCJub2RlX21vZHVsZXMvbXN4L3ZlbmRvci9mYnRyYW5zZm9ybS92aXNpdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9tc3gvdmVuZG9yL2lubGluZS1zb3VyY2UtbWFwLmpzIiwic3JjL0tvcnZhaXMva29ydmFpRGV0YWlsLmpzIiwic3JjL0tvcnZhaXMva29ydmFpTGlzdC5qcyIsInNyYy9Mb2dpbi9sb2dpbi5qcyIsInNyYy9Qcm9maWxlL3Byb2ZpbGUuanMiLCJzcmMvYXBwLmpzIiwic3JjL2NvbW1vbi9sYXlvdXRzL2FwcF9sYXlvdXQuanMiLCJzcmMvY29tbW9uL21vZGVscy9jdXJyZW50X3VzZXIuanMiLCJzcmMvY29tbW9uL21vZGVscy9rb3J2YWkuanMiLCJzcmMvY29tbW9uL21vZGVscy9wcm9maWxlLmpzIiwic3JjL2NvbW1vbi9zZXJ2aWNlcy9hcGlfc2VydmljZS5qcyIsInNyYy9jb21tb24vc2VydmljZXMvYXV0aF9zZXJ2aWNlLmpzIiwic3JjL2NvbW1vbi9zZXJ2aWNlcy9rb3J2YWlfcmVuZGVyX3NlcnZpY2UuanMiLCJzcmMvY29tbW9uL3NlcnZpY2VzL21hdHJhc19zZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0NENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGhQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIga01heExlbmd0aCA9IDB4M2ZmZmZmZmZcbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAtIEltcGxlbWVudGF0aW9uIG11c3Qgc3VwcG9ydCBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcy5cbiAqICAgRmlyZWZveCA0LTI5IGxhY2tlZCBzdXBwb3J0LCBmaXhlZCBpbiBGaXJlZm94IDMwKy5cbiAqICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cbiAqXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleSB3aWxsXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCB3aWxsIHdvcmsgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBuZXcgVWludDhBcnJheSgxKS5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpXG5cbiAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGggKiAyXG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoID4+PiAxXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XFwtXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cbiAgdmFyIGkgPSAwXG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgIGNvZGVQb2ludCA9IGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDAgfCAweDEwMDAwXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcblxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MjAwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZiovXG52YXIgdmlzaXRvcnMgPSByZXF1aXJlKCcuL3ZlbmRvci9mYnRyYW5zZm9ybS92aXNpdG9ycycpO1xudmFyIHRyYW5zZm9ybSA9IHJlcXVpcmUoJ2pzdHJhbnNmb3JtJykudHJhbnNmb3JtO1xudmFyIHR5cGVzU3ludGF4ID0gcmVxdWlyZSgnanN0cmFuc2Zvcm0vdmlzaXRvcnMvdHlwZS1zeW50YXgnKTtcbnZhciBpbmxpbmVTb3VyY2VNYXAgPSByZXF1aXJlKCcuL3ZlbmRvci9pbmxpbmUtc291cmNlLW1hcCcpO1xuXG52YXIgdmlzaXRSZWFjdFRhZyA9IHJlcXVpcmUoJy4vdmVuZG9yL2ZidHJhbnNmb3JtL3RyYW5zZm9ybXMvcmVhY3QnKS52aXNpdG9yTGlzdFswXTtcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBwYXJ0aWFsKGZ1bmMpIHtcbiAgdmFyIHBhcnRpYWxBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgcGFydGlhbEFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjKSB7XG4gIGlmIChzcmMgIT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICBkZXN0W3Byb3BdID0gc3JjW3Byb3BdO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgb3V0cHV0ID0gaW5uZXJUcmFuc2Zvcm0oaW5wdXQsIG9wdGlvbnMpO1xuICAgIHZhciByZXN1bHQgPSBvdXRwdXQuY29kZTtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgIHZhciBtYXAgPSBpbmxpbmVTb3VyY2VNYXAoXG4gICAgICAgIG91dHB1dC5zb3VyY2VNYXAsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBvcHRpb25zLmZpbGVuYW1lXG4gICAgICApO1xuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgbWFwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICB0cmFuc2Zvcm1XaXRoRGV0YWlsczogZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcHJvY2Vzc09wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIG91dHB1dCA9IGlubmVyVHJhbnNmb3JtKGlucHV0LCBvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgcmVzdWx0LmNvZGUgPSBvdXRwdXQuY29kZTtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgIHJlc3VsdC5zb3VyY2VNYXAgPSBvdXRwdXQuc291cmNlTWFwLnRvSlNPTigpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maWxlbmFtZSkge1xuICAgICAgcmVzdWx0LnNvdXJjZU1hcC5zb3VyY2VzID0gW29wdGlvbnMuZmlsZW5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vKipcbiAqIE9ubHkgY29weSB0aGUgdmFsdWVzIHRoYXQgd2UgbmVlZC4gV2UnbGwgZG8gc29tZSBwcmVwcm9jZXNzaW5nIHRvIGFjY291bnQgZm9yXG4gKiBjb252ZXJ0aW5nIGNvbW1hbmQgbGluZSBmbGFncyB0byBvcHRpb25zIHRoYXQganN0cmFuc2Zvcm0gY2FuIGFjdHVhbGx5IHVzZS5cbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc09wdGlvbnMob3B0cykge1xuICBvcHRzID0gZXh0ZW5kKHtwcmVjb21waWxlOiB0cnVlfSwgb3B0cyk7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgb3B0aW9ucy5oYXJtb255ID0gb3B0cy5oYXJtb255O1xuICBvcHRpb25zLnN0cmlwVHlwZXMgPSBvcHRzLnN0cmlwVHlwZXM7XG4gIG9wdGlvbnMuc291cmNlTWFwID0gb3B0cy5zb3VyY2VNYXA7XG4gIG9wdGlvbnMuZmlsZW5hbWUgPSBvcHRzLnNvdXJjZUZpbGVuYW1lO1xuICBvcHRpb25zLnByZWNvbXBpbGUgPSBvcHRzLnByZWNvbXBpbGU7XG5cbiAgaWYgKG9wdHMuZXM2bW9kdWxlKSB7XG4gICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XG4gIH1cbiAgaWYgKG9wdHMubm9uU3RyaWN0RXM2bW9kdWxlKSB7XG4gICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gJ25vblN0cmljdE1vZHVsZSc7XG4gIH1cblxuICAvLyBJbnN0ZWFkIG9mIGRvaW5nIGFueSBmYW5jeSB2YWxpZGF0aW9uLCBvbmx5IGxvb2sgZm9yICdlczMnLiBJZiB3ZSBoYXZlXG4gIC8vIHRoYXQsIHRoZW4gdXNlIGl0LiBPdGhlcndpc2UgdXNlICdlczUnLlxuICBvcHRpb25zLmVzMyA9IG9wdHMudGFyZ2V0ID09PSAnZXMzJztcbiAgb3B0aW9ucy5lczUgPSAhb3B0aW9ucy5lczM7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGlubmVyVHJhbnNmb3JtKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciB2aXNpdG9yU2V0cyA9IFsncmVhY3QnXTtcbiAgaWYgKG9wdGlvbnMuaGFybW9ueSkge1xuICAgIHZpc2l0b3JTZXRzLnB1c2goJ2hhcm1vbnknKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmVzMykge1xuICAgIHZpc2l0b3JTZXRzLnB1c2goJ2VzMycpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuc3RyaXBUeXBlcykge1xuICAgIC8vIFN0cmlwcGluZyB0eXBlcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBvdGhlciB0cmFuc2Zvcm1zXG4gICAgLy8gdW5mb3J0dW5hdGVseSwgZHVlIHRvIGJhZCBpbnRlcmFjdGlvbnMuIEZvciBleGFtcGxlLFxuICAgIC8vIGVzNi1yZXN0LXBhcmFtLXZpc2l0b3JzIGNvbmZsaWN0IHdpdGggc3RyaXBwaW5nIHJlc3QgcGFyYW0gdHlwZVxuICAgIC8vIGFubm90YXRpb25cbiAgICBpbnB1dCA9IHRyYW5zZm9ybSh0eXBlc1N5bnRheC52aXNpdG9yTGlzdCwgaW5wdXQsIG9wdGlvbnMpLmNvZGU7XG4gIH1cblxuICB2YXIgdmlzaXRvckxpc3QgPSB2aXNpdG9ycy5nZXRWaXNpdG9yc0J5U2V0KHZpc2l0b3JTZXRzKTtcblxuICAvLyBQYXRjaCB0aGUgcmVhY3QgdGFnIHZpc2l0b3IgdG8gcHJlY29uZmlndXJlIHRoZSBNU1ggcHJlY29tcGlsZSBhcmd1bWVudFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc2l0b3JMaXN0Lmxlbmd0aCA7IGkrKykge1xuICAgIHZhciB2aXNpdG9yID0gdmlzaXRvckxpc3RbaV07XG4gICAgaWYgKHZpc2l0b3IgPT09IHZpc2l0UmVhY3RUYWcpIHtcbiAgICAgIHZpc2l0b3JMaXN0W2ldID0gcGFydGlhbCh2aXNpdG9yLCBvcHRpb25zLnByZWNvbXBpbGUpO1xuICAgICAgdmlzaXRvckxpc3RbaV0udGVzdCA9IHZpc2l0b3IudGVzdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtKHZpc2l0b3JMaXN0LCBpbnB1dCwgb3B0aW9ucyk7XG59XG4iLCJ2YXIgQmFzZTYyID0gKGZ1bmN0aW9uIChteSkge1xuICBteS5jaGFycyA9IFtcIjBcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCIsIFwiaFwiLCBcImlcIiwgXCJqXCIsIFwia1wiLCBcImxcIiwgXCJtXCIsIFwiblwiLCBcIm9cIiwgXCJwXCIsIFwicVwiLCBcInJcIiwgXCJzXCIsIFwidFwiLCBcInVcIiwgXCJ2XCIsIFwid1wiLCBcInhcIiwgXCJ5XCIsIFwielwiLCBcIkFcIiwgXCJCXCIsIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiLCBcIkdcIiwgXCJIXCIsIFwiSVwiLCBcIkpcIiwgXCJLXCIsIFwiTFwiLCBcIk1cIiwgXCJOXCIsIFwiT1wiLCBcIlBcIiwgXCJRXCIsIFwiUlwiLCBcIlNcIiwgXCJUXCIsIFwiVVwiLCBcIlZcIiwgXCJXXCIsIFwiWFwiLCBcIllcIiwgXCJaXCJdXG5cbiAgbXkuZW5jb2RlID0gZnVuY3Rpb24oaSl7XG4gICAgaWYgKGkgPT09IDApIHtyZXR1cm4gJzAnfVxuICAgIHZhciBzID0gJydcbiAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgIHMgPSB0aGlzLmNoYXJzW2kgJSA2Ml0gKyBzXG4gICAgICBpID0gTWF0aC5mbG9vcihpLzYyKVxuICAgIH1cbiAgICByZXR1cm4gc1xuICB9O1xuICBteS5kZWNvZGUgPSBmdW5jdGlvbihhLGIsYyxkKXtcbiAgICBmb3IgKFxuICAgICAgYiA9IGMgPSAoXG4gICAgICAgIGEgPT09ICgvXFxXfF98XiQvLnRlc3QoYSArPSBcIlwiKSB8fCBhKVxuICAgICAgKSAtIDE7XG4gICAgICBkID0gYS5jaGFyQ29kZUF0KGMrKyk7XG4gICAgKVxuICAgIGIgPSBiICogNjIgKyBkIC0gWywgNDgsIDI5LCA4N11bZCA+PiA1XTtcbiAgICByZXR1cm4gYlxuICB9O1xuXG4gIHJldHVybiBteTtcbn0oe30pKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlNjIiLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBUaGFkZGVlIFR5bCA8dGhhZGRlZS50eWxAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTEgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLFxuICAgIC8vIFJoaW5vLCBhbmQgcGxhaW4gYnJvd3NlciBsb2FkaW5nLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KChyb290LmVzcHJpbWEgPSB7fSkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVG9rZW4sXG4gICAgICAgIFRva2VuTmFtZSxcbiAgICAgICAgRm5FeHByVG9rZW5zLFxuICAgICAgICBTeW50YXgsXG4gICAgICAgIFByb3BlcnR5S2luZCxcbiAgICAgICAgTWVzc2FnZXMsXG4gICAgICAgIFJlZ2V4LFxuICAgICAgICBTeW50YXhUcmVlRGVsZWdhdGUsXG4gICAgICAgIFhIVE1MRW50aXRpZXMsXG4gICAgICAgIENsYXNzUHJvcGVydHlUeXBlLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxpbmVOdW1iZXIsXG4gICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBkZWxlZ2F0ZSxcbiAgICAgICAgbG9va2FoZWFkLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZXh0cmE7XG5cbiAgICBUb2tlbiA9IHtcbiAgICAgICAgQm9vbGVhbkxpdGVyYWw6IDEsXG4gICAgICAgIEVPRjogMixcbiAgICAgICAgSWRlbnRpZmllcjogMyxcbiAgICAgICAgS2V5d29yZDogNCxcbiAgICAgICAgTnVsbExpdGVyYWw6IDUsXG4gICAgICAgIE51bWVyaWNMaXRlcmFsOiA2LFxuICAgICAgICBQdW5jdHVhdG9yOiA3LFxuICAgICAgICBTdHJpbmdMaXRlcmFsOiA4LFxuICAgICAgICBSZWd1bGFyRXhwcmVzc2lvbjogOSxcbiAgICAgICAgVGVtcGxhdGU6IDEwLFxuICAgICAgICBKU1hJZGVudGlmaWVyOiAxMSxcbiAgICAgICAgSlNYVGV4dDogMTJcbiAgICB9O1xuXG4gICAgVG9rZW5OYW1lID0ge307XG4gICAgVG9rZW5OYW1lW1Rva2VuLkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLklkZW50aWZpZXJdID0gJ0lkZW50aWZpZXInO1xuICAgIFRva2VuTmFtZVtUb2tlbi5LZXl3b3JkXSA9ICdLZXl3b3JkJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5OdW1lcmljTGl0ZXJhbF0gPSAnTnVtZXJpYyc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuICAgIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5KU1hJZGVudGlmaWVyXSA9ICdKU1hJZGVudGlmaWVyJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uSlNYVGV4dF0gPSAnSlNYVGV4dCc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlJlZ3VsYXJFeHByZXNzaW9uXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XG5cbiAgICAvLyBBIGZ1bmN0aW9uIGZvbGxvd2luZyBvbmUgb2YgdGhvc2UgdG9rZW5zIGlzIGFuIGV4cHJlc3Npb24uXG4gICAgRm5FeHByVG9rZW5zID0gWycoJywgJ3snLCAnWycsICdpbicsICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsICduZXcnLFxuICAgICAgICAgICAgICAgICAgICAncmV0dXJuJywgJ2Nhc2UnLCAnZGVsZXRlJywgJ3Rocm93JywgJ3ZvaWQnLFxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAnPScsICcrPScsICctPScsICcqPScsICcvPScsICclPScsICc8PD0nLCAnPj49JywgJz4+Pj0nLFxuICAgICAgICAgICAgICAgICAgICAnJj0nLCAnfD0nLCAnXj0nLCAnLCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbmFyeS91bmFyeSBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgJysnLCAnLScsICcqJywgJy8nLCAnJScsICcrKycsICctLScsICc8PCcsICc+PicsICc+Pj4nLCAnJicsXG4gICAgICAgICAgICAgICAgICAgICd8JywgJ14nLCAnIScsICd+JywgJyYmJywgJ3x8JywgJz8nLCAnOicsICc9PT0nLCAnPT0nLCAnPj0nLFxuICAgICAgICAgICAgICAgICAgICAnPD0nLCAnPCcsICc+JywgJyE9JywgJyE9PSddO1xuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBbnlUeXBlQW5ub3RhdGlvbjogJ0FueVR5cGVBbm5vdGF0aW9uJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyYXlUeXBlQW5ub3RhdGlvbjogJ0FycmF5VHlwZUFubm90YXRpb24nLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICAgIEJvb2xlYW5UeXBlQW5ub3RhdGlvbjogJ0Jvb2xlYW5UeXBlQW5ub3RhdGlvbicsXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXG4gICAgICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246ICdDbGFzc0RlY2xhcmF0aW9uJyxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiAnQ2xhc3NFeHByZXNzaW9uJyxcbiAgICAgICAgQ2xhc3NJbXBsZW1lbnRzOiAnQ2xhc3NJbXBsZW1lbnRzJyxcbiAgICAgICAgQ2xhc3NQcm9wZXJ0eTogJ0NsYXNzUHJvcGVydHknLFxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6ICdDb21wcmVoZW5zaW9uQmxvY2snLFxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogJ0NvbXByZWhlbnNpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBEZWNsYXJlQ2xhc3M6ICdEZWNsYXJlQ2xhc3MnLFxuICAgICAgICBEZWNsYXJlRnVuY3Rpb246ICdEZWNsYXJlRnVuY3Rpb24nLFxuICAgICAgICBEZWNsYXJlTW9kdWxlOiAnRGVjbGFyZU1vZHVsZScsXG4gICAgICAgIERlY2xhcmVWYXJpYWJsZTogJ0RlY2xhcmVWYXJpYWJsZScsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cG9ydERlY2xhcmF0aW9uOiAnRXhwb3J0RGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnRCYXRjaFNwZWNpZmllcjogJ0V4cG9ydEJhdGNoU3BlY2lmaWVyJyxcbiAgICAgICAgRXhwb3J0U3BlY2lmaWVyOiAnRXhwb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6ICdGb3JPZlN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgRnVuY3Rpb25UeXBlQW5ub3RhdGlvbjogJ0Z1bmN0aW9uVHlwZUFubm90YXRpb24nLFxuICAgICAgICBGdW5jdGlvblR5cGVQYXJhbTogJ0Z1bmN0aW9uVHlwZVBhcmFtJyxcbiAgICAgICAgR2VuZXJpY1R5cGVBbm5vdGF0aW9uOiAnR2VuZXJpY1R5cGVBbm5vdGF0aW9uJyxcbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246ICdJbXBvcnREZWNsYXJhdGlvbicsXG4gICAgICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6ICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJyxcbiAgICAgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJyxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiAnSW1wb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgSW50ZXJmYWNlRGVjbGFyYXRpb246ICdJbnRlcmZhY2VEZWNsYXJhdGlvbicsXG4gICAgICAgIEludGVyZmFjZUV4dGVuZHM6ICdJbnRlcmZhY2VFeHRlbmRzJyxcbiAgICAgICAgSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb246ICdJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbicsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogJ01vZHVsZVNwZWNpZmllcicsXG4gICAgICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgTnVsbGFibGVUeXBlQW5ub3RhdGlvbjogJ051bGxhYmxlVHlwZUFubm90YXRpb24nLFxuICAgICAgICBOdW1iZXJUeXBlQW5ub3RhdGlvbjogJ051bWJlclR5cGVBbm5vdGF0aW9uJyxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXG4gICAgICAgIE9iamVjdFR5cGVBbm5vdGF0aW9uOiAnT2JqZWN0VHlwZUFubm90YXRpb24nLFxuICAgICAgICBPYmplY3RUeXBlQ2FsbFByb3BlcnR5OiAnT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eScsXG4gICAgICAgIE9iamVjdFR5cGVJbmRleGVyOiAnT2JqZWN0VHlwZUluZGV4ZXInLFxuICAgICAgICBPYmplY3RUeXBlUHJvcGVydHk6ICdPYmplY3RUeXBlUHJvcGVydHknLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBRdWFsaWZpZWRUeXBlSWRlbnRpZmllcjogJ1F1YWxpZmllZFR5cGVJZGVudGlmaWVyJyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxuICAgICAgICBTcHJlYWRQcm9wZXJ0eTogJ1NwcmVhZFByb3BlcnR5JyxcbiAgICAgICAgU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uOiAnU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uJyxcbiAgICAgICAgU3RyaW5nVHlwZUFubm90YXRpb246ICdTdHJpbmdUeXBlQW5ub3RhdGlvbicsXG4gICAgICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50JyxcbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiAnVGVtcGxhdGVMaXRlcmFsJyxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXG4gICAgICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxuICAgICAgICBUdXBsZVR5cGVBbm5vdGF0aW9uOiAnVHVwbGVUeXBlQW5ub3RhdGlvbicsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFR5cGVBbGlhczogJ1R5cGVBbGlhcycsXG4gICAgICAgIFR5cGVBbm5vdGF0aW9uOiAnVHlwZUFubm90YXRpb24nLFxuICAgICAgICBUeXBlQ2FzdEV4cHJlc3Npb246ICdUeXBlQ2FzdEV4cHJlc3Npb24nLFxuICAgICAgICBUeXBlb2ZUeXBlQW5ub3RhdGlvbjogJ1R5cGVvZlR5cGVBbm5vdGF0aW9uJyxcbiAgICAgICAgVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uOiAnVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uJyxcbiAgICAgICAgVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb246ICdUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbicsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVuaW9uVHlwZUFubm90YXRpb246ICdVbmlvblR5cGVBbm5vdGF0aW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFZvaWRUeXBlQW5ub3RhdGlvbjogJ1ZvaWRUeXBlQW5ub3RhdGlvbicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXG4gICAgICAgIEpTWElkZW50aWZpZXI6ICdKU1hJZGVudGlmaWVyJyxcbiAgICAgICAgSlNYTmFtZXNwYWNlZE5hbWU6ICdKU1hOYW1lc3BhY2VkTmFtZScsXG4gICAgICAgIEpTWE1lbWJlckV4cHJlc3Npb246ICdKU1hNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgSlNYRW1wdHlFeHByZXNzaW9uOiAnSlNYRW1wdHlFeHByZXNzaW9uJyxcbiAgICAgICAgSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjogJ0pTWEV4cHJlc3Npb25Db250YWluZXInLFxuICAgICAgICBKU1hFbGVtZW50OiAnSlNYRWxlbWVudCcsXG4gICAgICAgIEpTWENsb3NpbmdFbGVtZW50OiAnSlNYQ2xvc2luZ0VsZW1lbnQnLFxuICAgICAgICBKU1hPcGVuaW5nRWxlbWVudDogJ0pTWE9wZW5pbmdFbGVtZW50JyxcbiAgICAgICAgSlNYQXR0cmlidXRlOiAnSlNYQXR0cmlidXRlJyxcbiAgICAgICAgSlNYU3ByZWFkQXR0cmlidXRlOiAnSlNYU3ByZWFkQXR0cmlidXRlJyxcbiAgICAgICAgSlNYVGV4dDogJ0pTWFRleHQnLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nLFxuICAgICAgICBBd2FpdEV4cHJlc3Npb246ICdBd2FpdEV4cHJlc3Npb24nXG4gICAgfTtcblxuICAgIFByb3BlcnR5S2luZCA9IHtcbiAgICAgICAgRGF0YTogMSxcbiAgICAgICAgR2V0OiAyLFxuICAgICAgICBTZXQ6IDRcbiAgICB9O1xuXG4gICAgQ2xhc3NQcm9wZXJ0eVR5cGUgPSB7XG4gICAgICAgICdzdGF0aWMnOiAnc3RhdGljJyxcbiAgICAgICAgcHJvdG90eXBlOiAncHJvdG90eXBlJ1xuICAgIH07XG5cbiAgICAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuICAgIE1lc3NhZ2VzID0ge1xuICAgICAgICBVbmV4cGVjdGVkVG9rZW46ICdVbmV4cGVjdGVkIHRva2VuICUwJyxcbiAgICAgICAgVW5leHBlY3RlZE51bWJlcjogJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcbiAgICAgICAgVW5leHBlY3RlZFN0cmluZzogJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcbiAgICAgICAgVW5leHBlY3RlZElkZW50aWZpZXI6ICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxuICAgICAgICBVbmV4cGVjdGVkUmVzZXJ2ZWQ6ICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxuICAgICAgICBVbmV4cGVjdGVkVGVtcGxhdGU6ICdVbmV4cGVjdGVkIHF1YXNpICUwJyxcbiAgICAgICAgVW5leHBlY3RlZEVPUzogJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICAgICAgTmV3bGluZUFmdGVyVGhyb3c6ICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxuICAgICAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJyxcbiAgICAgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXG4gICAgICAgIEludmFsaWRMSFNJbkZvcm1hbHNMaXN0OiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3JtYWxzIGxpc3QnLFxuICAgICAgICBJbnZhbGlkTEhTSW5Gb3JJbjogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcbiAgICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgICAgTm9DYXRjaE9yRmluYWxseTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuICAgICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgICBJbGxlZ2FsRHVwbGljYXRlQ2xhc3NQcm9wZXJ0eTogJ0lsbGVnYWwgZHVwbGljYXRlIHByb3BlcnR5IGluIGNsYXNzIGRlZmluaXRpb24nLFxuICAgICAgICBJbGxlZ2FsQ2xhc3NDb25zdHJ1Y3RvclByb3BlcnR5OiAnSWxsZWdhbCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBpbiBjbGFzcyBkZWZpbml0aW9uJyxcbiAgICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICAgIElsbGVnYWxTcHJlYWQ6ICdJbGxlZ2FsIHNwcmVhZCBlbGVtZW50JyxcbiAgICAgICAgU3RyaWN0TW9kZVdpdGg6ICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RWYXJOYW1lOiAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1OYW1lOiAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXG4gICAgICAgIFBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcjogJ1Jlc3QgcGFyYW1ldGVyIG11c3QgYmUgZmluYWwgcGFyYW1ldGVyIG9mIGFuIGFyZ3VtZW50IGxpc3QnLFxuICAgICAgICBEZWZhdWx0UmVzdFBhcmFtZXRlcjogJ1Jlc3QgcGFyYW1ldGVyIGNhbiBub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUnLFxuICAgICAgICBFbGVtZW50QWZ0ZXJTcHJlYWRFbGVtZW50OiAnU3ByZWFkIG11c3QgYmUgdGhlIGZpbmFsIGVsZW1lbnQgb2YgYW4gZWxlbWVudCBsaXN0JyxcbiAgICAgICAgUHJvcGVydHlBZnRlclNwcmVhZFByb3BlcnR5OiAnQSByZXN0IHByb3BlcnR5IG11c3QgYmUgdGhlIGZpbmFsIHByb3BlcnR5IG9mIGFuIG9iamVjdCBsaXRlcmFsJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybkFzUmVzdFBhcmFtZXRlcjogJ0ludmFsaWQgcmVzdCBwYXJhbWV0ZXInLFxuICAgICAgICBPYmplY3RQYXR0ZXJuQXNTcHJlYWQ6ICdJbnZhbGlkIHNwcmVhZCBhcmd1bWVudCcsXG4gICAgICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eTogJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgQWNjZXNzb3JEYXRhUHJvcGVydHk6ICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgZGF0YSBhbmQgYWNjZXNzb3IgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgICAgQWNjZXNzb3JHZXRTZXQ6ICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgbXVsdGlwbGUgZ2V0L3NldCBhY2Nlc3NvcnMgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgICAgU3RyaWN0TEhTQXNzaWdubWVudDogJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RMSFNQb3N0Zml4OiAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0TEhTUHJlZml4OiAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBNaXNzaW5nRnJvbUNsYXVzZTogJ01pc3NpbmcgZnJvbSBjbGF1c2UnLFxuICAgICAgICBOb0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2U6ICdNaXNzaW5nIGFzIGFmdGVyIGltcG9ydCAqJyxcbiAgICAgICAgSW52YWxpZE1vZHVsZVNwZWNpZmllcjogJ0ludmFsaWQgbW9kdWxlIHNwZWNpZmllcicsXG4gICAgICAgIElsbGVnYWxJbXBvcnREZWNsYXJhdGlvbjogJ0lsbGVnYWwgaW1wb3J0IGRlY2xhcmF0aW9uJyxcbiAgICAgICAgSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uOiAnSWxsZWdhbCBleHBvcnQgZGVjbGFyYXRpb24nLFxuICAgICAgICBOb1VuaW5pdGlhbGl6ZWRDb25zdDogJ0NvbnN0IG11c3QgYmUgaW5pdGlhbGl6ZWQnLFxuICAgICAgICBDb21wcmVoZW5zaW9uUmVxdWlyZXNCbG9jazogJ0NvbXByZWhlbnNpb24gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBibG9jaycsXG4gICAgICAgIENvbXByZWhlbnNpb25FcnJvcjogJ0NvbXByZWhlbnNpb24gRXJyb3InLFxuICAgICAgICBFYWNoTm90QWxsb3dlZDogJ0VhY2ggaXMgbm90IHN1cHBvcnRlZCcsXG4gICAgICAgIEludmFsaWRKU1hBdHRyaWJ1dGVWYWx1ZTogJ0pTWCB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGFuIGV4cHJlc3Npb24gb3IgYSBxdW90ZWQgSlNYIHRleHQnLFxuICAgICAgICBFeHBlY3RlZEpTWENsb3NpbmdUYWc6ICdFeHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgJTAnLFxuICAgICAgICBBZGphY2VudEpTWEVsZW1lbnRzOiAnQWRqYWNlbnQgSlNYIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBhbiBlbmNsb3NpbmcgdGFnJyxcbiAgICAgICAgQ29uZnVzZWRBYm91dEZ1bmN0aW9uVHlwZTogJ1VuZXhwZWN0ZWQgdG9rZW4gPT4uIEl0IGxvb2tzIGxpa2UgJyArXG4gICAgICAgICAgICAneW91IGFyZSB0cnlpbmcgdG8gd3JpdGUgYSBmdW5jdGlvbiB0eXBlLCBidXQgeW91IGVuZGVkIHVwICcgK1xuICAgICAgICAgICAgJ3dyaXRpbmcgYSBncm91cGVkIHR5cGUgZm9sbG93ZWQgYnkgYW4gPT4sIHdoaWNoIGlzIGEgc3ludGF4ICcgK1xuICAgICAgICAgICAgJ2Vycm9yLiBSZW1lbWJlciwgZnVuY3Rpb24gdHlwZSBwYXJhbWV0ZXJzIGFyZSBuYW1lZCBzbyBmdW5jdGlvbiAnICtcbiAgICAgICAgICAgICd0eXBlcyBsb29rIGxpa2UgKG5hbWUxOiB0eXBlMSwgbmFtZTI6IHR5cGUyKSA9PiByZXR1cm5UeXBlLiBZb3UgJyArXG4gICAgICAgICAgICAncHJvYmFibHkgd3JvdGUgKHR5cGUxKSA9PiByZXR1cm5UeXBlJ1xuICAgIH07XG5cbiAgICAvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxuICAgIFJlZ2V4ID0ge1xuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogbmV3IFJlZ0V4cCgnW1xceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXScpLFxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiBuZXcgUmVnRXhwKCdbXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjY5XFx1MDY2ZS1cXHUwNmQzXFx1MDZkNS1cXHUwNmRjXFx1MDZkZi1cXHUwNmU4XFx1MDZlYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTAtXFx1MDc0YVxcdTA3NGQtXFx1MDdiMVxcdTA3YzAtXFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MmRcXHUwODQwLVxcdTA4NWJcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliYy1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2VcXHUwOWQ3XFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTNcXHUwOWU2LVxcdTA5ZjFcXHUwYTAxLVxcdTBhMDNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE2Ni1cXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJjLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWQwXFx1MGFlMC1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2MtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiNzFcXHUwYjgyXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQwXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2QtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM1OFxcdTBjNTlcXHUwYzYwLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmMtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNkZVxcdTBjZTAtXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjFcXHUwY2YyXFx1MGQwMlxcdTBkMDNcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGVcXHUwZDU3XFx1MGQ2MC1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4MlxcdTBkODNcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMDEtXFx1MGUzYVxcdTBlNDAtXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWI5XFx1MGViYi1cXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmM2UtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOWRcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM1ZC1cXHUxMzVmXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3ZDNcXHUxN2Q3XFx1MTdkY1xcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMWJcXHUxYTIwLVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWE3XFx1MWIwMC1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYmYzXFx1MWMwMC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM0ZC1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2Y2XFx1MWQwMC1cXHUxZGU2XFx1MWRmYy1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkN2YtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJkZTAtXFx1MmRmZlxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMmZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5YVxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2N2YtXFx1YTY5N1xcdWE2OWYtXFx1YTZmMVxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgyN1xcdWE4NDAtXFx1YTg3M1xcdWE4ODAtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmN1xcdWE4ZmJcXHVhOTAwLVxcdWE5MmRcXHVhOTMwLVxcdWE5NTNcXHVhOTYwLVxcdWE5N2NcXHVhOTgwLVxcdWE5YzBcXHVhOWNmLVxcdWE5ZDlcXHVhYTAwLVxcdWFhMzZcXHVhYTQwLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3YlxcdWFhODAtXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlZlxcdWFhZjItXFx1YWFmNlxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZC1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMTAtXFx1ZmYxOVxcdWZmMjEtXFx1ZmYzYVxcdWZmM2ZcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNdJyksXG4gICAgICAgIExlYWRpbmdaZXJvczogbmV3IFJlZ0V4cCgnXjArKD8hJCknKVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgLy8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XG4gICAgLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4gICAgLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU3RyaW5nTWFwKCkge1xuICAgICAgICB0aGlzLiRkYXRhID0ge307XG4gICAgfVxuXG4gICAgU3RyaW5nTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGtleSA9ICckJyArIGtleTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGRhdGFba2V5XTtcbiAgICB9O1xuXG4gICAgU3RyaW5nTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSAnJCcgKyBrZXk7XG4gICAgICAgIHRoaXMuJGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3RyaW5nTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGtleSA9ICckJyArIGtleTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLiRkYXRhLCBrZXkpO1xuICAgIH07XG5cbiAgICBTdHJpbmdNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAga2V5ID0gJyQnICsga2V5O1xuICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuJGRhdGFba2V5XTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA+PSA0OCAmJiBjaCA8PSA1Nyk7ICAgLy8gMC4uOVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKSA+PSAwO1xuICAgIH1cblxuXG4gICAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMzIpIHx8ICAvLyBzcGFjZVxuICAgICAgICAgICAgKGNoID09PSA5KSB8fCAgICAgIC8vIHRhYlxuICAgICAgICAgICAgKGNoID09PSAweEIpIHx8XG4gICAgICAgICAgICAoY2ggPT09IDB4QykgfHxcbiAgICAgICAgICAgIChjaCA9PT0gMHhBMCkgfHxcbiAgICAgICAgICAgIChjaCA+PSAweDE2ODAgJiYgJ1xcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGJy5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSA+IDApO1xuICAgIH1cblxuICAgIC8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbiAgICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDEwKSB8fCAoY2ggPT09IDEzKSB8fCAoY2ggPT09IDB4MjAyOCkgfHwgKGNoID09PSAweDIwMjkpO1xuICAgIH1cblxuICAgIC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMzYpIHx8IChjaCA9PT0gOTUpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgICAgKGNoID49IDY1ICYmIGNoIDw9IDkwKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSA5NyAmJiBjaCA8PSAxMjIpIHx8ICAgICAgICAvLyBhLi56XG4gICAgICAgICAgICAoY2ggPT09IDkyKSB8fCAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMzYpIHx8IChjaCA9PT0gOTUpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgICAgKGNoID49IDY1ICYmIGNoIDw9IDkwKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSA5NyAmJiBjaCA8PSAxMjIpIHx8ICAgICAgICAvLyBhLi56XG4gICAgICAgICAgICAoY2ggPj0gNDggJiYgY2ggPD0gNTcpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgICAgKGNoID09PSA5MikgfHwgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICAgIH1cblxuICAgIC8vIDcuNi4xLjIgRnV0dXJlIFJlc2VydmVkIFdvcmRzXG5cbiAgICBmdW5jdGlvbiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICAgIGNhc2UgJ2V4dGVuZHMnOlxuICAgICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICBjYXNlICdzdXBlcic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0cmljdGVkV29yZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnY29uc3QnIGlzIHNwZWNpYWxpemVkIGFzIEtleXdvcmQgaW4gVjguXG4gICAgICAgIC8vICd5aWVsZCcgaXMgb25seSB0cmVhdGVkIGFzIGEga2V5d29yZCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgLy8gJ2xldCcgaXMgZm9yIGNvbXBhdGlibGl0eSB3aXRoIFNwaWRlck1vbmtleSBhbmQgRVMubmV4dC5cbiAgICAgICAgLy8gU29tZSBvdGhlcnMgYXJlIGZyb20gZnV0dXJlIHJlc2VydmVkIHdvcmRzLlxuXG4gICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA3LjQgQ29tbWVudHNcblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnQodHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQsIGxvYykge1xuICAgICAgICB2YXIgY29tbWVudDtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicsICdDb21tZW50IG11c3QgaGF2ZSB2YWxpZCBwb3NpdGlvbicpO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHdheSB0aGUgYWN0dWFsIHRva2VuIGlzIHNjYW5uZWQsIG9mdGVuIHRoZSBjb21tZW50c1xuICAgICAgICAvLyAoaWYgYW55KSBhcmUgc2tpcHBlZCB0d2ljZSBkdXJpbmcgdGhlIGxleGljYWwgYW5hbHlzaXMuXG4gICAgICAgIC8vIFRodXMsIHdlIG5lZWQgdG8gc2tpcCBhZGRpbmcgYSBjb21tZW50IGlmIHRoZSBjb21tZW50IGFycmF5IGFscmVhZHlcbiAgICAgICAgLy8gaGFuZGxlZCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmxhc3RDb21tZW50U3RhcnQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sYXN0Q29tbWVudFN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgICAgY29tbWVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgIGNvbW1lbnQubG9jID0gbG9jO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIGlmIChleHRyYS5hdHRhY2hDb21tZW50KSB7XG4gICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBTaW5nbGVMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXggLSAyO1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgMiwgaW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdMaW5lJywgY29tbWVudCwgc3RhcnQsIGluZGV4IC0gMSwgbG9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAxMyAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAyLCBpbmRleCk7XG4gICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwTXVsdGlMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgc3RhcnQgPSBpbmRleCAtIDI7XG4gICAgICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDIpIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50IGVuZHMgd2l0aCAnKi8nIChjaGFyICM0MiwgY2hhciAjNDcpLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSA0Nykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAyLCBpbmRleCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdCbG9jaycsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCwgbG9jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcENvbW1lbnQoKSB7XG4gICAgICAgIHZhciBjaDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDcpIHsgLy8gNDcgaXMgJy8nXG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDIpIHsgIC8vIDQyIGlzICcqJ1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBza2lwTXVsdGlMaW5lQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XG5cbiAgICAgICAgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKSB7XG4gICAgICAgIHZhciBjaCwgY29kZSwgY3UxLCBjdTI7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBjb2RlID0gMDtcblxuICAgICAgICAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cbiAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVURi0xNiBFbmNvZGluZ1xuICAgICAgICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1MSA9ICgoY29kZSAtIDB4MTAwMDApID4+IDEwKSArIDB4RDgwMDtcbiAgICAgICAgY3UyID0gKChjb2RlIC0gMHgxMDAwMCkgJiAxMDIzKSArIDB4REMwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY3UxLCBjdTIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgY2gsIGlkO1xuXG4gICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gICAgICAgIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgICAgLy8gJ1xcdScgKGNoYXIgIzkyLCBjaGFyICMxMTcpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDExNykge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCA9IGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgICAgICAgLy8gJ1xcdScgKGNoYXIgIzkyLCBjaGFyICMxMTcpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBpZiAoY2ggPT09IDkyKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMTE3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXgrKztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChjaGFyICM5MikgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXNjYXBlZElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGlkLCB0eXBlO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgICAgLy8gQmFja3NsYXNoIChjaGFyICM5Mikgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICBpZCA9IChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDkyKSA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xuICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uQm9vbGVhbkxpdGVyYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvLyA3LjcgUHVuY3R1YXRvcnNcblxuICAgIGZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBpbmRleCxcbiAgICAgICAgICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCksXG4gICAgICAgICAgICBjb2RlMixcbiAgICAgICAgICAgIGNoMSA9IHNvdXJjZVtpbmRleF0sXG4gICAgICAgICAgICBjaDIsXG4gICAgICAgICAgICBjaDMsXG4gICAgICAgICAgICBjaDQ7XG5cbiAgICAgICAgaWYgKHN0YXRlLmluSlNYVGFnIHx8IHN0YXRlLmluSlNYQ2hpbGQpIHtcbiAgICAgICAgICAgIC8vIERvbid0IG5lZWQgdG8gY2hlY2sgZm9yICd7JyBhbmQgJ30nIGFzIGl0J3MgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBjb3JyZWN0bHkgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSA2MDogIC8vIDxcbiAgICAgICAgICAgIGNhc2UgNjI6ICAvLyA+XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICAgIGNhc2UgNDA6ICAgLy8gKCBvcGVuIGJyYWNrZXRcbiAgICAgICAgY2FzZSA0MTogICAvLyApIGNsb3NlIGJyYWNrZXRcbiAgICAgICAgY2FzZSA1OTogICAvLyA7IHNlbWljb2xvblxuICAgICAgICBjYXNlIDQ0OiAgIC8vICwgY29tbWFcbiAgICAgICAgY2FzZSAxMjM6ICAvLyB7IG9wZW4gY3VybHkgYnJhY2VcbiAgICAgICAgY2FzZSAxMjU6ICAvLyB9IGNsb3NlIGN1cmx5IGJyYWNlXG4gICAgICAgIGNhc2UgOTE6ICAgLy8gW1xuICAgICAgICBjYXNlIDkzOiAgIC8vIF1cbiAgICAgICAgY2FzZSA1ODogICAvLyA6XG4gICAgICAgIGNhc2UgNjM6ICAgLy8gP1xuICAgICAgICBjYXNlIDEyNjogIC8vIH5cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMTIzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gZXh0cmEudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICAgICAgLy8gJz0nIChjaGFyICM2MSkgbWFya3MgYW4gYXNzaWdubWVudCBvciBjb21wYXJpc29uIG9wZXJhdG9yLlxuICAgICAgICAgICAgaWYgKGNvZGUyID09PSA2MSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMzc6ICAvLyAlXG4gICAgICAgICAgICAgICAgY2FzZSAzODogIC8vICZcbiAgICAgICAgICAgICAgICBjYXNlIDQyOiAgLy8gKjpcbiAgICAgICAgICAgICAgICBjYXNlIDQzOiAgLy8gK1xuICAgICAgICAgICAgICAgIGNhc2UgNDU6ICAvLyAtXG4gICAgICAgICAgICAgICAgY2FzZSA0NzogIC8vIC9cbiAgICAgICAgICAgICAgICBjYXNlIDYwOiAgLy8gPFxuICAgICAgICAgICAgICAgIGNhc2UgNjI6ICAvLyA+XG4gICAgICAgICAgICAgICAgY2FzZSA5NDogIC8vIF5cbiAgICAgICAgICAgICAgICBjYXNlIDEyNDogLy8gfFxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMzM6IC8vICFcbiAgICAgICAgICAgICAgICBjYXNlIDYxOiAvLyA9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIT09IGFuZCA9PT1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBlZWsgbW9yZSBjaGFyYWN0ZXJzLlxuXG4gICAgICAgIGNoMiA9IHNvdXJjZVtpbmRleCArIDFdO1xuICAgICAgICBjaDMgPSBzb3VyY2VbaW5kZXggKyAyXTtcbiAgICAgICAgY2g0ID0gc291cmNlW2luZGV4ICsgM107XG5cbiAgICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvcjogPj4+PVxuXG4gICAgICAgIGlmIChjaDEgPT09ICc+JyAmJiBjaDIgPT09ICc+JyAmJiBjaDMgPT09ICc+Jykge1xuICAgICAgICAgICAgaWYgKGNoNCA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJz4+Pj0nLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJz4nICYmIGNoMiA9PT0gJz4nICYmIGNoMyA9PT0gJz4nICYmICFzdGF0ZS5pblR5cGUpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc+Pj4nLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJzwnICYmIGNoMiA9PT0gJzwnICYmIGNoMyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPDw9JyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaDEgPT09ICc+JyAmJiBjaDIgPT09ICc+JyAmJiBjaDMgPT09ICc9Jykge1xuICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz4+PScsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gxID09PSAnLicgJiYgY2gyID09PSAnLicgJiYgY2gzID09PSAnLicpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcuLi4nLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXIgMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ICsrIC0tIDw8ID4+ICYmIHx8XG5cbiAgICAgICAgLy8gRG9uJ3QgbWF0Y2ggdGhlc2UgdG9rZW5zIGlmIHdlJ3JlIGluIGEgdHlwZSwgc2luY2UgdGhleSBuZXZlciBjYW5cbiAgICAgICAgLy8gb2NjdXIgYW5kIGNhbiBtZXNzIHVwIHR5cGVzIGxpa2UgTWFwPHN0cmluZywgQXJyYXk8c3RyaW5nPj5cbiAgICAgICAgaWYgKGNoMSA9PT0gY2gyICYmICgnKy08PiZ8Jy5pbmRleE9mKGNoMSkgPj0gMCkgJiYgIXN0YXRlLmluVHlwZSkge1xuICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2gxICsgY2gyLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJz0nICYmIGNoMiA9PT0gJz4nKSB7XG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPT4nLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaDEsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gxID09PSAnLicpIHtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoMSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICB9XG5cbiAgICAvLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiBzY2FuSGV4TGl0ZXJhbChzdGFydCkge1xuICAgICAgICB2YXIgbnVtYmVyID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtYmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuQmluYXJ5TGl0ZXJhbChzdGFydCkge1xuICAgICAgICB2YXIgY2gsIG51bWJlcjtcblxuICAgICAgICBudW1iZXIgPSAnJztcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtYmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gb25seSAwYiBvciAwQlxuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nhbk9jdGFsTGl0ZXJhbChwcmVmaXgsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBudW1iZXIsIG9jdGFsO1xuXG4gICAgICAgIGlmIChpc09jdGFsRGlnaXQocHJlZml4KSkge1xuICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgbnVtYmVyID0gJzAnICsgc291cmNlW2luZGV4KytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2N0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBudW1iZXIgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9jdGFsICYmIG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgMG8gb3IgME9cbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpIHx8IGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMG8nLlxuICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnYicgfHwgY2ggPT09ICdCJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdvJyB8fCBjaCA9PT0gJ08nIHx8IGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnIHN1Y2ggYXMgJzA5JyBpcyBpbGxlZ2FsLlxuICAgICAgICAgICAgICAgIGlmIChjaCAmJiBpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyA3LjguNCBTdHJpbmcgTGl0ZXJhbHNcblxuICAgIGZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICAgICAgICB2YXIgc3RyID0gJycsIHF1b3RlLCBzdGFydCwgY2gsIGNvZGUsIHVuZXNjYXBlZCwgcmVzdG9yZSwgb2N0YWwgPSBmYWxzZTtcblxuICAgICAgICBxdW90ZSA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGFzc2VydCgocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInKSxcbiAgICAgICAgICAgICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICArK2luZGV4O1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLlN0cmluZ0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblRlbXBsYXRlKCkge1xuICAgICAgICB2YXIgY29va2VkID0gJycsIGNoLCBzdGFydCwgdGVybWluYXRlZCwgdGFpbCwgcmVzdG9yZSwgdW5lc2NhcGVkLCBjb2RlLCBvY3RhbDtcblxuICAgICAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIHRhaWwgPSBmYWxzZTtcbiAgICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgICArK2luZGV4O1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdgJykge1xuICAgICAgICAgICAgICAgIHRhaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmICghaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx2JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5UZW1wbGF0ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY29va2VkOiBjb29rZWQsXG4gICAgICAgICAgICAgICAgcmF3OiBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAxLCBpbmRleCAtICgodGFpbCkgPyAxIDogMikpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5UZW1wbGF0ZUVsZW1lbnQob3B0aW9uKSB7XG4gICAgICAgIHZhciBzdGFydHNXaXRoLCB0ZW1wbGF0ZTtcblxuICAgICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgIHN0YXJ0c1dpdGggPSAob3B0aW9uLmhlYWQpID8gJ2AnIDogJ30nO1xuXG4gICAgICAgIGlmIChzb3VyY2VbaW5kZXhdICE9PSBzdGFydHNXaXRoKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wbGF0ZSA9IHNjYW5UZW1wbGF0ZSgpO1xuXG4gICAgICAgIHBlZWsoKTtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICAgICAgICB2YXIgdG1wID0gcGF0dGVybixcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSBlYWNoIGFzdHJhbCBzeW1ib2wgYW5kIGV2ZXJ5IFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uXG4gICAgICAgICAgICAvLyByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgYXJlIG9ubHkgdmFsaWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGAvdWAgZmxhZy5cbiAgICAgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgICAgICAgICAvLyBuZWdhdGl2ZXMgaW4gdW5saWtlbHkgc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7NjF9LWJdYCBpcyBhXG4gICAgICAgICAgICAvLyBwZXJmZWN0bHkgdmFsaWQgcGF0dGVybiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYFthLWJdYCwgYnV0IGl0XG4gICAgICAgICAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICAgIHRtcCA9IHRtcFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9L2csIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCAneCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAodG1wKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxuICAgICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XG4gICAgICAgIC8vIHVzZXMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwQm9keSgpIHtcbiAgICAgICAgdmFyIGNoLCBzdHIsIGNsYXNzTWFya2VyLCB0ZXJtaW5hdGVkLCBib2R5O1xuXG4gICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICAgICAgICBzdHIgPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgdGVybWluYXRlZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAvLyBFQ01BLTI2MiA3LjguNVxuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgIGJvZHkgPSBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBib2R5LFxuICAgICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cEZsYWdzKCkge1xuICAgICAgICB2YXIgY2gsIHN0ciwgZmxhZ3MsIHJlc3RvcmU7XG5cbiAgICAgICAgc3RyID0gJyc7XG4gICAgICAgIGZsYWdzID0gJyc7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IGluZGV4OyArK3Jlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc291cmNlW3Jlc3RvcmVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGZsYWdzLFxuICAgICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBib2R5LCBmbGFncywgdmFsdWU7XG5cbiAgICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcbiAgICAgICAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgICAgICAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcblxuICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGl0ZXJhbDogYm9keS5saXRlcmFsICsgZmxhZ3MubGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZVNsYXNoKCkge1xuICAgICAgICB2YXIgcHJldlRva2VuLFxuICAgICAgICAgICAgY2hlY2tUb2tlbjtcbiAgICAgICAgLy8gVXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG4gICAgICAgIHByZXZUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghcHJldlRva2VuKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIGJlZm9yZSB0aGF0OiBpdCBjYW5ub3QgYmUgYSBkaXZpc2lvbi5cbiAgICAgICAgICAgIHJldHVybiBzY2FuUmVnRXhwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlblBhcmVuVG9rZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tUb2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGVja1Rva2VuLnZhbHVlID09PSAnaWYnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3doaWxlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICdmb3InIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3dpdGgnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblJlZ0V4cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5SZWdFeHAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVja1Rva2VuIGRldGVybWluZXMgd2hldGhlciB0aGUgZnVuY3Rpb24gaXNcbiAgICAgICAgICAgICAgICAvLyBhIGRlY2xhcmF0aW9uIG9yIGFuIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgaWYgKEZuRXhwclRva2Vucy5pbmRleE9mKGNoZWNrVG9rZW4udmFsdWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgZGVjbGFyYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5SZWdFeHAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzY2FuUmVnRXhwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiYgcHJldlRva2VuLnZhbHVlICE9PSAndGhpcycpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuUmVnRXhwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5KU1hDaGlsZCkge1xuICAgICAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtpbmRleCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmluSlNYQ2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBhZHZhbmNlSlNYQ2hpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICAgIGlmIChjaCA9PT0gNDAgfHwgY2ggPT09IDQxIHx8IGNoID09PSA1OCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKCMzOSkgb3IgZG91YmxlIHF1b3RlICgjMzQpLlxuICAgICAgICBpZiAoY2ggPT09IDM5IHx8IGNoID09PSAzNCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmluSlNYVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5KU1hTdHJpbmdMaXRlcmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhblN0cmluZ0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5pbkpTWFRhZyAmJiBpc0pTWElkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuSlNYSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSA5Nikge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG90ICguKSBjaGFyICM0NiBjYW4gYWxzbyBzdGFydCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgaGVuY2UgdGhlIG5lZWRcbiAgICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoY2ggPT09IDQ2KSB7XG4gICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsYXNoICgvKSBjaGFyICM0NyBjYW4gYWxzbyBzdGFydCBhIHJlZ2V4LlxuICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUgJiYgY2ggPT09IDQ3KSB7XG4gICAgICAgICAgICByZXR1cm4gYWR2YW5jZVNsYXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaW5kZXggPSB0b2tlbi5yYW5nZVsxXTtcbiAgICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcblxuICAgICAgICBsb29rYWhlYWQgPSBhZHZhbmNlKCk7XG5cbiAgICAgICAgaW5kZXggPSB0b2tlbi5yYW5nZVsxXTtcbiAgICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQ7XG5cbiAgICAgICAgcG9zID0gaW5kZXg7XG4gICAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgbG9va2FoZWFkID0gYWR2YW5jZSgpO1xuICAgICAgICBpbmRleCA9IHBvcztcbiAgICAgICAgbGluZU51bWJlciA9IGxpbmU7XG4gICAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb2thaGVhZDIoKSB7XG4gICAgICAgIHZhciBhZHYsIHBvcywgbGluZSwgc3RhcnQsIHJlc3VsdDtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgY29sbGVjdGluZyB0aGUgdG9rZW5zLCBkb24ndCBncmFiIHRoZSBuZXh0IG9uZSB5ZXQuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGFkdiA9ICh0eXBlb2YgZXh0cmEuYWR2YW5jZSA9PT0gJ2Z1bmN0aW9uJykgPyBleHRyYS5hZHZhbmNlIDogYWR2YW5jZTtcblxuICAgICAgICBwb3MgPSBpbmRleDtcbiAgICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIC8vIFNjYW4gZm9yIHRoZSBuZXh0IGltbWVkaWF0ZSB0b2tlbi5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChsb29rYWhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvb2thaGVhZCA9IGFkdigpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gbG9va2FoZWFkLnJhbmdlWzFdO1xuICAgICAgICBsaW5lTnVtYmVyID0gbG9va2FoZWFkLmxpbmVOdW1iZXI7XG4gICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5saW5lU3RhcnQ7XG5cbiAgICAgICAgLy8gR3JhYiB0aGUgdG9rZW4gcmlnaHQgYWZ0ZXIuXG4gICAgICAgIHJlc3VsdCA9IGFkdigpO1xuICAgICAgICBpbmRleCA9IHBvcztcbiAgICAgICAgbGluZU51bWJlciA9IGxpbmU7XG4gICAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV3aW5kKHRva2VuKSB7XG4gICAgICAgIGluZGV4ID0gdG9rZW4ucmFuZ2VbMF07XG4gICAgICAgIGxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG4gICAgICAgIGxvb2thaGVhZCA9IHRva2VuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtlckNyZWF0ZSgpIHtcbiAgICAgICAgaWYgKCFleHRyYS5sb2MgJiYgIWV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIHJldHVybiB7b2Zmc2V0OiBpbmRleCwgbGluZTogbGluZU51bWJlciwgY29sOiBpbmRleCAtIGxpbmVTdGFydH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFya2VyQ3JlYXRlUHJlc2VydmVXaGl0ZXNwYWNlKCkge1xuICAgICAgICBpZiAoIWV4dHJhLmxvYyAmJiAhZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtvZmZzZXQ6IGluZGV4LCBsaW5lOiBsaW5lTnVtYmVyLCBjb2w6IGluZGV4IC0gbGluZVN0YXJ0fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQ29tbWVudChub2RlKSB7XG4gICAgICAgIHZhciBsYXN0Q2hpbGQsXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgYm90dG9tUmlnaHQgPSBleHRyYS5ib3R0b21SaWdodFN0YWNrLFxuICAgICAgICAgICAgbGFzdCA9IGJvdHRvbVJpZ2h0W2JvdHRvbVJpZ2h0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKG5vZGUuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhLnRyYWlsaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnRyYWlsaW5nQ29tbWVudHNbMF0ucmFuZ2VbMF0gPj0gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBleHRyYS50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50cmFpbGluZ0NvbW1lbnRzICYmIGxhc3QudHJhaWxpbmdDb21tZW50c1swXS5yYW5nZVswXSA+PSBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IGxhc3QudHJhaWxpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICBkZWxldGUgbGFzdC50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWF0aW5nIHRoZSBzdGFjay5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIHdoaWxlIChsYXN0ICYmIGxhc3QucmFuZ2VbMF0gPj0gbm9kZS5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgIGxhc3RDaGlsZCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgbGFzdCA9IGJvdHRvbVJpZ2h0LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMgJiYgbGFzdENoaWxkLmxlYWRpbmdDb21tZW50c1tsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDFdLnJhbmdlWzFdIDw9IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmEubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDAgJiYgZXh0cmEubGVhZGluZ0NvbW1lbnRzW2V4dHJhLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxXS5yYW5nZVsxXSA8PSBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGV4dHJhLmxlYWRpbmdDb21tZW50cztcbiAgICAgICAgICAgIGV4dHJhLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IHRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICBib3R0b21SaWdodC5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtlckFwcGx5KG1hcmtlciwgbm9kZSkge1xuICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBbbWFya2VyLm9mZnNldCwgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgIG5vZGUubG9jID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcmtlci5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1hcmtlci5jb2xcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGUgPSBkZWxlZ2F0ZS5wb3N0UHJvY2Vzcyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgU3ludGF4VHJlZURlbGVnYXRlID0ge1xuXG4gICAgICAgIG5hbWU6ICdTeW50YXhUcmVlJyxcblxuICAgICAgICBwb3N0UHJvY2VzczogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5BcnJheUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSAob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicpID8gU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQnJlYWtTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUNhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBjYWxsZWU6IGNhbGxlZSxcbiAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVDYXRjaENsYXVzZTogZnVuY3Rpb24gKHBhcmFtLCBib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYXRjaENsYXVzZSxcbiAgICAgICAgICAgICAgICBwYXJhbTogcGFyYW0sXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlOiBhbHRlcm5hdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQ29udGludWVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZURlYnVnZ2VyU3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5EZWJ1Z2dlclN0YXRlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVEb1doaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAoYm9keSwgdGVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRG9XaGlsZVN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHRlc3Q6IHRlc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkVtcHR5U3RhdGVtZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRm9yU3RhdGVtZW50OiBmdW5jdGlvbiAoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Gb3JTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRm9ySW5TdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBlYWNoOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVGb3JPZlN0YXRlbWVudDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Gb3JPZlN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSwgcmVzdCwgZ2VuZXJhdG9yLCBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luYywgcmV0dXJuVHlwZSwgdHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHZhciBmdW5EZWNsID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICByZXN0OiByZXN0LFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZTogcmV0dXJuVHlwZSxcbiAgICAgICAgICAgICAgICB0eXBlUGFyYW1ldGVyczogdHlwZVBhcmFtZXRlcnNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgZnVuRGVjbC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5EZWNsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCByZXN0LCBnZW5lcmF0b3IsIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQXN5bmMsIHJldHVyblR5cGUsIHR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB2YXIgZnVuRXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICByZXN0OiByZXN0LFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZTogcmV0dXJuVHlwZSxcbiAgICAgICAgICAgICAgICB0eXBlUGFyYW1ldGVyczogdHlwZVBhcmFtZXRlcnNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgZnVuRXhwci5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5FeHByO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUlkZW50aWZpZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgLy8gT25seSBoZXJlIHRvIGluaXRpYWxpemUgdGhlIHNoYXBlIG9mIHRoZSBvYmplY3QgdG8gZW5zdXJlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgJ3R5cGVBbm5vdGF0aW9uJyBrZXkgaXMgb3JkZXJlZCBiZWZvcmUgb3RoZXJzIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBhcmUgYWRkZWQgbGF0ZXIgKGxpa2UgJ2xvYycgYW5kICdyYW5nZScpLiBUaGlzIGp1c3QgaGVscHNcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZSBzaGFwZSBvZiBJZGVudGlmaWVyIG5vZGVzIGNvbnNpc3RlbnQgd2l0aCBldmVyeXRoaW5nXG4gICAgICAgICAgICAgICAgLy8gZWxzZS5cbiAgICAgICAgICAgICAgICB0eXBlQW5ub3RhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVHlwZUFubm90YXRpb246IGZ1bmN0aW9uICh0eXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVHlwZUFubm90YXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZUFubm90YXRpb246IHR5cGVBbm5vdGF0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVR5cGVDYXN0OiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgdHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlR5cGVDYXN0RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uOiB0eXBlQW5ub3RhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVGdW5jdGlvblR5cGVBbm5vdGF0aW9uOiBmdW5jdGlvbiAocGFyYW1zLCByZXR1cm5UeXBlLCByZXN0LCB0eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRnVuY3Rpb25UeXBlQW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlOiByZXR1cm5UeXBlLFxuICAgICAgICAgICAgICAgIHJlc3Q6IHJlc3QsXG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUZ1bmN0aW9uVHlwZVBhcmFtOiBmdW5jdGlvbiAobmFtZSwgdHlwZUFubm90YXRpb24sIG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5GdW5jdGlvblR5cGVQYXJhbSxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uOiB0eXBlQW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogb3B0aW9uYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTnVsbGFibGVUeXBlQW5ub3RhdGlvbjogZnVuY3Rpb24gKHR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OdWxsYWJsZVR5cGVBbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uOiB0eXBlQW5ub3RhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVBcnJheVR5cGVBbm5vdGF0aW9uOiBmdW5jdGlvbiAoZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkFycmF5VHlwZUFubm90YXRpb24sXG4gICAgICAgICAgICAgICAgZWxlbWVudFR5cGU6IGVsZW1lbnRUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUdlbmVyaWNUeXBlQW5ub3RhdGlvbjogZnVuY3Rpb24gKGlkLCB0eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguR2VuZXJpY1R5cGVBbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlUGFyYW1ldGVyczogdHlwZVBhcmFtZXRlcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUXVhbGlmaWVkVHlwZUlkZW50aWZpZXI6IGZ1bmN0aW9uIChxdWFsaWZpY2F0aW9uLCBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgcXVhbGlmaWNhdGlvbjogcXVhbGlmaWNhdGlvbixcbiAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb246IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uLFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUFueVR5cGVBbm5vdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5BbnlUeXBlQW5ub3RhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCb29sZWFuVHlwZUFubm90YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJvb2xlYW5UeXBlQW5ub3RhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVOdW1iZXJUeXBlQW5ub3RhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTnVtYmVyVHlwZUFubm90YXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlU3RyaW5nVHlwZUFubm90YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlN0cmluZ1R5cGVBbm5vdGF0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbjogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5TdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJhdzogc291cmNlLnNsaWNlKHRva2VuLnJhbmdlWzBdLCB0b2tlbi5yYW5nZVsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVm9pZFR5cGVBbm5vdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Wb2lkVHlwZUFubm90YXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVHlwZW9mVHlwZUFubm90YXRpb246IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVHlwZW9mVHlwZUFubm90YXRpb24sXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVR1cGxlVHlwZUFubm90YXRpb246IGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVHVwbGVUeXBlQW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlczogdHlwZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlT2JqZWN0VHlwZUFubm90YXRpb246IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBpbmRleGVycywgY2FsbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk9iamVjdFR5cGVBbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgaW5kZXhlcnM6IGluZGV4ZXJzLFxuICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzOiBjYWxsUHJvcGVydGllc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVPYmplY3RUeXBlSW5kZXhlcjogZnVuY3Rpb24gKGlkLCBrZXksIHZhbHVlLCBpc1N0YXRpYykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguT2JqZWN0VHlwZUluZGV4ZXIsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBzdGF0aWM6IGlzU3RhdGljXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZU9iamVjdFR5cGVDYWxsUHJvcGVydHk6IGZ1bmN0aW9uICh2YWx1ZSwgaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk9iamVjdFR5cGVDYWxsUHJvcGVydHksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHN0YXRpYzogaXNTdGF0aWNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlT2JqZWN0VHlwZVByb3BlcnR5OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9uYWwsIGlzU3RhdGljKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5PYmplY3RUeXBlUHJvcGVydHksXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICBzdGF0aWM6IGlzU3RhdGljXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb246IGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVW5pb25UeXBlQW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlczogdHlwZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb246IGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZXM6IHR5cGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVR5cGVBbGlhczogZnVuY3Rpb24gKGlkLCB0eXBlUGFyYW1ldGVycywgcmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlR5cGVBbGlhcyxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVJbnRlcmZhY2U6IGZ1bmN0aW9uIChpZCwgdHlwZVBhcmFtZXRlcnMsIGJvZHksIGV4dGVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgZXh0ZW5kczogZXh0ZW5kZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSW50ZXJmYWNlRXh0ZW5kczogZnVuY3Rpb24gKGlkLCB0eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSW50ZXJmYWNlRXh0ZW5kcyxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZURlY2xhcmVGdW5jdGlvbjogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5EZWNsYXJlRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZURlY2xhcmVWYXJpYWJsZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5EZWNsYXJlVmFyaWFibGUsXG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZURlY2xhcmVNb2R1bGU6IGZ1bmN0aW9uIChpZCwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRGVjbGFyZU1vZHVsZSxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVKU1hBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSlNYQXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlIHx8IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSlNYU3ByZWFkQXR0cmlidXRlOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkpTWFNwcmVhZEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSlNYSWRlbnRpZmllcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkpTWElkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVKU1hOYW1lc3BhY2VkTmFtZTogZnVuY3Rpb24gKG5hbWVzcGFjZSwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSlNYTmFtZXNwYWNlZE5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVKU1hNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSlNYTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSlNYRWxlbWVudDogZnVuY3Rpb24gKG9wZW5pbmdFbGVtZW50LCBjbG9zaW5nRWxlbWVudCwgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkpTWEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgb3BlbmluZ0VsZW1lbnQ6IG9wZW5pbmdFbGVtZW50LFxuICAgICAgICAgICAgICAgIGNsb3NpbmdFbGVtZW50OiBjbG9zaW5nRWxlbWVudCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSlNYRW1wdHlFeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5KU1hFbXB0eUV4cHJlc3Npb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkpTWEV4cHJlc3Npb25Db250YWluZXIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVKU1hPcGVuaW5nRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGF0dHJpYnV0ZXMsIHNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5KU1hPcGVuaW5nRWxlbWVudCxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHNlbGZDbG9zaW5nOiBzZWxmQ2xvc2luZyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUpTWENsb3NpbmdFbGVtZW50OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSlNYQ2xvc2luZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVJZlN0YXRlbWVudDogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWZTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgdGVzdDogdGVzdCxcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LFxuICAgICAgICAgICAgICAgIGFsdGVybmF0ZTogYWx0ZXJuYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUxhYmVsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTGFiZWxlZFN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMaXRlcmFsOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJhdzogc291cmNlLnNsaWNlKHRva2VuLnJhbmdlWzBdLCB0b2tlbi5yYW5nZVsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFjY2Vzc29yLCBvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBhY2Nlc3NvciA9PT0gJ1snLFxuICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVOZXdFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGNhbGxlZTogY2FsbGVlLFxuICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBhcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5PYmplY3RFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlVwZGF0ZUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudCxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVByb2dyYW06IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Qcm9ncmFtLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUHJvcGVydHk6IGZ1bmN0aW9uIChraW5kLCBrZXksIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHNob3J0aGFuZDogc2hvcnRoYW5kLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUmV0dXJuU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByZXNzaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBleHByZXNzaW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVTd2l0Y2hDYXNlOiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU3dpdGNoQ2FzZSxcbiAgICAgICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlU3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAoZGlzY3JpbWluYW50LCBjYXNlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU3dpdGNoU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGRpc2NyaW1pbmFudDogZGlzY3JpbWluYW50LFxuICAgICAgICAgICAgICAgIGNhc2VzOiBjYXNlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVGhpc0V4cHJlc3Npb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVGhyb3dTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRyeVN0YXRlbWVudDogZnVuY3Rpb24gKGJsb2NrLCBndWFyZGVkSGFuZGxlcnMsIGhhbmRsZXJzLCBmaW5hbGl6ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlRyeVN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBibG9jazogYmxvY2ssXG4gICAgICAgICAgICAgICAgZ3VhcmRlZEhhbmRsZXJzOiBndWFyZGVkSGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgaGFuZGxlcnM6IGhhbmRsZXJzLFxuICAgICAgICAgICAgICAgIGZpbmFsaXplcjogZmluYWxpemVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnKysnIHx8IG9wZXJhdG9yID09PSAnLS0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlVwZGF0ZUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uIChkZWNsYXJhdGlvbnMsIGtpbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBkZWNsYXJhdGlvbnMsXG4gICAgICAgICAgICAgICAga2luZDoga2luZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChpZCwgaW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBpbml0OiBpbml0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAodGVzdCwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguV2hpbGVTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgdGVzdDogdGVzdCxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVdpdGhTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChvYmplY3QsIGJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LldpdGhTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUZW1wbGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGFpbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVGVtcGxhdGVFbGVtZW50LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB0YWlsOiB0YWlsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbDogZnVuY3Rpb24gKHF1YXNpcywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlRlbXBsYXRlTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICBxdWFzaXM6IHF1YXNpcyxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uczogZXhwcmVzc2lvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlU3ByZWFkRWxlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5TcHJlYWRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVTcHJlYWRQcm9wZXJ0eTogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5TcHJlYWRQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAodGFnLCBxdWFzaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgICAgIHF1YXNpOiBxdWFzaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKHBhcmFtcywgZGVmYXVsdHMsIGJvZHksIHJlc3QsIGV4cHJlc3Npb24sIGlzQXN5bmMpIHtcbiAgICAgICAgICAgIHZhciBhcnJvd0V4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHJlc3Q6IHJlc3QsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICAgICAgICAgIGFycm93RXhwci5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnJvd0V4cHI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTWV0aG9kRGVmaW5pdGlvbjogZnVuY3Rpb24gKHByb3BlcnR5VHlwZSwga2luZCwga2V5LCB2YWx1ZSwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgJ3N0YXRpYyc6IHByb3BlcnR5VHlwZSA9PT0gQ2xhc3NQcm9wZXJ0eVR5cGUuc3RhdGljLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVDbGFzc1Byb3BlcnR5OiBmdW5jdGlvbiAoa2V5LCB0eXBlQW5ub3RhdGlvbiwgY29tcHV0ZWQsIGlzU3RhdGljKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DbGFzc1Byb3BlcnR5LFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uOiB0eXBlQW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgICAgICAgc3RhdGljOiBpc1N0YXRpY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVDbGFzc0JvZHk6IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DbGFzc0JvZHksXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVDbGFzc0ltcGxlbWVudHM6IGZ1bmN0aW9uIChpZCwgdHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNsYXNzSW1wbGVtZW50cyxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUNsYXNzRXhwcmVzc2lvbjogZnVuY3Rpb24gKGlkLCBzdXBlckNsYXNzLCBib2R5LCB0eXBlUGFyYW1ldGVycywgc3VwZXJUeXBlUGFyYW1ldGVycywgaW1wbGVtZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNsYXNzRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgc3VwZXJDbGFzczogc3VwZXJDbGFzcyxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzOiB0eXBlUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdXBlclR5cGVQYXJhbWV0ZXJzOiBzdXBlclR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGltcGxlbWVudHM6IGltcGxlbWVudGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUNsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSwgdHlwZVBhcmFtZXRlcnMsIHN1cGVyVHlwZVBhcmFtZXRlcnMsIGltcGxlbWVudGVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DbGFzc0RlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBzdXBlckNsYXNzOiBzdXBlckNsYXNzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHN1cGVyVHlwZVBhcmFtZXRlcnM6IHN1cGVyVHlwZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgaW1wbGVtZW50czogaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1vZHVsZVNwZWNpZmllcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICAgICAgICAgICAgcmF3OiBzb3VyY2Uuc2xpY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwb3J0U3BlY2lmaWVyLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUV4cG9ydEJhdGNoU3BlY2lmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FeHBvcnRCYXRjaFNwZWNpZmllclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkltcG9ydERlZmF1bHRTcGVjaWZpZXIsXG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIsXG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUV4cG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoaXNEZWZhdWx0LCBkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc3JjKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FeHBvcnREZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgICAnZGVmYXVsdCc6ICEhaXNEZWZhdWx0LFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uOiBkZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzOiBzcGVjaWZpZXJzLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogc3JjXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JbXBvcnRTcGVjaWZpZXIsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSW1wb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChzcGVjaWZpZXJzLCBzcmMsIGlzVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSW1wb3J0RGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyczogc3BlY2lmaWVycyxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNyYyxcbiAgICAgICAgICAgICAgICBpc1R5cGU6IGlzVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVZaWVsZEV4cHJlc3Npb246IGZ1bmN0aW9uIChhcmd1bWVudCwgZGxnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5ZaWVsZEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlOiBkbGdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQXdhaXRFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkF3YWl0RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChmaWx0ZXIsIGJsb2NrcywgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgYmxvY2tzOiBibG9ja3MsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHBlZWtMaW5lVGVybWluYXRvcigpIHtcbiAgICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQsIGZvdW5kO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIGZvdW5kID0gbGluZU51bWJlciAhPT0gbGluZTtcbiAgICAgICAgaW5kZXggPSBwb3M7XG4gICAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKHRva2VuLCBtZXNzYWdlRm9ybWF0KSB7XG4gICAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgdG9rZW4ubGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgICAgZXJyb3IuaW5kZXggPSB0b2tlbi5yYW5nZVswXTtcbiAgICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICAgICAgZXJyb3IuY29sdW1uID0gdG9rZW4ucmFuZ2VbMF0gLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIGxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICAgIGVycm9yLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gbXNnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yVG9sZXJhbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxuXG4gICAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLkpTWFRleHQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUZW1wbGF0ZSwgdG9rZW4udmFsdWUucmF3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJvb2xlYW5MaXRlcmFsLCBOdWxsTGl0ZXJhbCwgb3IgUHVuY3R1YXRvci5cbiAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCwgY29udGV4dHVhbCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IChjb250ZXh0dWFsID8gVG9rZW4uSWRlbnRpZmllciA6IFRva2VuLktleXdvcmQpIHx8XG4gICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBjb250ZXh0dWFsIGtleXdvcmQuXG4gICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cbiAgICBmdW5jdGlvbiBleHBlY3RDb250ZXh0dWFsS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBleHBlY3RLZXl3b3JkKGtleXdvcmQsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gICAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkLCBjb250ZXh0dWFsKSB7XG4gICAgICAgIHZhciBleHBlY3RlZFR5cGUgPSBjb250ZXh0dWFsID8gVG9rZW4uSWRlbnRpZmllciA6IFRva2VuLktleXdvcmQ7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gZXhwZWN0ZWRUeXBlICYmIGxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgY29udGV4dHVhbCBrZXl3b3JkXG5cbiAgICBmdW5jdGlvbiBtYXRjaENvbnRleHR1YWxLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoS2V5d29yZChrZXl3b3JkLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBpcyBhbiBhc3NpZ25tZW50IG9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBtYXRjaEFzc2lnbigpIHtcbiAgICAgICAgdmFyIG9wO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9wID0gbG9va2FoZWFkLnZhbHVlO1xuICAgICAgICByZXR1cm4gb3AgPT09ICc9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICcqPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnLz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJyU9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICcrPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnLT0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJzw8PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj49JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc+Pj49JyB8fFxuICAgICAgICAgICAgb3AgPT09ICcmPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnXj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ3w9JztcbiAgICB9XG5cbiAgICAvLyBOb3RlIHRoYXQgJ3lpZWxkJyBpcyB0cmVhdGVkIGFzIGEga2V5d29yZCBpbiBzdHJpY3QgbW9kZSwgYnV0IGFcbiAgICAvLyBjb250ZXh0dWFsIGtleXdvcmQgKGlkZW50aWZpZXIpIGluIG5vbi1zdHJpY3QgbW9kZSwgc28gd2UgbmVlZCB0b1xuICAgIC8vIHVzZSBtYXRjaEtleXdvcmQoJ3lpZWxkJywgZmFsc2UpIGFuZCBtYXRjaEtleXdvcmQoJ3lpZWxkJywgdHJ1ZSlcbiAgICAvLyAoaS5lLiBtYXRjaENvbnRleHR1YWxLZXl3b3JkKSBhcHByb3ByaWF0ZWx5LlxuICAgIGZ1bmN0aW9uIG1hdGNoWWllbGQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS55aWVsZEFsbG93ZWQgJiYgbWF0Y2hLZXl3b3JkKCd5aWVsZCcsICFzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoQXN5bmMoKSB7XG4gICAgICAgIHZhciBiYWNrdHJhY2tUb2tlbiA9IGxvb2thaGVhZCwgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpKSB7XG4gICAgICAgICAgICBsZXgoKTsgLy8gTWFrZSBzdXJlIHBlZWtMaW5lVGVybWluYXRvcigpIHN0YXJ0cyBhZnRlciAnYXN5bmMnLlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFwZWVrTGluZVRlcm1pbmF0b3IoKTtcbiAgICAgICAgICAgIHJld2luZChiYWNrdHJhY2tUb2tlbik7IC8vIFJldmVydCB0aGUgbGV4KCkuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEF3YWl0KCkge1xuICAgICAgICByZXR1cm4gc3RhdGUuYXdhaXRBbGxvd2VkICYmIG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2F3YWl0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgdmFyIGxpbmUsIG9sZEluZGV4ID0gaW5kZXgsIG9sZExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgb2xkTGluZVN0YXJ0ID0gbGluZVN0YXJ0LCBvbGRMb29rYWhlYWQgPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChjaGFyICM1OSkuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDU5KSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBpZiAobGluZU51bWJlciAhPT0gbGluZSkge1xuICAgICAgICAgICAgaW5kZXggPSBvbGRJbmRleDtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBvbGRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgbGluZVN0YXJ0ID0gb2xkTGluZVN0YXJ0O1xuICAgICAgICAgICAgbG9va2FoZWFkID0gb2xkTG9va2FoZWFkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YgJiYgIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgcHJvdmlkZWQgZXhwcmVzc2lvbiBpcyBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXG5cbiAgICBmdW5jdGlvbiBpc0xlZnRIYW5kU2lkZShleHByKSB7XG4gICAgICAgIHJldHVybiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyIHx8IGV4cHIudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBc3NpZ25hYmxlTGVmdEhhbmRTaWRlKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVmdEhhbmRTaWRlKGV4cHIpIHx8IGV4cHIudHlwZSA9PT0gU3ludGF4Lk9iamVjdFBhdHRlcm4gfHwgZXhwci50eXBlID09PSBTeW50YXguQXJyYXlQYXR0ZXJuO1xuICAgIH1cblxuICAgIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXSwgYmxvY2tzID0gW10sIGZpbHRlciA9IG51bGwsIHRtcCwgcG9zc2libGVjb21wcmVoZW5zaW9uID0gdHJ1ZSxcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdCgnWycpO1xuICAgICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudmFsdWUgPT09ICdmb3InICYmXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb3NzaWJsZWNvbXByZWhlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuQ29tcHJlaGVuc2lvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2hLZXl3b3JkKCdmb3InKTtcbiAgICAgICAgICAgICAgICB0bXAgPSBwYXJzZUZvclN0YXRlbWVudCh7aWdub3JlQm9keTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIHRtcC5vZiA9IHRtcC50eXBlID09PSBTeW50YXguRm9yT2ZTdGF0ZW1lbnQ7XG4gICAgICAgICAgICAgICAgdG1wLnR5cGUgPSBTeW50YXguQ29tcHJlaGVuc2lvbkJsb2NrO1xuICAgICAgICAgICAgICAgIGlmICh0bXAubGVmdC5raW5kKSB7IC8vIGNhbid0IGJlIGxldCBvciBjb25zdFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5Db21wcmVoZW5zaW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9ja3MucHVzaCh0bXApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb29rYWhlYWQudmFsdWUgPT09ICdpZicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb3NzaWJsZWNvbXByZWhlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuQ29tcHJlaGVuc2lvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0S2V5d29yZCgnaWYnKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkLnZhbHVlID09PSAnLCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICAgICAgcG9zc2libGVjb21wcmVoZW5zaW9uID0gZmFsc2U7IC8vIG5vIGxvbmdlciBhbGxvd2VkLlxuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcCA9IHBhcnNlU3ByZWFkT3JBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godG1wKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wICYmIHRtcC50eXBlID09PSBTeW50YXguU3ByZWFkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkVsZW1lbnRBZnRlclNwcmVhZEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghKG1hdGNoKCddJykgfHwgbWF0Y2hLZXl3b3JkKCdmb3InKSB8fCBtYXRjaEtleXdvcmQoJ2lmJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpOyAvLyB0aGlzIGxleGVzLlxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZWNvbXByZWhlbnNpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ10nKTtcblxuICAgICAgICBpZiAoZmlsdGVyICYmICFibG9ja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5Db21wcmVoZW5zaW9uUmVxdWlyZXNCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkNvbXByZWhlbnNpb25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVDb21wcmVoZW5zaW9uRXhwcmVzc2lvbihmaWx0ZXIsIGJsb2NrcywgZWxlbWVudHNbMF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpKTtcbiAgICB9XG5cbiAgICAvLyAxMS4xLjUgT2JqZWN0IEluaXRpYWxpc2VyXG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5RnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIHByZXZpb3VzWWllbGRBbGxvd2VkLCBwcmV2aW91c0F3YWl0QWxsb3dlZCxcbiAgICAgICAgICAgIHBhcmFtcywgZGVmYXVsdHMsIGJvZHksIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBwcmV2aW91c1lpZWxkQWxsb3dlZCA9IHN0YXRlLnlpZWxkQWxsb3dlZDtcbiAgICAgICAgc3RhdGUueWllbGRBbGxvd2VkID0gb3B0aW9ucy5nZW5lcmF0b3I7XG4gICAgICAgIHByZXZpb3VzQXdhaXRBbGxvd2VkID0gc3RhdGUuYXdhaXRBbGxvd2VkO1xuICAgICAgICBzdGF0ZS5hd2FpdEFsbG93ZWQgPSBvcHRpb25zLmFzeW5jO1xuICAgICAgICBwYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCBbXTtcbiAgICAgICAgZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzIHx8IFtdO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZUNvbmNpc2VCb2R5KCk7XG4gICAgICAgIGlmIChvcHRpb25zLm5hbWUgJiYgc3RyaWN0ICYmIGlzUmVzdHJpY3RlZFdvcmQocGFyYW1zWzBdLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQob3B0aW9ucy5uYW1lLCBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICBzdGF0ZS55aWVsZEFsbG93ZWQgPSBwcmV2aW91c1lpZWxkQWxsb3dlZDtcbiAgICAgICAgc3RhdGUuYXdhaXRBbGxvd2VkID0gcHJldmlvdXNBd2FpdEFsbG93ZWQ7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIG9wdGlvbnMucmVzdCB8fCBudWxsLFxuICAgICAgICAgICAgb3B0aW9ucy5nZW5lcmF0b3IsXG4gICAgICAgICAgICBib2R5LnR5cGUgIT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCxcbiAgICAgICAgICAgIG9wdGlvbnMuYXN5bmMsXG4gICAgICAgICAgICBvcHRpb25zLnJldHVyblR5cGUsXG4gICAgICAgICAgICBvcHRpb25zLnR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICkpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0LCB0bXAsIG1ldGhvZDtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcblxuICAgICAgICB0bXAgPSBwYXJzZVBhcmFtcygpO1xuXG4gICAgICAgIGlmICh0bXAuc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0bXAuc3RyaWN0ZWQsIHRtcC5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1ldGhvZCA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbih7XG4gICAgICAgICAgICBwYXJhbXM6IHRtcC5wYXJhbXMsXG4gICAgICAgICAgICBkZWZhdWx0czogdG1wLmRlZmF1bHRzLFxuICAgICAgICAgICAgcmVzdDogdG1wLnJlc3QsXG4gICAgICAgICAgICBnZW5lcmF0b3I6IG9wdGlvbnMuZ2VuZXJhdG9yLFxuICAgICAgICAgICAgYXN5bmM6IG9wdGlvbnMuYXN5bmMsXG4gICAgICAgICAgICByZXR1cm5UeXBlOiB0bXAucmV0dXJuVHlwZSxcbiAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzOiBvcHRpb25zLnR5cGVQYXJhbWV0ZXJzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksXG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpLFxuICAgICAgICAgICAgcHJvcGVydHlLZXksXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBmcm9tIHBhcnNlT2JqZWN0UHJvcGVydHkoKSwgd2hlcmVcbiAgICAgICAgLy8gRU9GIGFuZCBQdW5jdHVhdG9yIHRva2VucyBhcmUgYWxyZWFkeSBmaWx0ZXJlZCBvdXQuXG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVMaXRlcmFsKHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAvLyBGb3IgY29tcHV0ZWQgcHJvcGVydGllcyB3ZSBzaG91bGQgc2tpcCB0aGUgWyBhbmQgXSwgYW5kXG4gICAgICAgICAgICAvLyBjYXB0dXJlIGluIG1hcmtlciBvbmx5IHRoZSBhc3NpZ25tZW50IGV4cHJlc3Npb24gaXRzZWxmLlxuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1hcmtlckFwcGx5KG1hcmtlciwgcHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgZXhwZWN0KCddJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHkoKSB7XG4gICAgICAgIHZhciB0b2tlbiwga2V5LCBpZCwgcGFyYW0sIGNvbXB1dGVkLFxuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksIHJldHVyblR5cGUsIHR5cGVQYXJhbWV0ZXJzO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBjb21wdXRlZCA9ICh0b2tlbi52YWx1ZSA9PT0gJ1snICYmIHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8IGNvbXB1dGVkIHx8IG1hdGNoQXN5bmMoKSkge1xuICAgICAgICAgICAgaWQgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoKCcoJykgfHwgbWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnPCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmNyZWF0ZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2luaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzOiB0eXBlUGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvcGVydHkgQXNzaWdubWVudDogR2V0dGVyIGFuZCBTZXR0ZXIuXG5cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZCA9IChsb29rYWhlYWQudmFsdWUgPT09ICdbJyk7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IHBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlUHJvcGVydHlGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZTogcmV0dXJuVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZCA9IChsb29rYWhlYWQudmFsdWUgPT09ICdbJyk7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICAgICAgcGFyYW0gPSBbIHBhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcigpIF07XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IHBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlUHJvcGVydHlGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlOiByZXR1cm5UeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnYXN5bmMnKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSAobG9va2FoZWFkLnZhbHVlID09PSAnWycpO1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnPCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlZCBwcm9wZXJ0aWVzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBmdWxsIG5vdGF0aW9uLlxuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkoXG4gICAgICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlLmNyZWF0ZVByb3BlcnR5KCdpbml0JywgaWQsIGlkLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRiB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcqJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGNvbXB1dGVkID0gKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ1snKTtcblxuICAgICAgICAgICAgaWQgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCgnPCcpKSB7XG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAnaW5pdCcsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgcGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlUGFyYW1ldGVyczogdHlwZVBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgIGlmIChtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVByb3BlcnR5KCdpbml0Jywga2V5LCBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCksIGZhbHNlLCBmYWxzZSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2goJygnKSB8fCBtYXRjaCgnPCcpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgICdpbml0JyxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgcGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxleCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFNwcmVhZFByb3BlcnR5KCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgIGV4cGVjdCgnLi4uJyk7XG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVNwcmVhZFByb3BlcnR5KHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZpZWxkTmFtZShrZXkpIHtcbiAgICAgICAgdmFyIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAoa2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKGtleS52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXSwgcHJvcGVydHksIG5hbWUsIGtpbmQsIHN0b3JlZEtpbmQsIG1hcCA9IG5ldyBTdHJpbmdNYXAoKSxcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCB0b1N0cmluZyA9IFN0cmluZztcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLi4uJykpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlT2JqZWN0U3ByZWFkUHJvcGVydHkoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU9iamVjdFByb3BlcnR5KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wZXJ0eS5rZXkubmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2luZCA9IChwcm9wZXJ0eS5raW5kID09PSAnaW5pdCcpID8gUHJvcGVydHlLaW5kLkRhdGEgOiAocHJvcGVydHkua2luZCA9PT0gJ2dldCcpID8gUHJvcGVydHlLaW5kLkdldCA6IFByb3BlcnR5S2luZC5TZXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobWFwLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWRLaW5kID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JlZEtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgIT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcmVkS2luZCAmIGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yR2V0U2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHN0b3JlZEtpbmQgfCBraW5kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KG5hbWUsIGtpbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlRWxlbWVudChvcHRpb24pIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLFxuICAgICAgICAgICAgdG9rZW4gPSBzY2FuVGVtcGxhdGVFbGVtZW50KG9wdGlvbik7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlVGVtcGxhdGVFbGVtZW50KHsgcmF3OiB0b2tlbi52YWx1ZS5yYXcsIGNvb2tlZDogdG9rZW4udmFsdWUuY29va2VkIH0sIHRva2VuLnRhaWwpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIHF1YXNpLCBxdWFzaXMsIGV4cHJlc3Npb25zLCBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBxdWFzaSA9IHBhcnNlVGVtcGxhdGVFbGVtZW50KHsgaGVhZDogdHJ1ZSB9KTtcbiAgICAgICAgcXVhc2lzID0gWyBxdWFzaSBdO1xuICAgICAgICBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgICAgIHdoaWxlICghcXVhc2kudGFpbCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICBxdWFzaSA9IHBhcnNlVGVtcGxhdGVFbGVtZW50KHsgaGVhZDogZmFsc2UgfSk7XG4gICAgICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVUZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucykpO1xuICAgIH1cblxuICAgIC8vIDExLjEuNiBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgbWFya2VyLCB0eXBlQW5ub3RhdGlvbjtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICArK3N0YXRlLnBhcmVudGhlc2l6ZWRDb3VudDtcblxuICAgICAgICBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uID0gcGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgZXhwciA9IG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlVHlwZUNhc3QoXG4gICAgICAgICAgICAgICAgZXhwcixcbiAgICAgICAgICAgICAgICB0eXBlQW5ub3RhdGlvblxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEFzeW5jRnVuY0V4cHJPckRlY2woKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICBpZiAobWF0Y2hBc3luYygpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDIoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkICYmIHRva2VuLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTEuMSBQcmltYXJ5IEV4cHJlc3Npb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyLCB0eXBlLCB0b2tlbiwgZXhwcjtcblxuICAgICAgICB0eXBlID0gbG9va2FoZWFkLnR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSWRlbnRpZmllcihsZXgoKS52YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgbG9va2FoZWFkLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlTGl0ZXJhbChsZXgoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVRoaXNFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnc3VwZXInKSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUlkZW50aWZpZXIoJ3N1cGVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbCkge1xuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlTGl0ZXJhbCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCcvJykgfHwgbWF0Y2goJy89JykpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGV4cHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnPCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VKU1hFbGVtZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgIH1cblxuICAgIC8vIDExLjIgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBhcmc7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhcmcgPSBwYXJzZVNwcmVhZE9yQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLnR5cGUgPT09IFN5bnRheC5TcHJlYWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkVsZW1lbnRBZnRlclNwcmVhZEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTcHJlYWRPckFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICAgICAgICBpZiAobWF0Y2goJy4uLicpKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVNwcmVhZEVsZW1lbnQocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKSxcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUlkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICBleHBlY3QoJy4nKTtcblxuICAgICAgICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb21wdXRlZE1lbWJlcigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGNhbGxlZSwgYXJncywgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnbmV3Jyk7XG4gICAgICAgIGNhbGxlZSA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpO1xuICAgICAgICBhcmdzID0gbWF0Y2goJygnKSA/IHBhcnNlQXJndW1lbnRzKCkgOiBbXTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVOZXdFeHByZXNzaW9uKGNhbGxlZSwgYXJncykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpIHtcbiAgICAgICAgdmFyIGV4cHIsIGFyZ3MsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cHIgPSBtYXRjaEtleXdvcmQoJ25ldycpID8gcGFyc2VOZXdFeHByZXNzaW9uKCkgOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcuJykgfHwgbWF0Y2goJ1snKSB8fCBtYXRjaCgnKCcpIHx8IGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gcGFyc2VBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcGFyc2VDb21wdXRlZE1lbWJlcigpKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcGFyc2VOb25Db21wdXRlZE1lbWJlcigpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBleHByID0gbWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbigpIDogcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnLicpIHx8IG1hdGNoKCdbJykgfHwgbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlRlbXBsYXRlKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZU1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwYXJzZUNvbXB1dGVkTWVtYmVyKCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZU1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHBhcnNlVGVtcGxhdGVMaXRlcmFsKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLFxuICAgICAgICAgICAgZXhwciA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpLFxuICAgICAgICAgICAgdG9rZW47XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpICYmICFwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgLy8gMTEuMy4xLCAxMS4zLjJcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdExIU1Bvc3RmaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVQb3N0Zml4RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyLCB0b2tlbiwgZXhwcjtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgLy8gMTEuNC40LCAxMS40LjVcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdExIU1ByZWZpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNMZWZ0SGFuZFNpZGUoZXhwcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgZXhwciA9IG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIub3BlcmF0b3IgPT09ICdkZWxldGUnICYmIGV4cHIuYXJndW1lbnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdERlbGV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgYWxsb3dJbikge1xuICAgICAgICB2YXIgcHJlYyA9IDA7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgIHByZWMgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgcHJlYyA9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgIHByZWMgPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICBwcmVjID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcHJlYyA9IDU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgIHByZWMgPSA2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgY2FzZSAnaW5zdGFuY2VvZic6XG4gICAgICAgICAgICBwcmVjID0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICAgIHByZWMgPSBhbGxvd0luID8gNyA6IDA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc8PCc6XG4gICAgICAgIGNhc2UgJz4+JzpcbiAgICAgICAgY2FzZSAnPj4+JzpcbiAgICAgICAgICAgIHByZWMgPSA4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgcHJlYyA9IDk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcHJlYyA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZWM7XG4gICAgfVxuXG4gICAgLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcbiAgICAvLyAxMS42IEFkZGl0aXZlIE9wZXJhdG9yc1xuICAgIC8vIDExLjcgQml0d2lzZSBTaGlmdCBPcGVyYXRvcnNcbiAgICAvLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG4gICAgLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcbiAgICAvLyAxMS4xMCBCaW5hcnkgQml0d2lzZSBPcGVyYXRvcnNcbiAgICAvLyAxMS4xMSBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHRva2VuLCBwcmVjLCBwcmV2aW91c0FsbG93SW4sIHN0YWNrLCByaWdodCwgb3BlcmF0b3IsIGxlZnQsIGksXG4gICAgICAgICAgICBtYXJrZXIsIG1hcmtlcnM7XG5cbiAgICAgICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcbiAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG5cbiAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgIGxlZnQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBwcmVjID0gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgcHJldmlvdXNBbGxvd0luKTtcbiAgICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICBsZXgoKTtcblxuICAgICAgICBtYXJrZXJzID0gW21hcmtlciwgbWFya2VyQ3JlYXRlKCldO1xuICAgICAgICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgc3RhY2sgPSBbbGVmdCwgdG9rZW4sIHJpZ2h0XTtcblxuICAgICAgICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCwgcHJldmlvdXNBbGxvd0luKSkgPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cbiAgICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gc3RhY2sucG9wKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSBtYXJrZXJzLnBvcCgpO1xuICAgICAgICAgICAgICAgIG1hcmtlckFwcGx5KG1hcmtlciwgZXhwcik7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hpZnQuXG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIG1hcmtlcnMucHVzaChtYXJrZXJDcmVhdGUoKSk7XG4gICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gICAgICAgIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBleHByID0gc3RhY2tbaV07XG4gICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xuICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgbWFya2VyID0gbWFya2Vycy5wb3AoKTtcbiAgICAgICAgICAgIG1hcmtlckFwcGx5KG1hcmtlciwgZXhwcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcbiAgICAgICAgZXhwciA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGV4cHIgPSBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjEzIEFzc2lnbm1lbnQgT3BlcmF0b3JzXG5cbiAgICAvLyAxMi4xNC41IEFzc2lnbm1lbnRQYXR0ZXJuXG5cbiAgICBmdW5jdGlvbiByZWludGVycHJldEFzQXNzaWdubWVudEJpbmRpbmdQYXR0ZXJuKGV4cHIpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgcHJvcGVydHksIGVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5PYmplY3RQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBleHByLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5LnR5cGUgPT09IFN5bnRheC5TcHJlYWRQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlByb3BlcnR5QWZ0ZXJTcHJlYWRQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVpbnRlcnByZXRBc0Fzc2lnbm1lbnRCaW5kaW5nUGF0dGVybihwcm9wZXJ0eS5hcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5LmtpbmQgIT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVpbnRlcnByZXRBc0Fzc2lnbm1lbnRCaW5kaW5nUGF0dGVybihwcm9wZXJ0eS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LkFycmF5RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgZXhwci50eXBlID0gU3ludGF4LkFycmF5UGF0dGVybjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZXhwci5lbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0QXNBc3NpZ25tZW50QmluZGluZ1BhdHRlcm4oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT09IFN5bnRheC5TcHJlYWRFbGVtZW50KSB7XG4gICAgICAgICAgICByZWludGVycHJldEFzQXNzaWdubWVudEJpbmRpbmdQYXR0ZXJuKGV4cHIuYXJndW1lbnQpO1xuICAgICAgICAgICAgaWYgKGV4cHIuYXJndW1lbnQudHlwZSA9PT0gU3ludGF4Lk9iamVjdFBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5PYmplY3RQYXR0ZXJuQXNTcHJlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChleHByLnR5cGUgIT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIGV4cHIudHlwZSAhPT0gU3ludGF4LkNhbGxFeHByZXNzaW9uICYmIGV4cHIudHlwZSAhPT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEzLjIuMyBCaW5kaW5nUGF0dGVyblxuXG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRBc0Rlc3RydWN0dXJlZFBhcmFtZXRlcihvcHRpb25zLCBleHByKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHByb3BlcnR5LCBlbGVtZW50O1xuXG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFN5bnRheC5PYmplY3RFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBleHByLnR5cGUgPSBTeW50YXguT2JqZWN0UGF0dGVybjtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS50eXBlID09PSBTeW50YXguU3ByZWFkUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5Qcm9wZXJ0eUFmdGVyU3ByZWFkUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0QXNEZXN0cnVjdHVyZWRQYXJhbWV0ZXIob3B0aW9ucywgcHJvcGVydHkuYXJndW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5raW5kICE9PSAnaW5pdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRMSFNJbkZvcm1hbHNMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEFzRGVzdHJ1Y3R1cmVkUGFyYW1ldGVyKG9wdGlvbnMsIHByb3BlcnR5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09PSBTeW50YXguQXJyYXlFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBleHByLnR5cGUgPSBTeW50YXguQXJyYXlQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwci5lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBleHByLmVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0QXNEZXN0cnVjdHVyZWRQYXJhbWV0ZXIob3B0aW9ucywgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlUGFyYW0ob3B0aW9ucywgZXhwciwgZXhwci5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT09IFN5bnRheC5TcHJlYWRFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBCaW5kaW5nUmVzdEVsZW1lbnQgb25seSBhbGxvd3MgQmluZGluZ0lkZW50aWZpZXJcbiAgICAgICAgICAgIGlmIChleHByLmFyZ3VtZW50LnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luRm9ybWFsc0xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBleHByLmFyZ3VtZW50LCBleHByLmFyZ3VtZW50Lm5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luRm9ybWFsc0xpc3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgcGFyYW0sIHBhcmFtcywgZGVmYXVsdHMsIGRlZmF1bHRDb3VudCwgb3B0aW9ucywgcmVzdDtcblxuICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgZGVmYXVsdENvdW50ID0gMDtcbiAgICAgICAgcmVzdCA9IG51bGw7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJhbVNldDogbmV3IFN0cmluZ01hcCgpXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwcmVzc2lvbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHBhcmFtID0gZXhwcmVzc2lvbnNbaV07XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb24gfHwgcGFyYW0udHlwZSA9PT0gU3ludGF4LkFycmF5RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0QXNEZXN0cnVjdHVyZWRQYXJhbWV0ZXIob3B0aW9ucywgcGFyYW0pO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS50eXBlID09PSBTeW50YXguU3ByZWFkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChpID09PSBsZW4gLSAxLCAnSXQgaXMgZ3VhcmFudGVlZCB0aGF0IFNwcmVhZEVsZW1lbnQgaXMgbGFzdCBlbGVtZW50IGJ5IHBhcnNlRXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5hcmd1bWVudC50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JtYWxzTGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0QXNEZXN0cnVjdHVyZWRQYXJhbWV0ZXIob3B0aW9ucywgcGFyYW0uYXJndW1lbnQpO1xuICAgICAgICAgICAgICAgIHJlc3QgPSBwYXJhbS5hcmd1bWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0ubGVmdCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHMucHVzaChwYXJhbS5yaWdodCk7XG4gICAgICAgICAgICAgICAgKytkZWZhdWx0Q291bnQ7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbS5sZWZ0LCBwYXJhbS5sZWZ0Lm5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihcbiAgICAgICAgICAgICAgICBzdHJpY3QgPyBvcHRpb25zLnN0cmljdGVkIDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICAgIHJlc3Q6IHJlc3QsXG4gICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUFycm93RnVuY3Rpb25FeHByZXNzaW9uKG9wdGlvbnMsIG1hcmtlcikge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIHByZXZpb3VzWWllbGRBbGxvd2VkLCBwcmV2aW91c0F3YWl0QWxsb3dlZCwgYm9keTtcblxuICAgICAgICBleHBlY3QoJz0+Jyk7XG5cbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIHByZXZpb3VzWWllbGRBbGxvd2VkID0gc3RhdGUueWllbGRBbGxvd2VkO1xuICAgICAgICBzdGF0ZS55aWVsZEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgcHJldmlvdXNBd2FpdEFsbG93ZWQgPSBzdGF0ZS5hd2FpdEFsbG93ZWQ7XG4gICAgICAgIHN0YXRlLmF3YWl0QWxsb3dlZCA9ICEhb3B0aW9ucy5hc3luYztcbiAgICAgICAgYm9keSA9IHBhcnNlQ29uY2lzZUJvZHkoKTtcblxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgb3B0aW9ucy5zdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KG9wdGlvbnMuc3RyaWN0ZWQsIG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcbiAgICAgICAgc3RhdGUueWllbGRBbGxvd2VkID0gcHJldmlvdXNZaWVsZEFsbG93ZWQ7XG4gICAgICAgIHN0YXRlLmF3YWl0QWxsb3dlZCA9IHByZXZpb3VzQXdhaXRBbGxvd2VkO1xuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUFycm93RnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRzLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIG9wdGlvbnMucmVzdCxcbiAgICAgICAgICAgIGJvZHkudHlwZSAhPT0gU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgISFvcHRpb25zLmFzeW5jXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIGV4cHIsIHRva2VuLCBwYXJhbXMsIG9sZFBhcmVudGhlc2l6ZWRDb3VudCxcbiAgICAgICAgICAgIHN0YXJ0c1dpdGhQYXJlbiA9IGZhbHNlLCBiYWNrdHJhY2tUb2tlbiA9IGxvb2thaGVhZCxcbiAgICAgICAgICAgIHBvc3NpYmx5QXN5bmMgPSBmYWxzZTtcblxuICAgICAgICBpZiAobWF0Y2hZaWVsZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VZaWVsZEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEF3YWl0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUF3YWl0RXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkUGFyZW50aGVzaXplZENvdW50ID0gc3RhdGUucGFyZW50aGVzaXplZENvdW50O1xuXG4gICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaEFzeW5jRnVuY0V4cHJPckRlY2woKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hBc3luYygpKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBiZSBjb21wbGV0ZWx5IHN1cmUgdGhhdCB0aGlzICdhc3luYycgdG9rZW4gaXNcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGEgY29udGV4dHVhbCBrZXl3b3JkIG1vZGlmeWluZyBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBleHByZXNzaW9uLCBzbyB3ZSBtaWdodCBoYXZlIHRvIHVuLWxleCgpIGl0IGxhdGVyIGJ5XG4gICAgICAgICAgICAvLyBjYWxsaW5nIHJld2luZChiYWNrdHJhY2tUb2tlbikuXG4gICAgICAgICAgICBwb3NzaWJseUFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkMigpO1xuICAgICAgICAgICAgaWYgKCh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlID09PSAnKScpIHx8IHRva2VuLnZhbHVlID09PSAnLi4uJykge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMuYXN5bmMgPSBwb3NzaWJseUFzeW5jO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUFycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgbWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0c1dpdGhQYXJlbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICAvLyBJZiB0aGUgJ2FzeW5jJyBrZXl3b3JkIGlzIG5vdCBmb2xsb3dlZCBieSBhICcoJyBjaGFyYWN0ZXIgb3IgYW5cbiAgICAgICAgLy8gaWRlbnRpZmllciwgdGhlbiBpdCBjYW4ndCBiZSBhbiBhcnJvdyBmdW5jdGlvbiBtb2RpZmllciwgYW5kIHdlXG4gICAgICAgIC8vIHNob3VsZCBpbnRlcnByZXQgaXQgYXMgYSBub3JtYWwgaWRlbnRpZmVyLlxuICAgICAgICBpZiAocG9zc2libHlBc3luYyAmJiAhbWF0Y2goJygnKSAmJiB0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBwb3NzaWJseUFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICByZXdpbmQoYmFja3RyYWNrVG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc9PicpICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBhcmVudGhlc2l6ZWRDb3VudCA9PT0gb2xkUGFyZW50aGVzaXplZENvdW50IHx8XG4gICAgICAgICAgICAgICAgc3RhdGUucGFyZW50aGVzaXplZENvdW50ID09PSAob2xkUGFyZW50aGVzaXplZENvdW50ICsgMSkpKSB7XG4gICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KFsgZXhwciBdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gfHxcbiAgICAgICAgICAgICAgICAgICAgZXhwci50eXBlID09PSBTeW50YXguQXJyYXlFeHByZXNzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9PT0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0c1dpdGhQYXJlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMgPSByZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdChbIGV4cHIgXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KGV4cHIuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hc3luYyA9IHBvc3NpYmx5QXN5bmM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCBtYXJrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCByZXR1cm5lZCBieSBub3csIHRoZW4gdGhlICdhc3luYycga2V5d29yZCB3YXMgbm90XG4gICAgICAgIC8vIGEgZnVuY3Rpb24gbW9kaWZpZXIsIGFuZCB3ZSBzaG91bGQgcmV3aW5kIGFuZCBpbnRlcnByZXQgaXQgYXMgYVxuICAgICAgICAvLyBub3JtYWwgaWRlbnRpZmllci5cbiAgICAgICAgaWYgKHBvc3NpYmx5QXN5bmMpIHtcbiAgICAgICAgICAgIHBvc3NpYmx5QXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIHJld2luZChiYWNrdHJhY2tUb2tlbik7XG4gICAgICAgICAgICBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEFzc2lnbigpKSB7XG4gICAgICAgICAgICAvLyAxMS4xMy4xXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RMSFNBc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRVMubmV4dCBkcmFmIDExLjEzIFJ1bnRpbWUgU2VtYW50aWNzIHN0ZXAgMVxuICAgICAgICAgICAgaWYgKG1hdGNoKCc9JykgJiYgKGV4cHIudHlwZSA9PT0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb24gfHwgZXhwci50eXBlID09PSBTeW50YXguQXJyYXlFeHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0QXNBc3NpZ25tZW50QmluZGluZ1BhdHRlcm4oZXhwcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0xlZnRIYW5kU2lkZShleHByKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHByID0gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihsZXgoKS52YWx1ZSwgZXhwciwgcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyLCBleHByLCBleHByZXNzaW9ucywgc2VxdWVuY2UsIHNwcmVhZEZvdW5kO1xuXG4gICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICBleHByZXNzaW9ucyA9IFsgZXhwciBdO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlU3ByZWFkT3JBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBTeW50YXguU3ByZWFkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBzcHJlYWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuRWxlbWVudEFmdGVyU3ByZWFkRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXF1ZW5jZSA9IG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3ByZWFkRm91bmQgJiYgbG9va2FoZWFkMigpLnZhbHVlICE9PSAnPT4nKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsU3ByZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXF1ZW5jZSB8fCBleHByO1xuICAgIH1cblxuICAgIC8vIDEyLjEgQmxvY2tcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50TGlzdCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSxcbiAgICAgICAgICAgIHN0YXRlbWVudDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2ssIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIGJsb2NrID0gcGFyc2VTdGF0ZW1lbnRMaXN0KCk7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlQmxvY2tTdGF0ZW1lbnQoYmxvY2spKTtcbiAgICB9XG5cbiAgICAvLyAxMi4yIFZhcmlhYmxlIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKSwgcGFyYW1UeXBlcyA9IFtdO1xuXG4gICAgICAgIGV4cGVjdCgnPCcpO1xuICAgICAgICB3aGlsZSAoIW1hdGNoKCc+JykpIHtcbiAgICAgICAgICAgIHBhcmFtVHlwZXMucHVzaChwYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc+JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJz4nKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oXG4gICAgICAgICAgICBwYXJhbVR5cGVzXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKSwgb2xkSW5UeXBlID0gc3RhdGUuaW5UeXBlLCBwYXJhbVR5cGVzID0gW107XG5cbiAgICAgICAgc3RhdGUuaW5UeXBlID0gdHJ1ZTtcblxuICAgICAgICBleHBlY3QoJzwnKTtcbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnPicpKSB7XG4gICAgICAgICAgICBwYXJhbVR5cGVzLnB1c2gocGFyc2VUeXBlKCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnPicpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KCc+Jyk7XG5cbiAgICAgICAgc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKFxuICAgICAgICAgICAgcGFyYW1UeXBlc1xuICAgICAgICApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFR5cGVJbmRleGVyKG1hcmtlciwgaXNTdGF0aWMpIHtcbiAgICAgICAgdmFyIGlkLCBrZXksIHZhbHVlO1xuXG4gICAgICAgIGV4cGVjdCgnWycpO1xuICAgICAgICBpZCA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgIGtleSA9IHBhcnNlVHlwZSgpO1xuICAgICAgICBleHBlY3QoJ10nKTtcbiAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VUeXBlKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlT2JqZWN0VHlwZUluZGV4ZXIoXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgaXNTdGF0aWNcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKG1hcmtlcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gW10sIHJlc3QgPSBudWxsLCByZXR1cm5UeXBlLCB0eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgICAgIGlmIChtYXRjaCgnPCcpKSB7XG4gICAgICAgICAgICB0eXBlUGFyYW1ldGVycyA9IHBhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgd2hpbGUgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJy4uLicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJlc3QgPSBwYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICByZXR1cm5UeXBlID0gcGFyc2VUeXBlKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25UeXBlQW5ub3RhdGlvbihcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIHJldHVyblR5cGUsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnNcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RUeXBlTWV0aG9kKG1hcmtlciwgaXNTdGF0aWMsIGtleSkge1xuICAgICAgICB2YXIgb3B0aW9uYWwgPSBmYWxzZSwgdmFsdWU7XG4gICAgICAgIHZhbHVlID0gcGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKG1hcmtlcik7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlT2JqZWN0VHlwZVByb3BlcnR5KFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgIGlzU3RhdGljXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShtYXJrZXIsIGlzU3RhdGljKSB7XG4gICAgICAgIHZhciB2YWx1ZU1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVPYmplY3RUeXBlQ2FsbFByb3BlcnR5KFxuICAgICAgICAgICAgcGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHZhbHVlTWFya2VyKSxcbiAgICAgICAgICAgIGlzU3RhdGljXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0VHlwZShhbGxvd1N0YXRpYykge1xuICAgICAgICB2YXIgY2FsbFByb3BlcnRpZXMgPSBbXSwgaW5kZXhlcnMgPSBbXSwgbWFya2VyLCBvcHRpb25hbCA9IGZhbHNlLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IFtdLCBwcm9wZXJ0eUtleSwgcHJvcGVydHlUeXBlQW5ub3RhdGlvbixcbiAgICAgICAgICAgIHRva2VuLCBpc1N0YXRpYywgbWF0Y2hTdGF0aWM7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcbiAgICAgICAgICAgIG1hdGNoU3RhdGljID1cbiAgICAgICAgICAgICAgICAgICBzdHJpY3RcbiAgICAgICAgICAgICAgICAgICA/IG1hdGNoS2V5d29yZCgnc3RhdGljJylcbiAgICAgICAgICAgICAgICAgICA6IG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ3N0YXRpYycpO1xuXG4gICAgICAgICAgICBpZiAoYWxsb3dTdGF0aWMgJiYgbWF0Y2hTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBpbmRleGVycy5wdXNoKHBhcnNlT2JqZWN0VHlwZUluZGV4ZXIobWFya2VyLCBpc1N0YXRpYykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpIHx8IG1hdGNoKCc8JykpIHtcbiAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5wdXNoKHBhcnNlT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShtYXJrZXIsIGFsbG93U3RhdGljKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpYyAmJiBtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVJZGVudGlmaWVyKHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCc8JykgfHwgbWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWV0aG9kIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwYXJzZU9iamVjdFR5cGVNZXRob2QobWFya2VyLCBpc1N0YXRpYywgcHJvcGVydHlLZXkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goJz8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5VHlwZUFubm90YXRpb24gPSBwYXJzZVR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlT2JqZWN0VHlwZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVR5cGVBbm5vdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N0YXRpY1xuICAgICAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZU9iamVjdFR5cGVBbm5vdGF0aW9uKFxuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIGluZGV4ZXJzLFxuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUdlbmVyaWNUeXBlKCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlUGFyYW1ldGVycyA9IG51bGwsIHR5cGVJZGVudGlmaWVyO1xuXG4gICAgICAgIHR5cGVJZGVudGlmaWVyID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgZXhwZWN0KCcuJyk7XG4gICAgICAgICAgICB0eXBlSWRlbnRpZmllciA9IG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoXG4gICAgICAgICAgICAgICAgdHlwZUlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVHZW5lcmljVHlwZUFubm90YXRpb24oXG4gICAgICAgICAgICB0eXBlSWRlbnRpZmllcixcbiAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVm9pZFR5cGUoKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcbiAgICAgICAgZXhwZWN0S2V5d29yZCgndm9pZCcpO1xuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVWb2lkVHlwZUFubm90YXRpb24oKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlb2ZUeXBlKCkge1xuICAgICAgICB2YXIgYXJndW1lbnQsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBleHBlY3RLZXl3b3JkKCd0eXBlb2YnKTtcbiAgICAgICAgYXJndW1lbnQgPSBwYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVR5cGVvZlR5cGVBbm5vdGF0aW9uKFxuICAgICAgICAgICAgYXJndW1lbnRcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUdXBsZVR5cGUoKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKSwgdHlwZXMgPSBbXTtcbiAgICAgICAgZXhwZWN0KCdbJyk7XG4gICAgICAgIC8vIFdlIGFsbG93IHRyYWlsaW5nIGNvbW1hc1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGggJiYgIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgIHR5cGVzLnB1c2gocGFyc2VUeXBlKCkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnXScpO1xuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVUdXBsZVR5cGVBbm5vdGF0aW9uKFxuICAgICAgICAgICAgdHlwZXNcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCBuYW1lLCBvcHRpb25hbCA9IGZhbHNlLCB0eXBlQW5ub3RhdGlvbjtcbiAgICAgICAgbmFtZSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgdHlwZUFubm90YXRpb24gPSBwYXJzZVR5cGUoKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25UeXBlUGFyYW0oXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZUFubm90YXRpb24sXG4gICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpIHtcbiAgICAgICAgdmFyIHJldCA9IHsgcGFyYW1zOiBbXSwgcmVzdDogbnVsbCB9O1xuICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldC5wYXJhbXMucHVzaChwYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJy4uLicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldC5yZXN0ID0gcGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIHBhcnNpbmcgb2YgdHlwZXMgcm91Z2hseSBwYXJhbGxlbHMgdGhlIHBhcnNpbmcgb2YgZXhwcmVzc2lvbnMsIGFuZFxuICAgIC8vIHByaW1hcnkgdHlwZXMgYXJlIGtpbmQgb2YgbGlrZSBwcmltYXJ5IGV4cHJlc3Npb25zLi4udGhleSdyZSB0aGVcbiAgICAvLyBwcmltaXRpdmVzIHdpdGggd2hpY2ggb3RoZXIgdHlwZXMgYXJlIGNvbnN0cnVjdGVkLlxuICAgIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeVR5cGUoKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBudWxsLCByZXR1cm5UeXBlID0gbnVsbCxcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCByZXN0ID0gbnVsbCwgdG1wLFxuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMsIHRva2VuLCB0eXBlLCBpc0dyb3VwZWRUeXBlID0gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudHlwZSkge1xuICAgICAgICBjYXNlIFRva2VuLklkZW50aWZpZXI6XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYW55JzpcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVBbnlUeXBlQW5ub3RhdGlvbigpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2wnOiAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUJvb2xlYW5UeXBlQW5ub3RhdGlvbigpKTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlTnVtYmVyVHlwZUFubm90YXRpb24oKSk7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVN0cmluZ1R5cGVBbm5vdGF0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgcGFyc2VHZW5lcmljVHlwZSgpKTtcbiAgICAgICAgY2FzZSBUb2tlbi5QdW5jdHVhdG9yOlxuICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIHBhcnNlT2JqZWN0VHlwZSgpKTtcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVR1cGxlVHlwZSgpO1xuICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKCcpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHBhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICAgICAgICByZXN0ID0gdG1wLnJlc3Q7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gcGFyc2VUeXBlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVGdW5jdGlvblR5cGVBbm5vdGF0aW9uKFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJlc3QsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhY3R1YWxseSBhIGdyb3VwZWQgdHlwZVxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJyknKSAmJiAhbWF0Y2goJy4uLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0dyb3VwZWRUeXBlID0gdG9rZW4udmFsdWUgIT09ICc/JyAmJiB0b2tlbi52YWx1ZSAhPT0gJzonO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNHcm91cGVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gcGFyc2VUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHNlZSBhID0+IG5leHQgdGhlbiBzb21lb25lIHdhcyBwcm9iYWJseSBjb25mdXNlZCBhYm91dFxuICAgICAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiB0eXBlcywgc28gd2UgY2FuIHByb3ZpZGUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkNvbmZ1c2VkQWJvdXRGdW5jdGlvblR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG1wID0gcGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICAgICAgICAgIHJlc3QgPSB0bXAucmVzdDtcblxuICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KCc9PicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IHBhcnNlVHlwZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25UeXBlQW5ub3RhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlLFxuICAgICAgICAgICAgICAgICAgICByZXN0LFxuICAgICAgICAgICAgICAgICAgICBudWxsIC8qIHR5cGVQYXJhbWV0ZXJzICovXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUb2tlbi5LZXl3b3JkOlxuICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ZvaWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIHBhcnNlVm9pZFR5cGUoKSk7XG4gICAgICAgICAgICBjYXNlICd0eXBlb2YnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIHBhcnNlVHlwZW9mVHlwZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRva2VuLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbihcbiAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBvc3RmaXhUeXBlKCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksIHQgPSBwYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICBleHBlY3QoJ1snKTtcbiAgICAgICAgICAgIGV4cGVjdCgnXScpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlQXJyYXlUeXBlQW5ub3RhdGlvbih0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcmVmaXhUeXBlKCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZU51bGxhYmxlVHlwZUFubm90YXRpb24oXG4gICAgICAgICAgICAgICAgcGFyc2VQcmVmaXhUeXBlKClcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVBvc3RmaXhUeXBlKCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBwYXJzZUludGVyc2VjdGlvblR5cGUoKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKSwgdHlwZSwgdHlwZXM7XG4gICAgICAgIHR5cGUgPSBwYXJzZVByZWZpeFR5cGUoKTtcbiAgICAgICAgdHlwZXMgPSBbdHlwZV07XG4gICAgICAgIHdoaWxlIChtYXRjaCgnJicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHR5cGVzLnB1c2gocGFyc2VQcmVmaXhUeXBlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGVzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgdHlwZSA6XG4gICAgICAgICAgICAgICAgbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNcbiAgICAgICAgICAgICAgICApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVVuaW9uVHlwZSgpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCB0eXBlLCB0eXBlcztcbiAgICAgICAgdHlwZSA9IHBhcnNlSW50ZXJzZWN0aW9uVHlwZSgpO1xuICAgICAgICB0eXBlcyA9IFt0eXBlXTtcbiAgICAgICAgd2hpbGUgKG1hdGNoKCd8JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgdHlwZXMucHVzaChwYXJzZUludGVyc2VjdGlvblR5cGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgdHlwZSA6XG4gICAgICAgICAgICAgICAgbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uKFxuICAgICAgICAgICAgICAgICAgICB0eXBlc1xuICAgICAgICAgICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHlwZSgpIHtcbiAgICAgICAgdmFyIG9sZEluVHlwZSA9IHN0YXRlLmluVHlwZSwgdHlwZTtcbiAgICAgICAgc3RhdGUuaW5UeXBlID0gdHJ1ZTtcblxuICAgICAgICB0eXBlID0gcGFyc2VVbmlvblR5cGUoKTtcblxuICAgICAgICBzdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHlwZUFubm90YXRpb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKSwgdHlwZTtcblxuICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgdHlwZSA9IHBhcnNlVHlwZSgpO1xuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVR5cGVBbm5vdGF0aW9uKHR5cGUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLFxuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUlkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIocmVxdWlyZVR5cGVBbm5vdGF0aW9uLCBjYW5CZU9wdGlvbmFsUGFyYW0pIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLFxuICAgICAgICAgICAgaWRlbnQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpLFxuICAgICAgICAgICAgaXNPcHRpb25hbFBhcmFtID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNhbkJlT3B0aW9uYWxQYXJhbSAmJiBtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBleHBlY3QoJz8nKTtcbiAgICAgICAgICAgIGlzT3B0aW9uYWxQYXJhbSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWlyZVR5cGVBbm5vdGF0aW9uIHx8IG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgIGlkZW50LnR5cGVBbm5vdGF0aW9uID0gcGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgaWRlbnQgPSBtYXJrZXJBcHBseShtYXJrZXIsIGlkZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc09wdGlvbmFsUGFyYW0pIHtcbiAgICAgICAgICAgIGlkZW50Lm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGlkZW50ID0gbWFya2VyQXBwbHkobWFya2VyLCBpZGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWRlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKGtpbmQpIHtcbiAgICAgICAgdmFyIGlkLFxuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksXG4gICAgICAgICAgICBpbml0ID0gbnVsbCxcbiAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uTWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICBpZCA9IHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKTtcbiAgICAgICAgICAgIHJlaW50ZXJwcmV0QXNBc3NpZ25tZW50QmluZGluZ1BhdHRlcm4oaWQpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICBpZC50eXBlQW5ub3RhdGlvbiA9IHBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgICAgICAgICAgICBtYXJrZXJBcHBseSh0eXBlQW5ub3RhdGlvbk1hcmtlciwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XG4gICAgICAgICAgICByZWludGVycHJldEFzQXNzaWdubWVudEJpbmRpbmdQYXR0ZXJuKGlkKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICAgICAgaWQudHlwZUFubm90YXRpb24gPSBwYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyQXBwbHkodHlwZUFubm90YXRpb25NYXJrZXIsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZCA9IHN0YXRlLmFsbG93S2V5d29yZCA/IHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIDogcGFyc2VUeXBlQW5ub3RhdGFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAvLyAxMi4yLjFcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2luZCA9PT0gJ2NvbnN0Jykge1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTm9VbmluaXRpYWxpemVkQ29uc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KCc9Jyk7XG4gICAgICAgICAgICBpbml0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgaW5pdCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3Qoa2luZCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24oa2luZCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSB3aGlsZSAoaW5kZXggPCBsZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3ZhcicpO1xuXG4gICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XG4gICAgfVxuXG4gICAgLy8ga2luZCBtYXkgYmUgYGNvbnN0YCBvciBgbGV0YFxuICAgIC8vIEJvdGggYXJlIGV4cGVyaW1lbnRhbCBhbmQgbm90IGluIHRoZSBzcGVjaWZpY2F0aW9uIHlldC5cbiAgICAvLyBzZWUgaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTpjb25zdFxuICAgIC8vIGFuZCBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmxldFxuICAgIGZ1bmN0aW9uIHBhcnNlQ29uc3RMZXREZWNsYXJhdGlvbihraW5kKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoa2luZCk7XG5cbiAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChraW5kKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcbiAgICB9XG5cbiAgICAvLyBwZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWxcblxuICAgIGZ1bmN0aW9uIHBhcnNlTW9kdWxlU3BlY2lmaWVyKCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksXG4gICAgICAgICAgICBzcGVjaWZpZXI7XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkTW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBzcGVjaWZpZXIgPSBkZWxlZ2F0ZS5jcmVhdGVNb2R1bGVTcGVjaWZpZXIobG9va2FoZWFkKTtcbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIHNwZWNpZmllcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnRCYXRjaFNwZWNpZmllcigpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBleHBlY3QoJyonKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRXhwb3J0QmF0Y2hTcGVjaWZpZXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnRTcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciBpZCwgbmFtZSA9IG51bGwsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCBmcm9tO1xuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgaWQgPSBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUlkZW50aWZpZXIoJ2RlZmF1bHQnKSk7XG4gICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9IGZyb20gXCJzb21ldGhpbmdcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBuYW1lID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVFeHBvcnRTcGVjaWZpZXIoaWQsIG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSBudWxsLFxuICAgICAgICAgICAgcG9zc2libGVJZGVudGlmaWVyVG9rZW4sIHNvdXJjZUVsZW1lbnQsXG4gICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyLFxuICAgICAgICAgICAgc3JjID0gbnVsbCwgc3BlY2lmaWVycyA9IFtdLFxuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZXhwb3J0Jyk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSB8fCBtYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUlkZW50aWZpZXJUb2tlbiA9IGxvb2thaGVhZDIoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyTmFtZShwb3NzaWJsZUlkZW50aWZpZXJUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb28gKCkge31cbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgY2xhc3MgZm9vIHt9XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRXhwb3J0RGVjbGFyYXRpb24odHJ1ZSwgc291cmNlRWxlbWVudCwgW3NvdXJjZUVsZW1lbnQuaWRdLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGNsYXNzIHt9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUV4cG9ydERlY2xhcmF0aW9uKHRydWUsIHBhcnNlQ2xhc3NFeHByZXNzaW9uKCksIFtdLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVFeHBvcnREZWNsYXJhdGlvbih0cnVlLCBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpLCBbXSwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgbG9va2FoZWFkLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQge307XG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBbXTtcbiAgICAgICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUV4cG9ydERlY2xhcmF0aW9uKHRydWUsIGRlY2xhcmF0aW9uLCBbXSwgbnVsbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9uLWRlZmF1bHQgZXhwb3J0XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCB8fCBtYXRjaENvbnRleHR1YWxLZXl3b3JkKCd0eXBlJykpIHtcbiAgICAgICAgICAgIC8vIGNvdmVyczpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB2YXIgZiA9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVFeHBvcnREZWNsYXJhdGlvbihmYWxzZSwgcGFyc2VTb3VyY2VFbGVtZW50KCksIHNwZWNpZmllcnMsIG51bGwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tIFwiZm9vXCI7XG4gICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VFeHBvcnRCYXRjaFNwZWNpZmllcigpKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBsb29rYWhlYWQudmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2UsIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHNyYyA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG4gICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUV4cG9ydERlY2xhcmF0aW9uKGZhbHNlLCBudWxsLCBzcGVjaWZpZXJzLCBzcmMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gaXNFeHBvcnRGcm9tSWRlbnRpZmllciB8fCBtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VFeHBvcnRTcGVjaWZpZXIoKSk7XG4gICAgICAgICAgICB9IHdoaWxlIChtYXRjaCgnLCcpICYmIGxleCgpKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcmluZzpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSBcImZvb1wiO1xuICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299IGZyb20gXCJmb29cIjtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgc3JjID0gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcbiAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0V4cG9ydEZyb21JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcmluZzpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH07IC8vIG1pc3NpbmcgZnJvbUNsYXVzZVxuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgbG9va2FoZWFkLnZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2UsIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb3ZlclxuICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299O1xuICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUV4cG9ydERlY2xhcmF0aW9uKGZhbHNlLCBkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc3JjKSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydFNwZWNpZmllcigpIHtcbiAgICAgICAgLy8gaW1wb3J0IHs8Zm9vIGFzIGJhcj59IC4uLjtcbiAgICAgICAgdmFyIGlkLCBuYW1lID0gbnVsbCwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgaWQgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgbmFtZSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVJbXBvcnRTcGVjaWZpZXIoaWQsIG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5hbWVkSW1wb3J0cygpIHtcbiAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcbiAgICAgICAgLy8ge2ZvbywgYmFyIGFzIGJhc31cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG4gICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydFNwZWNpZmllcigpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKG1hdGNoKCcsJykgJiYgbGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnfScpO1xuICAgICAgICByZXR1cm4gc3BlY2lmaWVycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgICAgIC8vIGltcG9ydCA8Zm9vPiAuLi47XG4gICAgICAgIHZhciBpZCwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgaWQgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVJbXBvcnREZWZhdWx0U3BlY2lmaWVyKGlkKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSB7XG4gICAgICAgIC8vIGltcG9ydCA8KiBhcyBmb28+IC4uLjtcbiAgICAgICAgdmFyIGlkLCBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBleHBlY3QoJyonKTtcbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5Ob0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGxleCgpO1xuICAgICAgICBpZCA9IHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihpZCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW1wb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBzcGVjaWZpZXJzLCBzcmMsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCBpc1R5cGUgPSBmYWxzZSwgdG9rZW4yO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ltcG9ydCcpO1xuXG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCd0eXBlJykpIHtcbiAgICAgICAgICAgIHRva2VuMiA9IGxvb2thaGVhZDIoKTtcbiAgICAgICAgICAgIGlmICgodG9rZW4yLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgJiYgdG9rZW4yLnZhbHVlICE9PSAnZnJvbScpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbjIudHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuMi52YWx1ZSA9PT0gJ3snIHx8IHRva2VuMi52YWx1ZSA9PT0gJyonKSkpIHtcbiAgICAgICAgICAgICAgICBpc1R5cGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3BlY2lmaWVycyA9IFtdO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gaW1wb3J0IFwiZm9vXCI7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc3JjLCBpc1R5cGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgJiYgaXNJZGVudGlmaWVyTmFtZShsb29rYWhlYWQpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vXG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAuLi5cbiAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAqIGFzIGZvb1xuICAgICAgICAgICAgLy8gaW1wb3J0ICogYXMgZm9vXG4gICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywge2Jhcn1cbiAgICAgICAgICAgIC8vIGltcG9ydCB7YmFyfVxuICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHBhcnNlTmFtZWRJbXBvcnRzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIGxvb2thaGVhZC52YWx1ZSA/XG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IE1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlLCBsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxleCgpO1xuICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc3JjLCBpc1R5cGUpKTtcbiAgICB9XG5cbiAgICAvLyAxMi4zIEVtcHR5IFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbXB0eVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBleHBlY3QoJzsnKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRW1wdHlTdGF0ZW1lbnQoKSk7XG4gICAgfVxuXG4gICAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcbiAgICB9XG5cbiAgICAvLyAxMi41IElmIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnaWYnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZWxzZScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XG4gICAgfVxuXG4gICAgLy8gMTIuNiBJdGVyYXRpb24gU3RhdGVtZW50c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VEb1doaWxlU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgYm9keSwgdGVzdCwgb2xkSW5JdGVyYXRpb24sIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RvJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRlc3QsIGJvZHksIG9sZEluSXRlcmF0aW9uLCBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd3aGlsZScpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVXaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksXG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpO1xuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCB0b2tlbi52YWx1ZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KG9wdHMpIHtcbiAgICAgICAgdmFyIGluaXQsIHRlc3QsIHVwZGF0ZSwgbGVmdCwgcmlnaHQsIGJvZHksIG9wZXJhdG9yLCBvbGRJbkl0ZXJhdGlvbixcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBpbml0ID0gdGVzdCA9IHVwZGF0ZSA9IG51bGw7XG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ZvcicpO1xuXG4gICAgICAgIC8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXByb3Bvc2FsczppdGVyYXRvcnNfYW5kX2dlbmVyYXRvcnMmcz1lYWNoXG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdlYWNoJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkVhY2hOb3RBbGxvd2VkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3ZhcicpIHx8IG1hdGNoS2V5d29yZCgnbGV0JykgfHwgbWF0Y2hLZXl3b3JkKCdjb25zdCcpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGluaXQgPSBwYXJzZUZvclZhcmlhYmxlRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChpbml0LmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnaW4nKSB8fCBtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKChvcGVyYXRvci52YWx1ZSA9PT0gJ2luJyB8fCBpbml0LmtpbmQgIT09ICd2YXInKSAmJiBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbml0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXNzaWduYWJsZUxlZnRIYW5kU2lkZShpbml0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJzsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KCc7Jyk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGlmICghKG9wdHMgIT09IHVuZGVmaW5lZCAmJiBvcHRzLmlnbm9yZUJvZHkpKSB7XG4gICAgICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yLnZhbHVlID09PSAnaW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVGb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSk7XG4gICAgfVxuXG4gICAgLy8gMTIuNyBUaGUgY29udGludWUgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjb250aW51ZScpO1xuXG4gICAgICAgIC8vIE9wdGltaXplIHRoZSBtb3N0IGNvbW1vbiBmb3JtOiAnY29udGludWU7Jy5cbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gNTkpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlQ29udGludWVTdGF0ZW1lbnQobnVsbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlQ29udGludWVTdGF0ZW1lbnQobnVsbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUubGFiZWxTZXQuaGFzKGxhYmVsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlQ29udGludWVTdGF0ZW1lbnQobGFiZWwpKTtcbiAgICB9XG5cbiAgICAvLyAxMi44IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG51bGwsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2JyZWFrJyk7XG5cbiAgICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChjaGFyICM1OSkuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDU5KSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlQnJlYWtTdGF0ZW1lbnQobnVsbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICBpZiAoIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVCcmVha1N0YXRlbWVudChudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5sYWJlbFNldC5oYXMobGFiZWwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5Vbmtub3duTGFiZWwsIGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhKHN0YXRlLmluSXRlcmF0aW9uIHx8IHN0YXRlLmluU3dpdGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUJyZWFrU3RhdGVtZW50KGxhYmVsKSk7XG4gICAgfVxuXG4gICAgLy8gMTIuOSBUaGUgcmV0dXJuIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBhcmd1bWVudCA9IG51bGwsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAzMikge1xuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVJldHVyblN0YXRlbWVudChudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ30nKSAmJiBsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVSZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpKTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgd2l0aCBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2l0aFN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIG9iamVjdCwgYm9keSwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RNb2RlV2l0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd3aXRoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgb2JqZWN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpKTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgc3dpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciB0ZXN0LFxuICAgICAgICAgICAgY29uc2VxdWVudCA9IFtdLFxuICAgICAgICAgICAgc291cmNlRWxlbWVudCxcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0ZXN0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcbiAgICAgICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpIHx8IG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpIHx8IG1hdGNoS2V5d29yZCgnY2FzZScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zZXF1ZW50LnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVTd2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaFN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGRpc2NyaW1pbmFudCwgY2FzZXMsIGNsYXVzZSwgb2xkSW5Td2l0Y2gsIGRlZmF1bHRGb3VuZCwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZGlzY3JpbWluYW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgY2FzZXMgPSBbXTtcblxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSB0cnVlO1xuICAgICAgICBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGF1c2UgPSBwYXJzZVN3aXRjaENhc2UoKTtcbiAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpKTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMyBUaGUgdGhyb3cgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRocm93U3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgYXJndW1lbnQsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3Rocm93Jyk7XG5cbiAgICAgICAgaWYgKHBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVUaHJvd1N0YXRlbWVudChhcmd1bWVudCkpO1xuICAgIH1cblxuICAgIC8vIDEyLjE0IFRoZSB0cnkgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNhdGNoQ2xhdXNlKCkge1xuICAgICAgICB2YXIgcGFyYW0sIGJvZHksIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NhdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIC8vIDEyLjE0LjFcbiAgICAgICAgaWYgKHN0cmljdCAmJiBwYXJhbS50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgIGJvZHkgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUNhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUcnlTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBibG9jaywgaGFuZGxlcnMgPSBbXSwgZmluYWxpemVyID0gbnVsbCwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndHJ5Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnY2F0Y2gnKSkge1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChwYXJzZUNhdGNoQ2xhdXNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZmluYWxseScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGZpbmFsaXplciA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDAgJiYgIWZpbmFsaXplcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVUcnlTdGF0ZW1lbnQoYmxvY2ssIFtdLCBoYW5kbGVycywgZmluYWxpemVyKSk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTUgVGhlIGRlYnVnZ2VyIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBleHBlY3RLZXl3b3JkKCdkZWJ1Z2dlcicpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVEZWJ1Z2dlclN0YXRlbWVudCgpKTtcbiAgICB9XG5cbiAgICAvLyAxMiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBsb29rYWhlYWQudHlwZSxcbiAgICAgICAgICAgIG1hcmtlcixcbiAgICAgICAgICAgIGV4cHIsXG4gICAgICAgICAgICBsYWJlbGVkQm9keTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRW1wdHlTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUJsb2NrKCk7XG4gICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdicmVhayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDb250aW51ZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnZGVidWdnZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdkbyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRG9XaGlsZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnZm9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGb3JTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ2xhc3NEZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnaWYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlmU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVJldHVyblN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUaHJvd1N0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAndHJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUcnlTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3doaWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VXaGlsZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnd2l0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aFN0YXRlbWVudCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEFzeW5jRnVuY0V4cHJPckRlY2woKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICAvLyAxMi4xMiBMYWJlbGxlZCBTdGF0ZW1lbnRzXG4gICAgICAgIGlmICgoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikgJiYgbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5sYWJlbFNldC5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlJlZGVjbGFyYXRpb24sICdMYWJlbCcsIGV4cHIubmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLmxhYmVsU2V0LnNldChleHByLm5hbWUsIHRydWUpO1xuICAgICAgICAgICAgbGFiZWxlZEJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgc3RhdGUubGFiZWxTZXQuZGVsZXRlKGV4cHIubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVMYWJlbGVkU3RhdGVtZW50KGV4cHIsIGxhYmVsZWRCb2R5KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChleHByKSk7XG4gICAgfVxuXG4gICAgLy8gMTMgRnVuY3Rpb24gRGVmaW5pdGlvblxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb25jaXNlQm9keSgpIHtcbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIHNvdXJjZUVsZW1lbnQsIHNvdXJjZUVsZW1lbnRzID0gW10sIHRva2VuLCBkaXJlY3RpdmUsIGZpcnN0UmVzdHJpY3RlZCxcbiAgICAgICAgICAgIG9sZExhYmVsU2V0LCBvbGRJbkl0ZXJhdGlvbiwgb2xkSW5Td2l0Y2gsIG9sZEluRnVuY3Rpb25Cb2R5LCBvbGRQYXJlbnRoZXNpemVkQ291bnQsXG4gICAgICAgICAgICBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc291cmNlRWxlbWVudC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXJlY3RpdmUgPSBzb3VyY2Uuc2xpY2UodG9rZW4ucmFuZ2VbMF0gKyAxLCB0b2tlbi5yYW5nZVsxXSAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvbGRMYWJlbFNldCA9IHN0YXRlLmxhYmVsU2V0O1xuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBvbGRJblN3aXRjaCA9IHN0YXRlLmluU3dpdGNoO1xuICAgICAgICBvbGRJbkZ1bmN0aW9uQm9keSA9IHN0YXRlLmluRnVuY3Rpb25Cb2R5O1xuICAgICAgICBvbGRQYXJlbnRoZXNpemVkQ291bnQgPSBzdGF0ZS5wYXJlbnRoZXNpemVkQ291bnQ7XG5cbiAgICAgICAgc3RhdGUubGFiZWxTZXQgPSBuZXcgU3RyaW5nTWFwKCk7XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucGFyZW50aGVzaXplZENvdW50ID0gMDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgc3RhdGUubGFiZWxTZXQgPSBvbGRMYWJlbFNldDtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcbiAgICAgICAgc3RhdGUuaW5GdW5jdGlvbkJvZHkgPSBvbGRJbkZ1bmN0aW9uQm9keTtcbiAgICAgICAgc3RhdGUucGFyZW50aGVzaXplZENvdW50ID0gb2xkUGFyZW50aGVzaXplZENvdW50O1xuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUJsb2NrU3RhdGVtZW50KHNvdXJjZUVsZW1lbnRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgbmFtZSkge1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJhbVNldC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucGFyYW1TZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5wYXJhbVNldC5zZXQobmFtZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbShvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIHRva2VuLCByZXN0LCBwYXJhbSwgZGVmO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICcuLi4nKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgcmVzdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgICAgICBwYXJhbSA9IHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgICAgICAgcmVpbnRlcnByZXRBc0Rlc3RydWN0dXJlZFBhcmFtZXRlcihvcHRpb25zLCBwYXJhbSk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJzonKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLnR5cGVBbm5vdGF0aW9uID0gcGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgICAgIG1hcmtlckFwcGx5KG1hcmtlciwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5PYmplY3RQYXR0ZXJuQXNSZXN0UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtID0gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICAgICAgICAgICAgcmVpbnRlcnByZXRBc0Rlc3RydWN0dXJlZFBhcmFtZXRlcihvcHRpb25zLCBwYXJhbSk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJzonKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLnR5cGVBbm5vdGF0aW9uID0gcGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgICAgIG1hcmtlckFwcGx5KG1hcmtlciwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW0gPVxuICAgICAgICAgICAgICAgIHJlc3RcbiAgICAgICAgICAgICAgICA/IHBhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcihcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsIC8qIHJlcXVpcmVUeXBlQW5ub3RhdGlvbiAqL1xuICAgICAgICAgICAgICAgICAgICBmYWxzZSAvKiBjYW5CZU9wdGlvbmFsUGFyYW0gKi9cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBwYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLCAvKiByZXF1aXJlVHlwZUFubm90YXRpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSAvKiBjYW5CZU9wdGlvbmFsUGFyYW0gKi9cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQobG9va2FoZWFkLCBNZXNzYWdlcy5EZWZhdWx0UmVzdFBhcmFtZXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGRlZiA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICsrb3B0aW9ucy5kZWZhdWx0Q291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucmVzdCA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5wYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdHMucHVzaChkZWYpO1xuICAgICAgICByZXR1cm4gIW1hdGNoKCcpJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbXMoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgIHZhciBvcHRpb25zLCBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgIGRlZmF1bHRDb3VudDogMCxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IGZpcnN0UmVzdHJpY3RlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldCA9IG5ldyBTdHJpbmdNYXAoKTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VQYXJhbShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJldHVyblR5cGUgPSBwYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBpZCwgYm9keSwgdG9rZW4sIHRtcCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCBnZW5lcmF0b3IsIGlzQXN5bmMsXG4gICAgICAgICAgICBwcmV2aW91c1N0cmljdCwgcHJldmlvdXNZaWVsZEFsbG93ZWQsIHByZXZpb3VzQXdhaXRBbGxvd2VkLFxuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksIHR5cGVQYXJhbWV0ZXJzO1xuXG4gICAgICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1hdGNoQXN5bmMoKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgICAgZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGdlbmVyYXRvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc8JykpIHtcbiAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gcGFyc2VQYXJhbXMoZmlyc3RSZXN0cmljdGVkKTtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgcHJldmlvdXNZaWVsZEFsbG93ZWQgPSBzdGF0ZS55aWVsZEFsbG93ZWQ7XG4gICAgICAgIHN0YXRlLnlpZWxkQWxsb3dlZCA9IGdlbmVyYXRvcjtcbiAgICAgICAgcHJldmlvdXNBd2FpdEFsbG93ZWQgPSBzdGF0ZS5hd2FpdEFsbG93ZWQ7XG4gICAgICAgIHN0YXRlLmF3YWl0QWxsb3dlZCA9IGlzQXN5bmM7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuXG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiB0bXAuc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0bXAuc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICBzdGF0ZS55aWVsZEFsbG93ZWQgPSBwcmV2aW91c1lpZWxkQWxsb3dlZDtcbiAgICAgICAgc3RhdGUuYXdhaXRBbGxvd2VkID0gcHJldmlvdXNBd2FpdEFsbG93ZWQ7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KFxuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25EZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB0bXAucGFyYW1zLFxuICAgICAgICAgICAgICAgIHRtcC5kZWZhdWx0cyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIHRtcC5yZXN0LFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcixcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0FzeW5jLFxuICAgICAgICAgICAgICAgIHRtcC5yZXR1cm5UeXBlLFxuICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgaWQgPSBudWxsLCBmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UsIHRtcCwgYm9keSwgZ2VuZXJhdG9yLCBpc0FzeW5jLFxuICAgICAgICAgICAgcHJldmlvdXNTdHJpY3QsIHByZXZpb3VzWWllbGRBbGxvd2VkLCBwcmV2aW91c0F3YWl0QWxsb3dlZCxcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCB0eXBlUGFyYW1ldGVycztcblxuICAgICAgICBpc0FzeW5jID0gZmFsc2U7XG4gICAgICAgIGlmIChtYXRjaEFzeW5jKCkpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuXG4gICAgICAgIGdlbmVyYXRvciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGdlbmVyYXRvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCgnPCcpKSB7XG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gcGFyc2VQYXJhbXMoZmlyc3RSZXN0cmljdGVkKTtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgcHJldmlvdXNZaWVsZEFsbG93ZWQgPSBzdGF0ZS55aWVsZEFsbG93ZWQ7XG4gICAgICAgIHN0YXRlLnlpZWxkQWxsb3dlZCA9IGdlbmVyYXRvcjtcbiAgICAgICAgcHJldmlvdXNBd2FpdEFsbG93ZWQgPSBzdGF0ZS5hd2FpdEFsbG93ZWQ7XG4gICAgICAgIHN0YXRlLmF3YWl0QWxsb3dlZCA9IGlzQXN5bmM7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuXG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiB0bXAuc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0bXAuc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICBzdGF0ZS55aWVsZEFsbG93ZWQgPSBwcmV2aW91c1lpZWxkQWxsb3dlZDtcbiAgICAgICAgc3RhdGUuYXdhaXRBbGxvd2VkID0gcHJldmlvdXNBd2FpdEFsbG93ZWQ7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KFxuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHRtcC5wYXJhbXMsXG4gICAgICAgICAgICAgICAgdG1wLmRlZmF1bHRzLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgdG1wLnJlc3QsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQXN5bmMsXG4gICAgICAgICAgICAgICAgdG1wLnJldHVyblR5cGUsXG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnNcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVlpZWxkRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlRmxhZywgZXhwciwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgneWllbGQnLCAhc3RyaWN0KTtcblxuICAgICAgICBkZWxlZ2F0ZUZsYWcgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1hdGNoKCcqJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZGVsZWdhdGVGbGFnID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlWWllbGRFeHByZXNzaW9uKGV4cHIsIGRlbGVnYXRlRmxhZykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXdhaXRFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgIGV4cGVjdENvbnRleHR1YWxLZXl3b3JkKCdhd2FpdCcpO1xuICAgICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVBd2FpdEV4cHJlc3Npb24oZXhwcikpO1xuICAgIH1cblxuICAgIC8vIDE0IEZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuXG4gICAgLy8gMTQuMSBGdW5jdGlvbnMgaXMgZGVmaW5lZCBhYm92ZSAoMTMgaW4gRVM1KVxuICAgIC8vIDE0LjIgQXJyb3cgRnVuY3Rpb25zIERlZmluaXRpb25zIGlzIGRlZmluZWQgaW4gKDcuMyBhc3NpZ25tZW50cylcblxuICAgIC8vIDE0LjMgTWV0aG9kIERlZmluaXRpb25zXG4gICAgLy8gMTQuMy43XG4gICAgZnVuY3Rpb24gc3BlY2lhbE1ldGhvZChtZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBtZXRob2REZWZpbml0aW9uLmtpbmQgPT09ICdnZXQnIHx8XG4gICAgICAgICAgICAgICBtZXRob2REZWZpbml0aW9uLmtpbmQgPT09ICdzZXQnIHx8XG4gICAgICAgICAgICAgICBtZXRob2REZWZpbml0aW9uLnZhbHVlLmdlbmVyYXRvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1ldGhvZERlZmluaXRpb24oa2V5LCBpc1N0YXRpYywgZ2VuZXJhdG9yLCBjb21wdXRlZCkge1xuICAgICAgICB2YXIgdG9rZW4sIHBhcmFtLCBwcm9wVHlwZSxcbiAgICAgICAgICAgIGlzQXN5bmMsIHR5cGVQYXJhbWV0ZXJzLCB0b2tlblZhbHVlLCByZXR1cm5UeXBlO1xuXG4gICAgICAgIHByb3BUeXBlID0gaXNTdGF0aWMgPyBDbGFzc1Byb3BlcnR5VHlwZS5zdGF0aWMgOiBDbGFzc1Byb3BlcnR5VHlwZS5wcm90b3R5cGU7XG5cbiAgICAgICAgaWYgKGdlbmVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZU1ldGhvZERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgcHJvcFR5cGUsXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbih7IGdlbmVyYXRvcjogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuVmFsdWUgPSBrZXkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIGtleS5uYW1lO1xuXG4gICAgICAgIGlmICh0b2tlblZhbHVlID09PSAnZ2V0JyAmJiAhbWF0Y2goJygnKSkge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXG4gICAgICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gcGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZU1ldGhvZERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgcHJvcFR5cGUsXG4gICAgICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHBhcnNlUHJvcGVydHlGdW5jdGlvbih7IGdlbmVyYXRvcjogZmFsc2UsIHJldHVyblR5cGU6IHJldHVyblR5cGUgfSksXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuVmFsdWUgPT09ICdzZXQnICYmICFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG5cbiAgICAgICAgICAgIGV4cGVjdCgnKCcpO1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICBwYXJhbSA9IFsgcGFyc2VUeXBlQW5ub3RhdGFibGVJZGVudGlmaWVyKCkgXTtcbiAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gcGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZU1ldGhvZERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgcHJvcFR5cGUsXG4gICAgICAgICAgICAgICAgJ3NldCcsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHBhcnNlUHJvcGVydHlGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlOiByZXR1cm5UeXBlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNBc3luYyA9IHRva2VuVmFsdWUgPT09ICdhc3luYycgJiYgIW1hdGNoKCcoJyk7XG4gICAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihcbiAgICAgICAgICAgIHByb3BUeXBlLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXN5bmM6IGlzQXN5bmMsXG4gICAgICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnM6IHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNvbXB1dGVkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDbGFzc1Byb3BlcnR5KGtleSwgY29tcHV0ZWQsIGlzU3RhdGljKSB7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbjtcblxuICAgICAgICB0eXBlQW5ub3RhdGlvbiA9IHBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgICAgZXhwZWN0KCc7Jyk7XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUNsYXNzUHJvcGVydHkoXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB0eXBlQW5ub3RhdGlvbixcbiAgICAgICAgICAgIGNvbXB1dGVkLFxuICAgICAgICAgICAgaXNTdGF0aWNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRWxlbWVudCgpIHtcbiAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2UsIGdlbmVyYXRvciA9IGZhbHNlLCBrZXksIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLFxuICAgICAgICAgICAgaXNTdGF0aWMgPSBmYWxzZSwgcG9zc2libHlPcGVuQnJhY2tldFRva2VuO1xuICAgICAgICBpZiAobWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC52YWx1ZSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCcqJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZ2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvc3NpYmx5T3BlbkJyYWNrZXRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2dldCcpIHx8IG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ3NldCcpKSB7XG4gICAgICAgICAgICBwb3NzaWJseU9wZW5CcmFja2V0VG9rZW4gPSBsb29rYWhlYWQyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zc2libHlPcGVuQnJhY2tldFRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3JcbiAgICAgICAgICAgICAgICAmJiBwb3NzaWJseU9wZW5CcmFja2V0VG9rZW4udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXG4gICAgICAgIGlmICghZ2VuZXJhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJzonKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBwYXJzZUNsYXNzUHJvcGVydHkoa2V5LCBjb21wdXRlZCwgaXNTdGF0aWMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIHBhcnNlTWV0aG9kRGVmaW5pdGlvbihcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGlzU3RhdGljLFxuICAgICAgICAgICAgZ2VuZXJhdG9yLFxuICAgICAgICAgICAgY29tcHV0ZWRcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDbGFzc0JvZHkoKSB7XG4gICAgICAgIHZhciBjbGFzc0VsZW1lbnQsIGNsYXNzRWxlbWVudHMgPSBbXSwgZXhpc3RpbmdQcm9wcyA9IHt9LFxuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksIHByb3BOYW1lLCBwcm9wVHlwZTtcblxuICAgICAgICBleGlzdGluZ1Byb3BzW0NsYXNzUHJvcGVydHlUeXBlLnN0YXRpY10gPSBuZXcgU3RyaW5nTWFwKCk7XG4gICAgICAgIGV4aXN0aW5nUHJvcHNbQ2xhc3NQcm9wZXJ0eVR5cGUucHJvdG90eXBlXSA9IG5ldyBTdHJpbmdNYXAoKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzc0VsZW1lbnQgPSBwYXJzZUNsYXNzRWxlbWVudChleGlzdGluZ1Byb3BzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGFzc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NFbGVtZW50cy5wdXNoKGNsYXNzRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBwcm9wTmFtZSA9ICFjbGFzc0VsZW1lbnQuY29tcHV0ZWQgJiYgZ2V0RmllbGROYW1lKGNsYXNzRWxlbWVudC5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFR5cGUgPSBjbGFzc0VsZW1lbnQuc3RhdGljID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3NQcm9wZXJ0eVR5cGUuc3RhdGljIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3NQcm9wZXJ0eVR5cGUucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc0VsZW1lbnQudHlwZSA9PT0gU3ludGF4Lk1ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiAhY2xhc3NFbGVtZW50LnN0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsTWV0aG9kKGNsYXNzRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihjbGFzc0VsZW1lbnQsIE1lc3NhZ2VzLklsbGVnYWxDbGFzc0NvbnN0cnVjdG9yUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQcm9wc1tDbGFzc1Byb3BlcnR5VHlwZS5wcm90b3R5cGVdLmhhcygnY29uc3RydWN0b3InKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGNsYXNzRWxlbWVudC5rZXksIE1lc3NhZ2VzLklsbGVnYWxEdXBsaWNhdGVDbGFzc1Byb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1Byb3BzW3Byb3BUeXBlXS5zZXQocHJvcE5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlQ2xhc3NCb2R5KGNsYXNzRWxlbWVudHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzSW1wbGVtZW50cygpIHtcbiAgICAgICAgdmFyIGlkLCBpbXBsZW1lbnRlZCA9IFtdLCBtYXJrZXIsIHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBleHBlY3RLZXl3b3JkKCdpbXBsZW1lbnRzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBlY3RDb250ZXh0dWFsS2V5d29yZCgnaW1wbGVtZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbXBsZW1lbnRlZC5wdXNoKG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlQ2xhc3NJbXBsZW1lbnRzKFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICApKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBsZW1lbnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGlkLCBpbXBsZW1lbnRlZCwgcHJldmlvdXNZaWVsZEFsbG93ZWQsIHN1cGVyQ2xhc3MgPSBudWxsLFxuICAgICAgICAgICAgc3VwZXJUeXBlUGFyYW1ldGVycywgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksIHR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgbWF0Y2hJbXBsZW1lbnRzO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XG5cbiAgICAgICAgbWF0Y2hJbXBsZW1lbnRzID1cbiAgICAgICAgICAgICAgICBzdHJpY3RcbiAgICAgICAgICAgICAgICA/IG1hdGNoS2V5d29yZCgnaW1wbGVtZW50cycpXG4gICAgICAgICAgICAgICAgOiBtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdpbXBsZW1lbnRzJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSAmJiAhbWF0Y2hJbXBsZW1lbnRzICYmICFtYXRjaCgneycpKSB7XG4gICAgICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XG4gICAgICAgICAgICBleHBlY3RLZXl3b3JkKCdleHRlbmRzJyk7XG4gICAgICAgICAgICBwcmV2aW91c1lpZWxkQWxsb3dlZCA9IHN0YXRlLnlpZWxkQWxsb3dlZDtcbiAgICAgICAgICAgIHN0YXRlLnlpZWxkQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc8JykpIHtcbiAgICAgICAgICAgICAgICBzdXBlclR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUueWllbGRBbGxvd2VkID0gcHJldmlvdXNZaWVsZEFsbG93ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0ID8gbWF0Y2hLZXl3b3JkKCdpbXBsZW1lbnRzJykgOiBtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdpbXBsZW1lbnRzJykpIHtcbiAgICAgICAgICAgIGltcGxlbWVudGVkID0gcGFyc2VDbGFzc0ltcGxlbWVudHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUNsYXNzRXhwcmVzc2lvbihcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc3VwZXJDbGFzcyxcbiAgICAgICAgICAgIHBhcnNlQ2xhc3NCb2R5KCksXG4gICAgICAgICAgICB0eXBlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN1cGVyVHlwZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpbXBsZW1lbnRlZFxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBpZCwgaW1wbGVtZW50ZWQsIHByZXZpb3VzWWllbGRBbGxvd2VkLCBzdXBlckNsYXNzID0gbnVsbCxcbiAgICAgICAgICAgIHN1cGVyVHlwZVBhcmFtZXRlcnMsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCB0eXBlUGFyYW1ldGVycztcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjbGFzcycpO1xuXG4gICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICBpZiAobWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XG4gICAgICAgICAgICBleHBlY3RLZXl3b3JkKCdleHRlbmRzJyk7XG4gICAgICAgICAgICBwcmV2aW91c1lpZWxkQWxsb3dlZCA9IHN0YXRlLnlpZWxkQWxsb3dlZDtcbiAgICAgICAgICAgIHN0YXRlLnlpZWxkQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc8JykpIHtcbiAgICAgICAgICAgICAgICBzdXBlclR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUueWllbGRBbGxvd2VkID0gcHJldmlvdXNZaWVsZEFsbG93ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0ID8gbWF0Y2hLZXl3b3JkKCdpbXBsZW1lbnRzJykgOiBtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdpbXBsZW1lbnRzJykpIHtcbiAgICAgICAgICAgIGltcGxlbWVudGVkID0gcGFyc2VDbGFzc0ltcGxlbWVudHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUNsYXNzRGVjbGFyYXRpb24oXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN1cGVyQ2xhc3MsXG4gICAgICAgICAgICBwYXJzZUNsYXNzQm9keSgpLFxuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdXBlclR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaW1wbGVtZW50ZWRcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgLy8gMTUgUHJvZ3JhbVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcbiAgICAgICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ29uc3RMZXREZWNsYXJhdGlvbihsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnREZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkMigpLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50ZXJmYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCd0eXBlJylcbiAgICAgICAgICAgICAgICAmJiBsb29rYWhlYWQyKCkudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHlwZUFsaWFzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnaW50ZXJmYWNlJylcbiAgICAgICAgICAgICAgICAmJiBsb29rYWhlYWQyKCkudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50ZXJmYWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZGVjbGFyZScpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDIoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGVjbGFyZUNsYXNzKCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEZWNsYXJlRnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjYXNlICd2YXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEZWNsYXJlVmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgJiYgdG9rZW4udmFsdWUgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGVjbGFyZU1vZHVsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtRWxlbWVudCgpIHtcbiAgICAgICAgdmFyIGlzTW9kdWxlID0gZXh0cmEuc291cmNlVHlwZSA9PT0gJ21vZHVsZScgfHwgZXh0cmEuc291cmNlVHlwZSA9PT0gJ25vblN0cmljdE1vZHVsZSc7XG5cbiAgICAgICAgaWYgKGlzTW9kdWxlICYmIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnREZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbUVsZW1lbnRzKCkge1xuICAgICAgICB2YXIgc291cmNlRWxlbWVudCwgc291cmNlRWxlbWVudHMgPSBbXSwgdG9rZW4sIGRpcmVjdGl2ZSwgZmlyc3RSZXN0cmljdGVkO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VQcm9ncmFtRWxlbWVudCgpO1xuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5yYW5nZVswXSArIDEsIHRva2VuLnJhbmdlWzFdIC0gMSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlUHJvZ3JhbUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZUVsZW1lbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSgpIHtcbiAgICAgICAgdmFyIGJvZHksIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBzdHJpY3QgPSBleHRyYS5zb3VyY2VUeXBlID09PSAnbW9kdWxlJztcbiAgICAgICAgcGVlaygpO1xuICAgICAgICBib2R5ID0gcGFyc2VQcm9ncmFtRWxlbWVudHMoKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlUHJvZ3JhbShib2R5KSk7XG4gICAgfVxuXG4gICAgLy8gMTYgSlNYXG5cbiAgICBYSFRNTEVudGl0aWVzID0ge1xuICAgICAgICBxdW90OiAnXFx1MDAyMicsXG4gICAgICAgIGFtcDogJyYnLFxuICAgICAgICBhcG9zOiAnXFx1MDAyNycsXG4gICAgICAgIGx0OiAnPCcsXG4gICAgICAgIGd0OiAnPicsXG4gICAgICAgIG5ic3A6ICdcXHUwMEEwJyxcbiAgICAgICAgaWV4Y2w6ICdcXHUwMEExJyxcbiAgICAgICAgY2VudDogJ1xcdTAwQTInLFxuICAgICAgICBwb3VuZDogJ1xcdTAwQTMnLFxuICAgICAgICBjdXJyZW46ICdcXHUwMEE0JyxcbiAgICAgICAgeWVuOiAnXFx1MDBBNScsXG4gICAgICAgIGJydmJhcjogJ1xcdTAwQTYnLFxuICAgICAgICBzZWN0OiAnXFx1MDBBNycsXG4gICAgICAgIHVtbDogJ1xcdTAwQTgnLFxuICAgICAgICBjb3B5OiAnXFx1MDBBOScsXG4gICAgICAgIG9yZGY6ICdcXHUwMEFBJyxcbiAgICAgICAgbGFxdW86ICdcXHUwMEFCJyxcbiAgICAgICAgbm90OiAnXFx1MDBBQycsXG4gICAgICAgIHNoeTogJ1xcdTAwQUQnLFxuICAgICAgICByZWc6ICdcXHUwMEFFJyxcbiAgICAgICAgbWFjcjogJ1xcdTAwQUYnLFxuICAgICAgICBkZWc6ICdcXHUwMEIwJyxcbiAgICAgICAgcGx1c21uOiAnXFx1MDBCMScsXG4gICAgICAgIHN1cDI6ICdcXHUwMEIyJyxcbiAgICAgICAgc3VwMzogJ1xcdTAwQjMnLFxuICAgICAgICBhY3V0ZTogJ1xcdTAwQjQnLFxuICAgICAgICBtaWNybzogJ1xcdTAwQjUnLFxuICAgICAgICBwYXJhOiAnXFx1MDBCNicsXG4gICAgICAgIG1pZGRvdDogJ1xcdTAwQjcnLFxuICAgICAgICBjZWRpbDogJ1xcdTAwQjgnLFxuICAgICAgICBzdXAxOiAnXFx1MDBCOScsXG4gICAgICAgIG9yZG06ICdcXHUwMEJBJyxcbiAgICAgICAgcmFxdW86ICdcXHUwMEJCJyxcbiAgICAgICAgZnJhYzE0OiAnXFx1MDBCQycsXG4gICAgICAgIGZyYWMxMjogJ1xcdTAwQkQnLFxuICAgICAgICBmcmFjMzQ6ICdcXHUwMEJFJyxcbiAgICAgICAgaXF1ZXN0OiAnXFx1MDBCRicsXG4gICAgICAgIEFncmF2ZTogJ1xcdTAwQzAnLFxuICAgICAgICBBYWN1dGU6ICdcXHUwMEMxJyxcbiAgICAgICAgQWNpcmM6ICdcXHUwMEMyJyxcbiAgICAgICAgQXRpbGRlOiAnXFx1MDBDMycsXG4gICAgICAgIEF1bWw6ICdcXHUwMEM0JyxcbiAgICAgICAgQXJpbmc6ICdcXHUwMEM1JyxcbiAgICAgICAgQUVsaWc6ICdcXHUwMEM2JyxcbiAgICAgICAgQ2NlZGlsOiAnXFx1MDBDNycsXG4gICAgICAgIEVncmF2ZTogJ1xcdTAwQzgnLFxuICAgICAgICBFYWN1dGU6ICdcXHUwMEM5JyxcbiAgICAgICAgRWNpcmM6ICdcXHUwMENBJyxcbiAgICAgICAgRXVtbDogJ1xcdTAwQ0InLFxuICAgICAgICBJZ3JhdmU6ICdcXHUwMENDJyxcbiAgICAgICAgSWFjdXRlOiAnXFx1MDBDRCcsXG4gICAgICAgIEljaXJjOiAnXFx1MDBDRScsXG4gICAgICAgIEl1bWw6ICdcXHUwMENGJyxcbiAgICAgICAgRVRIOiAnXFx1MDBEMCcsXG4gICAgICAgIE50aWxkZTogJ1xcdTAwRDEnLFxuICAgICAgICBPZ3JhdmU6ICdcXHUwMEQyJyxcbiAgICAgICAgT2FjdXRlOiAnXFx1MDBEMycsXG4gICAgICAgIE9jaXJjOiAnXFx1MDBENCcsXG4gICAgICAgIE90aWxkZTogJ1xcdTAwRDUnLFxuICAgICAgICBPdW1sOiAnXFx1MDBENicsXG4gICAgICAgIHRpbWVzOiAnXFx1MDBENycsXG4gICAgICAgIE9zbGFzaDogJ1xcdTAwRDgnLFxuICAgICAgICBVZ3JhdmU6ICdcXHUwMEQ5JyxcbiAgICAgICAgVWFjdXRlOiAnXFx1MDBEQScsXG4gICAgICAgIFVjaXJjOiAnXFx1MDBEQicsXG4gICAgICAgIFV1bWw6ICdcXHUwMERDJyxcbiAgICAgICAgWWFjdXRlOiAnXFx1MDBERCcsXG4gICAgICAgIFRIT1JOOiAnXFx1MDBERScsXG4gICAgICAgIHN6bGlnOiAnXFx1MDBERicsXG4gICAgICAgIGFncmF2ZTogJ1xcdTAwRTAnLFxuICAgICAgICBhYWN1dGU6ICdcXHUwMEUxJyxcbiAgICAgICAgYWNpcmM6ICdcXHUwMEUyJyxcbiAgICAgICAgYXRpbGRlOiAnXFx1MDBFMycsXG4gICAgICAgIGF1bWw6ICdcXHUwMEU0JyxcbiAgICAgICAgYXJpbmc6ICdcXHUwMEU1JyxcbiAgICAgICAgYWVsaWc6ICdcXHUwMEU2JyxcbiAgICAgICAgY2NlZGlsOiAnXFx1MDBFNycsXG4gICAgICAgIGVncmF2ZTogJ1xcdTAwRTgnLFxuICAgICAgICBlYWN1dGU6ICdcXHUwMEU5JyxcbiAgICAgICAgZWNpcmM6ICdcXHUwMEVBJyxcbiAgICAgICAgZXVtbDogJ1xcdTAwRUInLFxuICAgICAgICBpZ3JhdmU6ICdcXHUwMEVDJyxcbiAgICAgICAgaWFjdXRlOiAnXFx1MDBFRCcsXG4gICAgICAgIGljaXJjOiAnXFx1MDBFRScsXG4gICAgICAgIGl1bWw6ICdcXHUwMEVGJyxcbiAgICAgICAgZXRoOiAnXFx1MDBGMCcsXG4gICAgICAgIG50aWxkZTogJ1xcdTAwRjEnLFxuICAgICAgICBvZ3JhdmU6ICdcXHUwMEYyJyxcbiAgICAgICAgb2FjdXRlOiAnXFx1MDBGMycsXG4gICAgICAgIG9jaXJjOiAnXFx1MDBGNCcsXG4gICAgICAgIG90aWxkZTogJ1xcdTAwRjUnLFxuICAgICAgICBvdW1sOiAnXFx1MDBGNicsXG4gICAgICAgIGRpdmlkZTogJ1xcdTAwRjcnLFxuICAgICAgICBvc2xhc2g6ICdcXHUwMEY4JyxcbiAgICAgICAgdWdyYXZlOiAnXFx1MDBGOScsXG4gICAgICAgIHVhY3V0ZTogJ1xcdTAwRkEnLFxuICAgICAgICB1Y2lyYzogJ1xcdTAwRkInLFxuICAgICAgICB1dW1sOiAnXFx1MDBGQycsXG4gICAgICAgIHlhY3V0ZTogJ1xcdTAwRkQnLFxuICAgICAgICB0aG9ybjogJ1xcdTAwRkUnLFxuICAgICAgICB5dW1sOiAnXFx1MDBGRicsXG4gICAgICAgIE9FbGlnOiAnXFx1MDE1MicsXG4gICAgICAgIG9lbGlnOiAnXFx1MDE1MycsXG4gICAgICAgIFNjYXJvbjogJ1xcdTAxNjAnLFxuICAgICAgICBzY2Fyb246ICdcXHUwMTYxJyxcbiAgICAgICAgWXVtbDogJ1xcdTAxNzgnLFxuICAgICAgICBmbm9mOiAnXFx1MDE5MicsXG4gICAgICAgIGNpcmM6ICdcXHUwMkM2JyxcbiAgICAgICAgdGlsZGU6ICdcXHUwMkRDJyxcbiAgICAgICAgQWxwaGE6ICdcXHUwMzkxJyxcbiAgICAgICAgQmV0YTogJ1xcdTAzOTInLFxuICAgICAgICBHYW1tYTogJ1xcdTAzOTMnLFxuICAgICAgICBEZWx0YTogJ1xcdTAzOTQnLFxuICAgICAgICBFcHNpbG9uOiAnXFx1MDM5NScsXG4gICAgICAgIFpldGE6ICdcXHUwMzk2JyxcbiAgICAgICAgRXRhOiAnXFx1MDM5NycsXG4gICAgICAgIFRoZXRhOiAnXFx1MDM5OCcsXG4gICAgICAgIElvdGE6ICdcXHUwMzk5JyxcbiAgICAgICAgS2FwcGE6ICdcXHUwMzlBJyxcbiAgICAgICAgTGFtYmRhOiAnXFx1MDM5QicsXG4gICAgICAgIE11OiAnXFx1MDM5QycsXG4gICAgICAgIE51OiAnXFx1MDM5RCcsXG4gICAgICAgIFhpOiAnXFx1MDM5RScsXG4gICAgICAgIE9taWNyb246ICdcXHUwMzlGJyxcbiAgICAgICAgUGk6ICdcXHUwM0EwJyxcbiAgICAgICAgUmhvOiAnXFx1MDNBMScsXG4gICAgICAgIFNpZ21hOiAnXFx1MDNBMycsXG4gICAgICAgIFRhdTogJ1xcdTAzQTQnLFxuICAgICAgICBVcHNpbG9uOiAnXFx1MDNBNScsXG4gICAgICAgIFBoaTogJ1xcdTAzQTYnLFxuICAgICAgICBDaGk6ICdcXHUwM0E3JyxcbiAgICAgICAgUHNpOiAnXFx1MDNBOCcsXG4gICAgICAgIE9tZWdhOiAnXFx1MDNBOScsXG4gICAgICAgIGFscGhhOiAnXFx1MDNCMScsXG4gICAgICAgIGJldGE6ICdcXHUwM0IyJyxcbiAgICAgICAgZ2FtbWE6ICdcXHUwM0IzJyxcbiAgICAgICAgZGVsdGE6ICdcXHUwM0I0JyxcbiAgICAgICAgZXBzaWxvbjogJ1xcdTAzQjUnLFxuICAgICAgICB6ZXRhOiAnXFx1MDNCNicsXG4gICAgICAgIGV0YTogJ1xcdTAzQjcnLFxuICAgICAgICB0aGV0YTogJ1xcdTAzQjgnLFxuICAgICAgICBpb3RhOiAnXFx1MDNCOScsXG4gICAgICAgIGthcHBhOiAnXFx1MDNCQScsXG4gICAgICAgIGxhbWJkYTogJ1xcdTAzQkInLFxuICAgICAgICBtdTogJ1xcdTAzQkMnLFxuICAgICAgICBudTogJ1xcdTAzQkQnLFxuICAgICAgICB4aTogJ1xcdTAzQkUnLFxuICAgICAgICBvbWljcm9uOiAnXFx1MDNCRicsXG4gICAgICAgIHBpOiAnXFx1MDNDMCcsXG4gICAgICAgIHJobzogJ1xcdTAzQzEnLFxuICAgICAgICBzaWdtYWY6ICdcXHUwM0MyJyxcbiAgICAgICAgc2lnbWE6ICdcXHUwM0MzJyxcbiAgICAgICAgdGF1OiAnXFx1MDNDNCcsXG4gICAgICAgIHVwc2lsb246ICdcXHUwM0M1JyxcbiAgICAgICAgcGhpOiAnXFx1MDNDNicsXG4gICAgICAgIGNoaTogJ1xcdTAzQzcnLFxuICAgICAgICBwc2k6ICdcXHUwM0M4JyxcbiAgICAgICAgb21lZ2E6ICdcXHUwM0M5JyxcbiAgICAgICAgdGhldGFzeW06ICdcXHUwM0QxJyxcbiAgICAgICAgdXBzaWg6ICdcXHUwM0QyJyxcbiAgICAgICAgcGl2OiAnXFx1MDNENicsXG4gICAgICAgIGVuc3A6ICdcXHUyMDAyJyxcbiAgICAgICAgZW1zcDogJ1xcdTIwMDMnLFxuICAgICAgICB0aGluc3A6ICdcXHUyMDA5JyxcbiAgICAgICAgenduajogJ1xcdTIwMEMnLFxuICAgICAgICB6d2o6ICdcXHUyMDBEJyxcbiAgICAgICAgbHJtOiAnXFx1MjAwRScsXG4gICAgICAgIHJsbTogJ1xcdTIwMEYnLFxuICAgICAgICBuZGFzaDogJ1xcdTIwMTMnLFxuICAgICAgICBtZGFzaDogJ1xcdTIwMTQnLFxuICAgICAgICBsc3F1bzogJ1xcdTIwMTgnLFxuICAgICAgICByc3F1bzogJ1xcdTIwMTknLFxuICAgICAgICBzYnF1bzogJ1xcdTIwMUEnLFxuICAgICAgICBsZHF1bzogJ1xcdTIwMUMnLFxuICAgICAgICByZHF1bzogJ1xcdTIwMUQnLFxuICAgICAgICBiZHF1bzogJ1xcdTIwMUUnLFxuICAgICAgICBkYWdnZXI6ICdcXHUyMDIwJyxcbiAgICAgICAgRGFnZ2VyOiAnXFx1MjAyMScsXG4gICAgICAgIGJ1bGw6ICdcXHUyMDIyJyxcbiAgICAgICAgaGVsbGlwOiAnXFx1MjAyNicsXG4gICAgICAgIHBlcm1pbDogJ1xcdTIwMzAnLFxuICAgICAgICBwcmltZTogJ1xcdTIwMzInLFxuICAgICAgICBQcmltZTogJ1xcdTIwMzMnLFxuICAgICAgICBsc2FxdW86ICdcXHUyMDM5JyxcbiAgICAgICAgcnNhcXVvOiAnXFx1MjAzQScsXG4gICAgICAgIG9saW5lOiAnXFx1MjAzRScsXG4gICAgICAgIGZyYXNsOiAnXFx1MjA0NCcsXG4gICAgICAgIGV1cm86ICdcXHUyMEFDJyxcbiAgICAgICAgaW1hZ2U6ICdcXHUyMTExJyxcbiAgICAgICAgd2VpZXJwOiAnXFx1MjExOCcsXG4gICAgICAgIHJlYWw6ICdcXHUyMTFDJyxcbiAgICAgICAgdHJhZGU6ICdcXHUyMTIyJyxcbiAgICAgICAgYWxlZnN5bTogJ1xcdTIxMzUnLFxuICAgICAgICBsYXJyOiAnXFx1MjE5MCcsXG4gICAgICAgIHVhcnI6ICdcXHUyMTkxJyxcbiAgICAgICAgcmFycjogJ1xcdTIxOTInLFxuICAgICAgICBkYXJyOiAnXFx1MjE5MycsXG4gICAgICAgIGhhcnI6ICdcXHUyMTk0JyxcbiAgICAgICAgY3JhcnI6ICdcXHUyMUI1JyxcbiAgICAgICAgbEFycjogJ1xcdTIxRDAnLFxuICAgICAgICB1QXJyOiAnXFx1MjFEMScsXG4gICAgICAgIHJBcnI6ICdcXHUyMUQyJyxcbiAgICAgICAgZEFycjogJ1xcdTIxRDMnLFxuICAgICAgICBoQXJyOiAnXFx1MjFENCcsXG4gICAgICAgIGZvcmFsbDogJ1xcdTIyMDAnLFxuICAgICAgICBwYXJ0OiAnXFx1MjIwMicsXG4gICAgICAgIGV4aXN0OiAnXFx1MjIwMycsXG4gICAgICAgIGVtcHR5OiAnXFx1MjIwNScsXG4gICAgICAgIG5hYmxhOiAnXFx1MjIwNycsXG4gICAgICAgIGlzaW46ICdcXHUyMjA4JyxcbiAgICAgICAgbm90aW46ICdcXHUyMjA5JyxcbiAgICAgICAgbmk6ICdcXHUyMjBCJyxcbiAgICAgICAgcHJvZDogJ1xcdTIyMEYnLFxuICAgICAgICBzdW06ICdcXHUyMjExJyxcbiAgICAgICAgbWludXM6ICdcXHUyMjEyJyxcbiAgICAgICAgbG93YXN0OiAnXFx1MjIxNycsXG4gICAgICAgIHJhZGljOiAnXFx1MjIxQScsXG4gICAgICAgIHByb3A6ICdcXHUyMjFEJyxcbiAgICAgICAgaW5maW46ICdcXHUyMjFFJyxcbiAgICAgICAgYW5nOiAnXFx1MjIyMCcsXG4gICAgICAgIGFuZDogJ1xcdTIyMjcnLFxuICAgICAgICBvcjogJ1xcdTIyMjgnLFxuICAgICAgICBjYXA6ICdcXHUyMjI5JyxcbiAgICAgICAgY3VwOiAnXFx1MjIyQScsXG4gICAgICAgICdpbnQnOiAnXFx1MjIyQicsXG4gICAgICAgIHRoZXJlNDogJ1xcdTIyMzQnLFxuICAgICAgICBzaW06ICdcXHUyMjNDJyxcbiAgICAgICAgY29uZzogJ1xcdTIyNDUnLFxuICAgICAgICBhc3ltcDogJ1xcdTIyNDgnLFxuICAgICAgICBuZTogJ1xcdTIyNjAnLFxuICAgICAgICBlcXVpdjogJ1xcdTIyNjEnLFxuICAgICAgICBsZTogJ1xcdTIyNjQnLFxuICAgICAgICBnZTogJ1xcdTIyNjUnLFxuICAgICAgICBzdWI6ICdcXHUyMjgyJyxcbiAgICAgICAgc3VwOiAnXFx1MjI4MycsXG4gICAgICAgIG5zdWI6ICdcXHUyMjg0JyxcbiAgICAgICAgc3ViZTogJ1xcdTIyODYnLFxuICAgICAgICBzdXBlOiAnXFx1MjI4NycsXG4gICAgICAgIG9wbHVzOiAnXFx1MjI5NScsXG4gICAgICAgIG90aW1lczogJ1xcdTIyOTcnLFxuICAgICAgICBwZXJwOiAnXFx1MjJBNScsXG4gICAgICAgIHNkb3Q6ICdcXHUyMkM1JyxcbiAgICAgICAgbGNlaWw6ICdcXHUyMzA4JyxcbiAgICAgICAgcmNlaWw6ICdcXHUyMzA5JyxcbiAgICAgICAgbGZsb29yOiAnXFx1MjMwQScsXG4gICAgICAgIHJmbG9vcjogJ1xcdTIzMEInLFxuICAgICAgICBsYW5nOiAnXFx1MjMyOScsXG4gICAgICAgIHJhbmc6ICdcXHUyMzJBJyxcbiAgICAgICAgbG96OiAnXFx1MjVDQScsXG4gICAgICAgIHNwYWRlczogJ1xcdTI2NjAnLFxuICAgICAgICBjbHViczogJ1xcdTI2NjMnLFxuICAgICAgICBoZWFydHM6ICdcXHUyNjY1JyxcbiAgICAgICAgZGlhbXM6ICdcXHUyNjY2J1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LnR5cGUgPT09IFN5bnRheC5KU1hJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50eXBlID09PSBTeW50YXguSlNYTmFtZXNwYWNlZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZXNwYWNlLm5hbWUgKyAnOicgKyBvYmplY3QubmFtZS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChvYmplY3QudHlwZSA9PT0gU3ludGF4LkpTWE1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgZ2V0UXVhbGlmaWVkSlNYTmFtZShvYmplY3Qub2JqZWN0KSArICcuJyArXG4gICAgICAgICAgICAgICAgZ2V0UXVhbGlmaWVkSlNYTmFtZShvYmplY3QucHJvcGVydHkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93VW5leHBlY3RlZChvYmplY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSlNYSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgYmFja3NsYXNoIChcXClcbiAgICAgICAgcmV0dXJuIChjaCAhPT0gOTIpICYmIGlzSWRlbnRpZmllclN0YXJ0KGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0pTWElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgYmFja3NsYXNoIChcXCkgYW5kIGFkZCBoeXBoZW4gKC0pXG4gICAgICAgIHJldHVybiAoY2ggIT09IDkyKSAmJiAoY2ggPT09IDQ1IHx8IGlzSWRlbnRpZmllclBhcnQoY2gpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSlNYSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIGNoLCBzdGFydCwgdmFsdWUgPSAnJztcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFpc0pTWElkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLkpTWElkZW50aWZpZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSlNYRW50aXR5KCkge1xuICAgICAgICB2YXIgY2gsIHN0ciA9ICcnLCBzdGFydCA9IGluZGV4LCBjb3VudCA9IDAsIGNvZGU7XG4gICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KGNoID09PSAnJicsICdFbnRpdHkgbXVzdCBzdGFydCB3aXRoIGFuIGFtcGVyc2FuZCcpO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGggJiYgY291bnQrKyA8IDEwKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZWxsLWZvcm1lZCBlbnRpdHkgKGVuZGluZyB3YXMgZm91bmQpLlxuICAgICAgICBpZiAoY2ggPT09ICc7Jykge1xuICAgICAgICAgICAgLy8gTnVtZXJpYyBlbnRpdHkuXG4gICAgICAgICAgICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyWzFdID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICsoJzAnICsgc3RyLnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZpbmcgbGVhZGluZyB6ZXJvcyBpbiBvcmRlciB0byBhdm9pZCB0cmVhdGluZyBhcyBvY3RhbCBpbiBvbGQgYnJvd3NlcnMuXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSArc3RyLnN1YnN0cigxKS5yZXBsYWNlKFJlZ2V4LkxlYWRpbmdaZXJvcywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoWEhUTUxFbnRpdGllc1tzdHJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFhIVE1MRW50aXRpZXNbc3RyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyZWF0IG5vbi1lbnRpdHkgc2VxdWVuY2VzIGFzIHJlZ3VsYXIgdGV4dC5cbiAgICAgICAgaW5kZXggPSBzdGFydCArIDE7XG4gICAgICAgIHJldHVybiAnJic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkpTWFRleHQoc3RvcENoYXJzKSB7XG4gICAgICAgIHZhciBjaCwgc3RyID0gJycsIHN0YXJ0O1xuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdG9wQ2hhcnMuaW5kZXhPZihjaCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcmJykge1xuICAgICAgICAgICAgICAgIHN0ciArPSBzY2FuSlNYRW50aXR5KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5KU1hUZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHN0cixcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5KU1hTdHJpbmdMaXRlcmFsKCkge1xuICAgICAgICB2YXIgaW5uZXJUb2tlbiwgcXVvdGUsIHN0YXJ0O1xuXG4gICAgICAgIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgaW5uZXJUb2tlbiA9IHNjYW5KU1hUZXh0KFtxdW90ZV0pO1xuXG4gICAgICAgIGlmIChxdW90ZSAhPT0gc291cmNlW2luZGV4XSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICBpbm5lclRva2VuLnJhbmdlID0gW3N0YXJ0LCBpbmRleF07XG5cbiAgICAgICAgcmV0dXJuIGlubmVyVG9rZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmV0d2VlbiBKU1ggb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIChlLmcuIDxmb28+SEVSRTwvZm9vPiksIGFueXRoaW5nIHRoYXRcbiAgICAgKiBpcyBub3QgYW5vdGhlciBKU1ggdGFnIGFuZCBpcyBub3QgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGJ5IHt9IGlzIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWR2YW5jZUpTWENoaWxkKCkge1xuICAgICAgICB2YXIgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgLy8gJzwnIDYwLCAnPicgNjIsICd7JyAxMjMsICd9JyAxMjVcbiAgICAgICAgaWYgKGNoICE9PSA2MCAmJiBjaCAhPT0gNjIgJiYgY2ggIT09IDEyMyAmJiBjaCAhPT0gMTI1KSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbkpTWFRleHQoWyc8JywgJz4nLCAneycsICd9J10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU1hJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgdG9rZW4sIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uSlNYSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVKU1hJZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU1hOYW1lc3BhY2VkTmFtZSgpIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSwgbmFtZSwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgbmFtZXNwYWNlID0gcGFyc2VKU1hJZGVudGlmaWVyKCk7XG4gICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICBuYW1lID0gcGFyc2VKU1hJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU1hNZW1iZXJFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksXG4gICAgICAgICAgICBleHByID0gcGFyc2VKU1hJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSlNYTWVtYmVyRXhwcmVzc2lvbihleHByLCBwYXJzZUpTWElkZW50aWZpZXIoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU1hFbGVtZW50TmFtZSgpIHtcbiAgICAgICAgaWYgKGxvb2thaGVhZDIoKS52YWx1ZSA9PT0gJzonKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VKU1hOYW1lc3BhY2VkTmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rYWhlYWQyKCkudmFsdWUgPT09ICcuJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSlNYTWVtYmVyRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSlNYSWRlbnRpZmllcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNYQXR0cmlidXRlTmFtZSgpIHtcbiAgICAgICAgaWYgKGxvb2thaGVhZDIoKS52YWx1ZSA9PT0gJzonKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VKU1hOYW1lc3BhY2VkTmFtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSlNYSWRlbnRpZmllcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNYQXR0cmlidXRlVmFsdWUoKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgbWFya2VyO1xuICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5KU1hFbXB0eUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ0pTWCBhdHRyaWJ1dGVzIG11c3Qgb25seSBiZSBhc3NpZ25lZCBhIG5vbi1lbXB0eSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdleHByZXNzaW9uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUpTWEVsZW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSlNYVGV4dCkge1xuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlTGl0ZXJhbChsZXgoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZEpTWEF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU1hFbXB0eUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJDcmVhdGVQcmVzZXJ2ZVdoaXRlc3BhY2UoKTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZS5jaGFyQXQoaW5kZXgpICE9PSAnfScpIHtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSlNYRW1wdHlFeHByZXNzaW9uKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lcigpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24sIG9yaWdJbkpTWENoaWxkLCBvcmlnSW5KU1hUYWcsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIG9yaWdJbkpTWENoaWxkID0gc3RhdGUuaW5KU1hDaGlsZDtcbiAgICAgICAgb3JpZ0luSlNYVGFnID0gc3RhdGUuaW5KU1hUYWc7XG4gICAgICAgIHN0YXRlLmluSlNYQ2hpbGQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5KU1hUYWcgPSBmYWxzZTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlSlNYRW1wdHlFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5pbkpTWENoaWxkID0gb3JpZ0luSlNYQ2hpbGQ7XG4gICAgICAgIHN0YXRlLmluSlNYVGFnID0gb3JpZ0luSlNYVGFnO1xuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNYU3ByZWFkQXR0cmlidXRlKCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiwgb3JpZ0luSlNYQ2hpbGQsIG9yaWdJbkpTWFRhZywgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgb3JpZ0luSlNYQ2hpbGQgPSBzdGF0ZS5pbkpTWENoaWxkO1xuICAgICAgICBvcmlnSW5KU1hUYWcgPSBzdGF0ZS5pbkpTWFRhZztcbiAgICAgICAgc3RhdGUuaW5KU1hDaGlsZCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbkpTWFRhZyA9IGZhbHNlO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICBleHBlY3QoJy4uLicpO1xuXG4gICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgc3RhdGUuaW5KU1hDaGlsZCA9IG9yaWdJbkpTWENoaWxkO1xuICAgICAgICBzdGF0ZS5pbkpTWFRhZyA9IG9yaWdJbkpTWFRhZztcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVKU1hTcHJlYWRBdHRyaWJ1dGUoZXhwcmVzc2lvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNYQXR0cmlidXRlKCkge1xuICAgICAgICB2YXIgbmFtZSwgbWFya2VyO1xuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuXG4gICAgICAgIG5hbWUgPSBwYXJzZUpTWEF0dHJpYnV0ZU5hbWUoKTtcblxuICAgICAgICAvLyBIVE1MIGVtcHR5IGF0dHJpYnV0ZVxuICAgICAgICBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVKU1hBdHRyaWJ1dGUobmFtZSwgcGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVKU1hBdHRyaWJ1dGUobmFtZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSlNYQ2hpbGQoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbWFya2VyO1xuICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgdG9rZW4gPSBwYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSlNYVGV4dCkge1xuICAgICAgICAgICAgbWFya2VyID0gbWFya2VyQ3JlYXRlUHJlc2VydmVXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICB0b2tlbiA9IG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlTGl0ZXJhbChsZXgoKSkpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCc8JykpIHtcbiAgICAgICAgICAgIHRva2VuID0gcGFyc2VKU1hFbGVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU1hDbG9zaW5nRWxlbWVudCgpIHtcbiAgICAgICAgdmFyIG5hbWUsIG9yaWdJbkpTWENoaWxkLCBvcmlnSW5KU1hUYWcsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBvcmlnSW5KU1hDaGlsZCA9IHN0YXRlLmluSlNYQ2hpbGQ7XG4gICAgICAgIG9yaWdJbkpTWFRhZyA9IHN0YXRlLmluSlNYVGFnO1xuICAgICAgICBzdGF0ZS5pbkpTWENoaWxkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluSlNYVGFnID0gdHJ1ZTtcbiAgICAgICAgZXhwZWN0KCc8Jyk7XG4gICAgICAgIGV4cGVjdCgnLycpO1xuICAgICAgICBuYW1lID0gcGFyc2VKU1hFbGVtZW50TmFtZSgpO1xuICAgICAgICAvLyBCZWNhdXNlIGFkdmFuY2UoKSAoY2FsbGVkIGJ5IGxleCgpIGNhbGxlZCBieSBleHBlY3QoKSkgZXhwZWN0cyB0aGVyZVxuICAgICAgICAvLyB0byBiZSBhIHZhbGlkIHRva2VuIGFmdGVyID4sIGl0IG5lZWRzIHRvIGtub3cgd2hldGhlciB0byBsb29rIGZvciBhXG4gICAgICAgIC8vIHN0YW5kYXJkIEpTIHRva2VuIG9yIGFuIEpTWCB0ZXh0IG5vZGVcbiAgICAgICAgc3RhdGUuaW5KU1hDaGlsZCA9IG9yaWdJbkpTWENoaWxkO1xuICAgICAgICBzdGF0ZS5pbkpTWFRhZyA9IG9yaWdJbkpTWFRhZztcbiAgICAgICAgZXhwZWN0KCc+Jyk7XG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUpTWENsb3NpbmdFbGVtZW50KG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUpTWE9wZW5pbmdFbGVtZW50KCkge1xuICAgICAgICB2YXIgbmFtZSwgYXR0cmlidXRlcyA9IFtdLCBzZWxmQ2xvc2luZyA9IGZhbHNlLCBvcmlnSW5KU1hDaGlsZCwgb3JpZ0luSlNYVGFnLCBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcblxuICAgICAgICBvcmlnSW5KU1hDaGlsZCA9IHN0YXRlLmluSlNYQ2hpbGQ7XG4gICAgICAgIG9yaWdJbkpTWFRhZyA9IHN0YXRlLmluSlNYVGFnO1xuICAgICAgICBzdGF0ZS5pbkpTWENoaWxkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluSlNYVGFnID0gdHJ1ZTtcblxuICAgICAgICBleHBlY3QoJzwnKTtcblxuICAgICAgICBuYW1lID0gcGFyc2VKU1hFbGVtZW50TmFtZSgpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGxvb2thaGVhZC52YWx1ZSAhPT0gJy8nICYmXG4gICAgICAgICAgICAgICAgbG9va2FoZWFkLnZhbHVlICE9PSAnPicpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChwYXJzZUpTWEF0dHJpYnV0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmluSlNYVGFnID0gb3JpZ0luSlNYVGFnO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudmFsdWUgPT09ICcvJykge1xuICAgICAgICAgICAgZXhwZWN0KCcvJyk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGFkdmFuY2UoKSAoY2FsbGVkIGJ5IGxleCgpIGNhbGxlZCBieSBleHBlY3QoKSkgZXhwZWN0c1xuICAgICAgICAgICAgLy8gdGhlcmUgdG8gYmUgYSB2YWxpZCB0b2tlbiBhZnRlciA+LCBpdCBuZWVkcyB0byBrbm93IHdoZXRoZXIgdG9cbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIGEgc3RhbmRhcmQgSlMgdG9rZW4gb3IgYW4gSlNYIHRleHQgbm9kZVxuICAgICAgICAgICAgc3RhdGUuaW5KU1hDaGlsZCA9IG9yaWdJbkpTWENoaWxkO1xuICAgICAgICAgICAgZXhwZWN0KCc+Jyk7XG4gICAgICAgICAgICBzZWxmQ2xvc2luZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5pbkpTWENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGV4cGVjdCgnPicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHNlbGZDbG9zaW5nKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VKU1hFbGVtZW50KCkge1xuICAgICAgICB2YXIgb3BlbmluZ0VsZW1lbnQsIGNsb3NpbmdFbGVtZW50ID0gbnVsbCwgY2hpbGRyZW4gPSBbXSwgb3JpZ0luSlNYQ2hpbGQsIG9yaWdJbkpTWFRhZywgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgb3JpZ0luSlNYQ2hpbGQgPSBzdGF0ZS5pbkpTWENoaWxkO1xuICAgICAgICBvcmlnSW5KU1hUYWcgPSBzdGF0ZS5pbkpTWFRhZztcbiAgICAgICAgb3BlbmluZ0VsZW1lbnQgPSBwYXJzZUpTWE9wZW5pbmdFbGVtZW50KCk7XG5cbiAgICAgICAgaWYgKCFvcGVuaW5nRWxlbWVudC5zZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5KU1hDaGlsZCA9IGZhbHNlOyAvLyBDYWxsIGxvb2thaGVhZDIoKSB3aXRoIGluSlNYQ2hpbGQgPSBmYWxzZSBiZWNhdXNlIDwvIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBpbiB0aGUgY2hpbGRcbiAgICAgICAgICAgICAgICBpZiAobG9va2FoZWFkLnZhbHVlID09PSAnPCcgJiYgbG9va2FoZWFkMigpLnZhbHVlID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmluSlNYQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gocGFyc2VKU1hDaGlsZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmluSlNYQ2hpbGQgPSBvcmlnSW5KU1hDaGlsZDtcbiAgICAgICAgICAgIHN0YXRlLmluSlNYVGFnID0gb3JpZ0luSlNYVGFnO1xuICAgICAgICAgICAgY2xvc2luZ0VsZW1lbnQgPSBwYXJzZUpTWENsb3NpbmdFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZ2V0UXVhbGlmaWVkSlNYTmFtZShjbG9zaW5nRWxlbWVudC5uYW1lKSAhPT0gZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkV4cGVjdGVkSlNYQ2xvc2luZ1RhZywgZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIChlcnJvbmVvdXNseSkgd3JpdGluZyB0d28gYWRqYWNlbnQgdGFncyBsaWtlXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICB2YXIgeCA9IDxkaXY+b25lPC9kaXY+PGRpdj50d288L2Rpdj47XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoZSBkZWZhdWx0IGVycm9yIG1lc3NhZ2UgaXMgYSBiaXQgaW5jb21wcmVoZW5zaWJsZS4gU2luY2UgaXQnc1xuICAgICAgICAvLyByYXJlbHkgKG5ldmVyPykgdXNlZnVsIHRvIHdyaXRlIGEgbGVzcy10aGFuIHNpZ24gYWZ0ZXIgYW4gSlNYXG4gICAgICAgIC8vIGVsZW1lbnQsIHdlIGRpc2FsbG93IGl0IGhlcmUgaW4gdGhlIHBhcnNlciBpbiBvcmRlciB0byBwcm92aWRlIGFcbiAgICAgICAgLy8gYmV0dGVyIGVycm9yIG1lc3NhZ2UuIChJbiB0aGUgcmFyZSBjYXNlIHRoYXQgdGhlIGxlc3MtdGhhbiBvcGVyYXRvclxuICAgICAgICAvLyB3YXMgaW50ZW5kZWQsIHRoZSBsZWZ0IHRhZyBjYW4gYmUgd3JhcHBlZCBpbiBwYXJlbnRoZXNlcy4pXG4gICAgICAgIGlmICghb3JpZ0luSlNYQ2hpbGQgJiYgbWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQsIE1lc3NhZ2VzLkFkamFjZW50SlNYRWxlbWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSlNYRWxlbWVudChvcGVuaW5nRWxlbWVudCwgY2xvc2luZ0VsZW1lbnQsIGNoaWxkcmVuKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlQWxpYXMoKSB7XG4gICAgICAgIHZhciBpZCwgbWFya2VyID0gbWFya2VyQ3JlYXRlKCksIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgcmlnaHQ7XG4gICAgICAgIGV4cGVjdENvbnRleHR1YWxLZXl3b3JkKCd0eXBlJyk7XG4gICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKG1hdGNoKCc8JykpIHtcbiAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgcmlnaHQgPSBwYXJzZVR5cGUoKTtcbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVUeXBlQWxpYXMoaWQsIHR5cGVQYXJhbWV0ZXJzLCByaWdodCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW50ZXJmYWNlRXh0ZW5kcygpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCBpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuXG4gICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKG1hdGNoKCc8JykpIHtcbiAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlSW50ZXJmYWNlRXh0ZW5kcyhcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnNcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnRlcmZhY2Vpc2gobWFya2VyLCBhbGxvd1N0YXRpYykge1xuICAgICAgICB2YXIgYm9keSwgYm9keU1hcmtlciwgZXh0ZW5kZWQgPSBbXSwgaWQsXG4gICAgICAgICAgICB0eXBlUGFyYW1ldGVycyA9IG51bGw7XG5cbiAgICAgICAgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAobWF0Y2goJzwnKSkge1xuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XG4gICAgICAgICAgICBleHBlY3RLZXl3b3JkKCdleHRlbmRzJyk7XG5cbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkLnB1c2gocGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBib2R5TWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG4gICAgICAgIGJvZHkgPSBtYXJrZXJBcHBseShib2R5TWFya2VyLCBwYXJzZU9iamVjdFR5cGUoYWxsb3dTdGF0aWMpKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVJbnRlcmZhY2UoXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGV4dGVuZGVkXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW50ZXJmYWNlKCkge1xuICAgICAgICB2YXIgbWFya2VyID0gbWFya2VyQ3JlYXRlKCk7XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgZXhwZWN0S2V5d29yZCgnaW50ZXJmYWNlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBlY3RDb250ZXh0dWFsS2V5d29yZCgnaW50ZXJmYWNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VJbnRlcmZhY2Vpc2gobWFya2VyLCAvKiBhbGxvd1N0YXRpYyAqL2ZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZURlY2xhcmVDbGFzcygpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCByZXQ7XG4gICAgICAgIGV4cGVjdENvbnRleHR1YWxLZXl3b3JkKCdkZWNsYXJlJyk7XG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XG5cbiAgICAgICAgcmV0ID0gcGFyc2VJbnRlcmZhY2Vpc2gobWFya2VyLCAvKiBhbGxvd1N0YXRpYyAqL3RydWUpO1xuICAgICAgICByZXQudHlwZSA9IFN5bnRheC5EZWNsYXJlQ2xhc3M7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VEZWNsYXJlRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCwgaWRNYXJrZXIsXG4gICAgICAgICAgICBtYXJrZXIgPSBtYXJrZXJDcmVhdGUoKSwgcGFyYW1zLCByZXR1cm5UeXBlLCByZXN0LCB0bXAsXG4gICAgICAgICAgICB0eXBlUGFyYW1ldGVycyA9IG51bGwsIHZhbHVlLCB2YWx1ZU1hcmtlcjtcblxuICAgICAgICBleHBlY3RDb250ZXh0dWFsS2V5d29yZCgnZGVjbGFyZScpO1xuICAgICAgICBleHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuICAgICAgICBpZE1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgdmFsdWVNYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcbiAgICAgICAgaWYgKG1hdGNoKCc8JykpIHtcbiAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgdG1wID0gcGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKTtcbiAgICAgICAgcGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgcmVzdCA9IHRtcC5yZXN0O1xuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgcmV0dXJuVHlwZSA9IHBhcnNlVHlwZSgpO1xuXG4gICAgICAgIHZhbHVlID0gbWFya2VyQXBwbHkodmFsdWVNYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUZ1bmN0aW9uVHlwZUFubm90YXRpb24oXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICByZXR1cm5UeXBlLFxuICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICkpO1xuXG4gICAgICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gbWFya2VyQXBwbHkodmFsdWVNYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZVR5cGVBbm5vdGF0aW9uKFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgKSk7XG4gICAgICAgIG1hcmtlckFwcGx5KGlkTWFya2VyLCBpZCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBtYXJrZXJBcHBseShtYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZURlY2xhcmVGdW5jdGlvbihcbiAgICAgICAgICAgIGlkXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRGVjbGFyZVZhcmlhYmxlKCkge1xuICAgICAgICB2YXIgaWQsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpO1xuICAgICAgICBleHBlY3RDb250ZXh0dWFsS2V5d29yZCgnZGVjbGFyZScpO1xuICAgICAgICBleHBlY3RLZXl3b3JkKCd2YXInKTtcbiAgICAgICAgaWQgPSBwYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlckFwcGx5KG1hcmtlciwgZGVsZWdhdGUuY3JlYXRlRGVjbGFyZVZhcmlhYmxlKFxuICAgICAgICAgICAgaWRcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VEZWNsYXJlTW9kdWxlKCkge1xuICAgICAgICB2YXIgYm9keSA9IFtdLCBib2R5TWFya2VyLCBpZCwgaWRNYXJrZXIsIG1hcmtlciA9IG1hcmtlckNyZWF0ZSgpLCB0b2tlbjtcbiAgICAgICAgZXhwZWN0Q29udGV4dHVhbEtleXdvcmQoJ2RlY2xhcmUnKTtcbiAgICAgICAgZXhwZWN0Q29udGV4dHVhbEtleXdvcmQoJ21vZHVsZScpO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBsb29rYWhlYWQub2N0YWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQobG9va2FoZWFkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRNYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcbiAgICAgICAgICAgIGlkID0gbWFya2VyQXBwbHkoaWRNYXJrZXIsIGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwobGV4KCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHlNYXJrZXIgPSBtYXJrZXJDcmVhdGUoKTtcbiAgICAgICAgZXhwZWN0KCd7Jyk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKHBhcnNlRGVjbGFyZUNsYXNzKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIGJvZHkucHVzaChwYXJzZURlY2xhcmVGdW5jdGlvbigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKHBhcnNlRGVjbGFyZVZhcmlhYmxlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyQXBwbHkobWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVEZWNsYXJlTW9kdWxlKFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBtYXJrZXJBcHBseShib2R5TWFya2VyLCBkZWxlZ2F0ZS5jcmVhdGVCbG9ja1N0YXRlbWVudChib2R5KSlcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFRva2VuKCkge1xuICAgICAgICB2YXIgbG9jLCB0b2tlbiwgcmFuZ2UsIHZhbHVlLCBlbnRyeTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoIXN0YXRlLmluSlNYQ2hpbGQpIHtcbiAgICAgICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRva2VuID0gZXh0cmEuYWR2YW5jZSgpO1xuICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICByYW5nZSA9IFt0b2tlbi5yYW5nZVswXSwgdG9rZW4ucmFuZ2VbMV1dO1xuICAgICAgICAgICAgdmFsdWUgPSBzb3VyY2Uuc2xpY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKTtcbiAgICAgICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHRva2VuLnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiB0b2tlbi5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFJlZ2V4KCkge1xuICAgICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2V4ID0gZXh0cmEuc2NhblJlZ0V4cCgpO1xuICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy8nIHx8IHRva2VuLnZhbHVlID09PSAnLz0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUmVndWxhckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiByZWdleC5yZWdleCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3BvcywgaW5kZXhdLFxuICAgICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJUb2tlbkxvY2F0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmEudG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGV4dHJhLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGVudHJ5LnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBlbnRyeS5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5yYW5nZSA9IGVudHJ5LnJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICAgIHRva2VuLmxvYyA9IGVudHJ5LmxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLnRva2VucyA9IHRva2VucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXRjaCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBleHRyYS5hZHZhbmNlID0gYWR2YW5jZTtcbiAgICAgICAgICAgIGV4dHJhLnNjYW5SZWdFeHAgPSBzY2FuUmVnRXhwO1xuXG4gICAgICAgICAgICBhZHZhbmNlID0gY29sbGVjdFRva2VuO1xuICAgICAgICAgICAgc2NhblJlZ0V4cCA9IGNvbGxlY3RSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVucGF0Y2goKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmEuc2NhblJlZ0V4cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYWR2YW5jZSA9IGV4dHJhLmFkdmFuY2U7XG4gICAgICAgICAgICBzY2FuUmVnRXhwID0gZXh0cmEuc2NhblJlZ0V4cDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBtb2RpZnkgdGhlIGRlbGVnYXRlLlxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKG9iamVjdCwgcHJvcGVydGllcykge1xuICAgICAgICB2YXIgZW50cnksIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAoZW50cnkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbZW50cnldID0gb2JqZWN0W2VudHJ5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoZW50cnkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtlbnRyeV0gPSBwcm9wZXJ0aWVzW2VudHJ5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5pemUoY29kZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdG9TdHJpbmcsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHRva2VucztcblxuICAgICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxlZ2F0ZSA9IFN5bnRheFRyZWVEZWxlZ2F0ZTtcbiAgICAgICAgc291cmNlID0gY29kZTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGFsbG93S2V5d29yZDogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICBsYWJlbFNldDogbmV3IFN0cmluZ01hcCgpLFxuICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgICAgfTtcblxuICAgICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAgIC8vIE9wdGlvbnMgbWF0Y2hpbmcuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgICBvcHRpb25zLnRva2VucyA9IHRydWU7XG4gICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcbiAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0Y2goKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGVlaygpO1xuICAgICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmEudG9rZW5zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgd2hpbGUgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChsZXhFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGJyZWFrIG9uIHRoZSBmaXJzdCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGxleEVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgICB0b2tlbnMgPSBleHRyYS50b2tlbnM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmNvbW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRva2Vucy5jb21tZW50cyA9IGV4dHJhLmNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHVucGF0Y2goKTtcbiAgICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwcm9ncmFtLCB0b1N0cmluZztcblxuICAgICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxlZ2F0ZSA9IFN5bnRheFRyZWVEZWxlZ2F0ZTtcbiAgICAgICAgc291cmNlID0gY29kZTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGFsbG93S2V5d29yZDogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTZXQ6IG5ldyBTdHJpbmdNYXAoKSxcbiAgICAgICAgICAgIHBhcmVudGhlc2l6ZWRDb3VudDogMCxcbiAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGluSlNYQ2hpbGQ6IGZhbHNlLFxuICAgICAgICAgICAgaW5KU1hUYWc6IGZhbHNlLFxuICAgICAgICAgICAgaW5UeXBlOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xLFxuICAgICAgICAgICAgeWllbGRBbGxvd2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGF3YWl0QWxsb3dlZDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcbiAgICAgICAgICAgIGV4dHJhLmF0dGFjaENvbW1lbnQgPSAodHlwZW9mIG9wdGlvbnMuYXR0YWNoQ29tbWVudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmF0dGFjaENvbW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MgJiYgb3B0aW9ucy5zb3VyY2UgIT09IG51bGwgJiYgb3B0aW9ucy5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGVnYXRlID0gZXh0ZW5kKGRlbGVnYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0UHJvY2Vzcyc6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxvYy5zb3VyY2UgPSB0b1N0cmluZyhvcHRpb25zLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYS5zb3VyY2VUeXBlID0gb3B0aW9ucy5zb3VyY2VUeXBlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRva2VucyA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGV4dHJhLmNvbW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRvbGVyYW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIGV4dHJhLnJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhLmJvdHRvbVJpZ2h0U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXRjaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5jb21tZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS50b2tlbnMgPSBleHRyYS50b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHVucGF0Y2goKTtcbiAgICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICAvLyBTeW5jIHdpdGggKi5qc29uIG1hbmlmZXN0cy5cbiAgICBleHBvcnRzLnZlcnNpb24gPSAnMTMwMDEuMTAwMS4wLWRldi1oYXJtb255LWZiJztcblxuICAgIGV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcblxuICAgIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICAgIC8vIERlZXAgY29weS5cbiAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZXhwb3J0cy5TeW50YXggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZSwgdHlwZXMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHR5cGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobmFtZSBpbiBTeW50YXgpIHtcbiAgICAgICAgICAgIGlmIChTeW50YXguaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlc1tuYW1lXSA9IFN5bnRheFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmZyZWV6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0eXBlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfSgpKTtcblxufSkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qKlxuICAgKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAgICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gICAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAgICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICAgKi9cbiAgZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zZXQgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAgICovXG4gIEFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgaXNEdXBsaWNhdGUgPSB0aGlzLmhhcyhhU3RyKTtcbiAgICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICAgIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgICB9XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildID0gaWR4O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwudG9TZXRTdHJpbmcoYVN0cikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICAgIGlmICh0aGlzLmhhcyhhU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAgICpcbiAgICogQHBhcmFtIE51bWJlciBhSWR4XG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gICAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAgICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAgICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbiAgfTtcblxuICBleHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuICAvLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbiAgLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4gIC8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuICAvLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4gIC8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuICAvL1xuICAvLyAgIENvbnRpbnVhdGlvblxuICAvLyAgIHwgICAgU2lnblxuICAvLyAgIHwgICAgfFxuICAvLyAgIFYgICAgVlxuICAvLyAgIDEwMTAxMVxuXG4gIHZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuICAvLyBiaW5hcnk6IDAxMTExMVxuICB2YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuICAvKipcbiAgICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIGlzIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAgICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAgICovXG4gIGZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICAgIHJldHVybiBhVmFsdWUgPCAwXG4gICAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBpcyBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gICAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICAgIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICAgIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gICAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICAgID8gLXNoaWZ0ZWRcbiAgICAgIDogc2hpZnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICAgIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgICB2YXIgZGlnaXQ7XG5cbiAgICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICAgIGRvIHtcbiAgICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgICAgaWYgKHZscSA+IDApIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgICB9XG4gICAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICAgIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gICAgcmV0dXJuIGVuY29kZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICAgKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZy5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICB2YXIgc2hpZnQgPSAwO1xuICAgIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKGkgPj0gc3RyTGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICAgIH1cbiAgICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJBdChpKyspKTtcbiAgICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBmcm9tVkxRU2lnbmVkKHJlc3VsdCksXG4gICAgICByZXN0OiBhU3RyLnNsaWNlKGkpXG4gICAgfTtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBjaGFyVG9JbnRNYXAgPSB7fTtcbiAgdmFyIGludFRvQ2hhck1hcCA9IHt9O1xuXG4gICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuICAgIC5zcGxpdCgnJylcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAoY2gsIGluZGV4KSB7XG4gICAgICBjaGFyVG9JbnRNYXBbY2hdID0gaW5kZXg7XG4gICAgICBpbnRUb0NoYXJNYXBbaW5kZXhdID0gY2g7XG4gICAgfSk7XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NF9lbmNvZGUoYU51bWJlcikge1xuICAgIGlmIChhTnVtYmVyIGluIGludFRvQ2hhck1hcCkge1xuICAgICAgcmV0dXJuIGludFRvQ2hhck1hcFthTnVtYmVyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBhTnVtYmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgdG8gYW4gaW50ZWdlci5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0X2RlY29kZShhQ2hhcikge1xuICAgIGlmIChhQ2hhciBpbiBjaGFyVG9JbnRNYXApIHtcbiAgICAgIHJldHVybiBjaGFyVG9JbnRNYXBbYUNoYXJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGEgdmFsaWQgYmFzZSA2NCBkaWdpdDogXCIgKyBhQ2hhcik7XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvKipcbiAgICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgLy9cbiAgICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIG5leHRcbiAgICAvLyAgICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIGxlc3MgdGhhbiB0aGF0IGVsZW1lbnQuXG4gICAgLy9cbiAgICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAgIC8vICAgICAgZWxlbWVudCB3aGljaCBpcyBsZXNzIHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2VcbiAgICAvLyAgICAgIHJldHVybiBudWxsLlxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICAgIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgICAgcmV0dXJuIGFIYXlzdGFja1ttaWRdO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAvLyBhSGF5c3RhY2tbbWlkXSBpcyBncmVhdGVyIHRoYW4gb3VyIG5lZWRsZS5cbiAgICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBkaWQgbm90IGZpbmQgYW4gZXhhY3QgbWF0Y2gsIHJldHVybiB0aGUgbmV4dCBjbG9zZXN0IG9uZVxuICAgICAgLy8gKHRlcm1pbmF0aW9uIGNhc2UgMikuXG4gICAgICByZXR1cm4gYUhheXN0YWNrW21pZF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gYUhheXN0YWNrW21pZF0gaXMgbGVzcyB0aGFuIG91ciBuZWVkbGUuXG4gICAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDIpIG9yICgzKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIHJldHVybiBhTG93IDwgMFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBhSGF5c3RhY2tbYUxvd107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICAgKiB0aGUgbmV4dCBsb3dlc3QgdmFsdWUgY2hlY2tlZCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICAgKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gICAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gICAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAgICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICAgKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICAgKi9cbiAgZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSkge1xuICAgIHJldHVybiBhSGF5c3RhY2subGVuZ3RoID4gMFxuICAgICAgPyByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpXG4gICAgICA6IG51bGw7XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcblxuICAvKipcbiAgICogQSBTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gICAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICAgKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gICAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAgICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAgICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBmaWxlOiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gICAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICAgKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAgICogICAgIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gICAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAgIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gICAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMsIHRydWUpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gICAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gICAqIEByZXR1cm5zIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICAgIHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgICAgc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy5zbGljZSgpXG4gICAgICAgIC5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcbiAgICAgIHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy5zbGljZSgpXG4gICAgICAgIC5zb3J0KHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc21jO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbiAgLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbiAgLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuICAvLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbiAgLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4gIC8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbiAgLy9cbiAgLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbiAgLy9cbiAgLy8gICAgIHtcbiAgLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbiAgLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4gIC8vICAgICAgICAgICAgIGNvZGUuXG4gIC8vICAgICB9XG4gIC8vXG4gIC8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbiAgLy8gYG51bGxgLlxuICAvL1xuICAvLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuICAvL1xuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgbWFwcGluZ1NlcGFyYXRvciA9IC9eWyw7XS87XG4gICAgICB2YXIgc3RyID0gYVN0cjtcbiAgICAgIHZhciBtYXBwaW5nO1xuICAgICAgdmFyIHRlbXA7XG5cbiAgICAgIHdoaWxlIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJzsnKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJywnKSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcgPSB7fTtcbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgICB0ZW1wID0gYmFzZTY0VkxRLmRlY29kZShzdHIpO1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuXG4gICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwICYmICFtYXBwaW5nU2VwYXJhdG9yLnRlc3Qoc3RyLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICAgIHRlbXAgPSBiYXNlNjRWTFEuZGVjb2RlKHN0cik7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQocHJldmlvdXNTb3VyY2UgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCBtYXBwaW5nU2VwYXJhdG9yLnRlc3Qoc3RyLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IG1hcHBpbmdTZXBhcmF0b3IudGVzdChzdHIuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICAgIHRlbXAgPSBiYXNlNjRWTFEuZGVjb2RlKHN0cik7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcblxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwICYmICFtYXBwaW5nU2VwYXJhdG9yLnRlc3Qoc3RyLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgICAgdGVtcCA9IGJhc2U2NFZMUS5kZWNvZGUoc3RyKTtcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gdGhpcy5fbmFtZXMuYXQocHJldmlvdXNOYW1lICsgdGVtcC52YWx1ZSk7XG4gICAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gICAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcblxuICAgICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiB0aGlzLnNvdXJjZVJvb3QpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGlibGUuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QpIHtcbiAgICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmw7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290XG4gICAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCkge1xuICAgICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gICAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAgICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAgICogQHBhcmFtIGFPcmRlclxuICAgKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICAgKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAgICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgICAgdmFyIG1hcHBpbmdzO1xuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICYmIHNvdXJjZVJvb3QpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lXG4gICAgICAgIH07XG4gICAgICB9KS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG5cbiAgLyoqXG4gICAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAgICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gVG8gY3JlYXRlIGEgbmV3IG9uZSwgeW91IG11c3QgcGFzcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBbiBvcHRpb25hbCByb290IGZvciBhbGwgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJyk7XG4gICAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX21hcHBpbmdzID0gW107XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgfVxuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICAgKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICAgKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuXG4gICAgICBpZiAoc291cmNlICYmICF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICYmICF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gICAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gICAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICAgKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAgICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSkge1xuICAgICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgICAgaWYgKCFhU291cmNlRmlsZSkge1xuICAgICAgICBhU291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgLy8gTWFrZSBcImFTb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgIGFTb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBhU291cmNlRmlsZSk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJhU291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gYVNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgICAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG9yaWdpbmFsLnNvdXJjZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPT0gbnVsbCAmJiBtYXBwaW5nLm5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlIGlkZW50aWZpZXIgbmFtZSBpZiBpdCdzIGFuIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgLy8gaW4gYm90aCBTb3VyY2VNYXBzXG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICBpZiAobmFtZSAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gICAqXG4gICAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAgICogICAgICB0b2tlbi5cbiAgICpcbiAgICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gICAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgICAgLy8gQ2FzZSAxLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICAgIG9yZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICAgKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbWFwcGluZztcblxuICAgICAgLy8gVGhlIG1hcHBpbmdzIG11c3QgYmUgZ3VhcmFudGVlZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIgYmVmb3JlIHdlIHN0YXJ0XG4gICAgICAvLyBzZXJpYWxpemluZyB0aGVtIG9yIGVsc2UgdGhlIGdlbmVyYXRlZCBsaW5lIG51bWJlcnMgKHdoaWNoIGFyZSBkZWZpbmVkXG4gICAgICAvLyB2aWEgdGhlICc7JyBzZXBhcmF0b3JzKSB3aWxsIGJlIGFsbCBtZXNzZWQgdXAuIE5vdGU6IGl0IG1pZ2h0IGJlIG1vcmVcbiAgICAgIC8vIHBlcmZvcm1hbnQgdG8gbWFpbnRhaW4gdGhlIHNvcnRpbmcgYXMgd2UgaW5zZXJ0IHRoZW0sIHJhdGhlciB0aGFuIGFzIHdlXG4gICAgICAvLyBzZXJpYWxpemUgdGhlbSwgYnV0IHRoZSBiaWcgTyBpcyB0aGUgc2FtZSBlaXRoZXIgd2F5LlxuICAgICAgdGhpcy5fbWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9tYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXBwaW5nID0gdGhpcy5fbWFwcGluZ3NbaV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc7JztcbiAgICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZywgdGhpcy5fbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcblxuICAgICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhU291cmNlUm9vdCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KVxuICAgICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgZmlsZTogdGhpcy5fZmlsZSxcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QpIHtcbiAgICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAgICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gICAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICAgKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAgICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICAgKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAgICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gICAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgICB0aGlzLmxpbmUgPSBhTGluZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFMaW5lO1xuICAgIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFDb2x1bW47XG4gICAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogYVNvdXJjZTtcbiAgICB0aGlzLm5hbWUgPSBhTmFtZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFOYW1lO1xuICAgIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqXG4gICAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICovXG4gIFNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIGFycmF5LlxuICAgICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zaGlmdCgpICsgXCJcXG5cIik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBcIlwiO1xuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIGZ1bGwgbGluZXMgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgY29kZSArPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgICB9IHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSk7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIHJlYWNoZWQgdGhlIGNvcnJlY3QgbGluZSwgd2UgYWRkIGNvZGUgdW50aWwgd2VcbiAgICAgICAgICAgIC8vIHJlYWNoIHRoZSBjb3JyZWN0IGNvbHVtbiB0b28uXG4gICAgICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgICBjb2RlICs9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBTb3VyY2VOb2RlLlxuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgcmVtYWluaW5nTGluZXMuam9pbihcIlxcblwiKSk7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChhQ2h1bmspIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUgfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gICAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAgICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICAgIHZhciBjaHVuaztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gICAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICAgKlxuICAgKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gICAgdmFyIG5ld0NoaWxkcmVuO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgICB9XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gICAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoaWxkIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gICAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAgICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICAgKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAgICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzdHIgKz0gY2h1bms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICAgKiBtYXAuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgICBjb2RlOiBcIlwiLFxuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaHVuay5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbiAgfTtcblxuICBleHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAgICogb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gICAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAgICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgICB9XG4gIH1cbiAgZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbiAgdmFyIHVybFJlZ2V4cCA9IC8oW1xcdytcXC0uXSspOlxcL1xcLygoXFx3KzpcXHcrKUApPyhbXFx3Ll0rKT8oOihcXGQrKSk/KFxcUyspPy87XG4gIHZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLisvO1xuXG4gIGZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgICAgYXV0aDogbWF0Y2hbM10sXG4gICAgICBob3N0OiBtYXRjaFs0XSxcbiAgICAgIHBvcnQ6IG1hdGNoWzZdLFxuICAgICAgcGF0aDogbWF0Y2hbN11cbiAgICB9O1xuICB9XG4gIGV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuICBmdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gICAgdmFyIHVybCA9IGFQYXJzZWRVcmwuc2NoZW1lICsgXCI6Ly9cIjtcbiAgICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgXCJAXCJcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4gIGZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gICAgdmFyIHVybDtcblxuICAgIGlmIChhUGF0aC5tYXRjaCh1cmxSZWdleHApIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgaWYgKGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nICYmICh1cmwgPSB1cmxQYXJzZShhUm9vdCkpKSB7XG4gICAgICB1cmwucGF0aCA9IGFQYXRoO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLycgKyBhUGF0aDtcbiAgfVxuICBleHBvcnRzLmpvaW4gPSBqb2luO1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gICAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBmdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cbiAgZXhwb3J0cy50b1NldFN0cmluZyA9IHRvU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiBhU3RyLnN1YnN0cigxKTtcbiAgfVxuICBleHBvcnRzLmZyb21TZXRTdHJpbmcgPSBmcm9tU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICAgIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAgIHZhciB1cmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gICAgaWYgKGFQYXRoLmNoYXJBdCgwKSA9PSBcIi9cIiAmJiB1cmwgJiYgdXJsLnBhdGggPT0gXCIvXCIpIHtcbiAgICAgIHJldHVybiBhUGF0aC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgPT09IDBcbiAgICAgID8gYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpXG4gICAgICA6IGFQYXRoO1xuICB9XG4gIGV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxuICBmdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gICAgdmFyIHMxID0gYVN0cjEgfHwgXCJcIjtcbiAgICB2YXIgczIgPSBhU3RyMiB8fCBcIlwiO1xuICAgIHJldHVybiAoczEgPiBzMikgLSAoczEgPCBzMik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICAgKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAgICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAgICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICB9O1xuICBleHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlXG4gICAqIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICAgKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICAgKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICB2YXIgY21wO1xuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zO1xuXG59KTtcbiIsIi8qKiB2aW06IGV0OnRzPTQ6c3c9NDpzdHM9NFxuICogQGxpY2Vuc2UgYW1kZWZpbmUgMC4xLjAgQ29weXJpZ2h0IChjKSAyMDExLCBUaGUgRG9qbyBGb3VuZGF0aW9uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBBdmFpbGFibGUgdmlhIHRoZSBNSVQgb3IgbmV3IEJTRCBsaWNlbnNlLlxuICogc2VlOiBodHRwOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL2FtZGVmaW5lIGZvciBkZXRhaWxzXG4gKi9cblxuLypqc2xpbnQgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCBwcm9jZXNzICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlZmluZSBmb3Igbm9kZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgdGhlIFwibW9kdWxlXCIgb2JqZWN0IHRoYXQgaXMgZGVmaW5lZCBieSBOb2RlIGZvciB0aGVcbiAqIGN1cnJlbnQgbW9kdWxlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlcXVpcmVGbl0uIE5vZGUncyByZXF1aXJlIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudCBtb2R1bGUuXG4gKiBJdCBvbmx5IG5lZWRzIHRvIGJlIHBhc3NlZCBpbiBOb2RlIHZlcnNpb25zIGJlZm9yZSAwLjUsIHdoZW4gbW9kdWxlLnJlcXVpcmVcbiAqIGRpZCBub3QgZXhpc3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZGVmaW5lIGZ1bmN0aW9uIHRoYXQgaXMgdXNhYmxlIGZvciB0aGUgY3VycmVudCBub2RlXG4gKiBtb2R1bGUuXG4gKi9cbmZ1bmN0aW9uIGFtZGVmaW5lKG1vZHVsZSwgcmVxdWlyZUZuKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBkZWZpbmVDYWNoZSA9IHt9LFxuICAgICAgICBsb2FkZXJDYWNoZSA9IHt9LFxuICAgICAgICBhbHJlYWR5Q2FsbGVkID0gZmFsc2UsXG4gICAgICAgIHBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgICAgIG1ha2VSZXF1aXJlLCBzdHJpbmdSZXF1aXJlO1xuXG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIC4gYW5kIC4uIGZyb20gYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKiBJdCB3aWxsIGtlZXAgYSBsZWFkaW5nIHBhdGggc2VnbWVudCBpZiBhIC4uIHdpbGwgYmVjb21lXG4gICAgICogdGhlIGZpcnN0IHBhdGggc2VnbWVudCwgdG8gaGVscCB3aXRoIG1vZHVsZSBuYW1lIGxvb2t1cHMsXG4gICAgICogd2hpY2ggYWN0IGxpa2UgcGF0aHMsIGJ1dCBjYW4gYmUgcmVtYXBwZWQuIEJ1dCB0aGUgZW5kIHJlc3VsdCxcbiAgICAgKiBhbGwgcGF0aHMgdGhhdCB1c2UgdGhpcyBmdW5jdGlvbiBzaG91bGQgbG9vayBub3JtYWxpemVkLlxuICAgICAqIE5PVEU6IHRoaXMgbWV0aG9kIE1PRElGSUVTIHRoZSBpbnB1dCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnkgdGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbURvdHMoYXJ5KSB7XG4gICAgICAgIHZhciBpLCBwYXJ0O1xuICAgICAgICBmb3IgKGkgPSAwOyBhcnlbaV07IGkrPSAxKSB7XG4gICAgICAgICAgICBwYXJ0ID0gYXJ5W2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGFyeS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgKGFyeVsyXSA9PT0gJy4uJyB8fCBhcnlbMF0gPT09ICcuLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vRW5kIG9mIHRoZSBsaW5lLiBLZWVwIGF0IGxlYXN0IG9uZSBub24tZG90XG4gICAgICAgICAgICAgICAgICAgIC8vcGF0aCBzZWdtZW50IGF0IHRoZSBmcm9udCBzbyBpdCBjYW4gYmUgbWFwcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vY29ycmVjdGx5IHRvIGRpc2suIE90aGVyd2lzZSwgdGhlcmUgaXMgbGlrZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vbm8gcGF0aCBtYXBwaW5nIGZvciBhIHBhdGggc3RhcnRpbmcgd2l0aCAnLi4nLlxuICAgICAgICAgICAgICAgICAgICAvL1RoaXMgY2FuIHN0aWxsIGZhaWwsIGJ1dCBjYXRjaGVzIHRoZSBtb3N0IHJlYXNvbmFibGVcbiAgICAgICAgICAgICAgICAgICAgLy91c2VzIG9mIC4uXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemUobmFtZSwgYmFzZU5hbWUpIHtcbiAgICAgICAgdmFyIGJhc2VQYXJ0cztcblxuICAgICAgICAvL0FkanVzdCBhbnkgcmVsYXRpdmUgcGF0aHMuXG4gICAgICAgIGlmIChuYW1lICYmIG5hbWUuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgIC8vSWYgaGF2ZSBhIGJhc2UgbmFtZSwgdHJ5IHRvIG5vcm1hbGl6ZSBhZ2FpbnN0IGl0LFxuICAgICAgICAgICAgLy9vdGhlcndpc2UsIGFzc3VtZSBpdCBpcyBhIHRvcC1sZXZlbCByZXF1aXJlIHRoYXQgd2lsbFxuICAgICAgICAgICAgLy9iZSByZWxhdGl2ZSB0byBiYXNlVXJsIGluIHRoZSBlbmQuXG4gICAgICAgICAgICBpZiAoYmFzZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlTmFtZS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLmNvbmNhdChuYW1lLnNwbGl0KCcvJykpO1xuICAgICAgICAgICAgICAgIHRyaW1Eb3RzKGJhc2VQYXJ0cyk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGJhc2VQYXJ0cy5qb2luKCcvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIG5vcm1hbGl6ZSgpIGZ1bmN0aW9uIHBhc3NlZCB0byBhIGxvYWRlciBwbHVnaW4nc1xuICAgICAqIG5vcm1hbGl6ZSBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZU5vcm1hbGl6ZShyZWxOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlTG9hZChpZCkge1xuICAgICAgICBmdW5jdGlvbiBsb2FkKHZhbHVlKSB7XG4gICAgICAgICAgICBsb2FkZXJDYWNoZVtpZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWQuZnJvbVRleHQgPSBmdW5jdGlvbiAoaWQsIHRleHQpIHtcbiAgICAgICAgICAgIC8vVGhpcyBvbmUgaXMgZGlmZmljdWx0IGJlY2F1c2UgdGhlIHRleHQgY2FuL3Byb2JhYmx5IHVzZXNcbiAgICAgICAgICAgIC8vZGVmaW5lLCBhbmQgYW55IHJlbGF0aXZlIHBhdGhzIGFuZCByZXF1aXJlcyBzaG91bGQgYmUgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vdG8gdGhhdCBpZCB3YXMgaXQgd291bGQgYmUgZm91bmQgb24gZGlzay4gQnV0IHRoaXMgd291bGQgcmVxdWlyZVxuICAgICAgICAgICAgLy9ib290c3RyYXBwaW5nIGEgbW9kdWxlL3JlcXVpcmUgZmFpcmx5IGRlZXBseSBmcm9tIG5vZGUgY29yZS5cbiAgICAgICAgICAgIC8vTm90IHN1cmUgaG93IGJlc3QgdG8gZ28gYWJvdXQgdGhhdCB5ZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIGRvZXMgbm90IGltcGxlbWVudCBsb2FkLmZyb21UZXh0Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGxvYWQ7XG4gICAgfVxuXG4gICAgbWFrZVJlcXVpcmUgPSBmdW5jdGlvbiAoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCkge1xuICAgICAgICBmdW5jdGlvbiBhbWRSZXF1aXJlKGRlcHMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9TeW5jaHJvbm91cywgc2luZ2xlIG1vZHVsZSByZXF1aXJlKCcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwcywgcmVsSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL0FycmF5IG9mIGRlcGVuZGVuY2llcyB3aXRoIGEgY2FsbGJhY2suXG5cbiAgICAgICAgICAgICAgICAvL0NvbnZlcnQgdGhlIGRlcGVuZGVuY2llcyB0byBtb2R1bGVzLlxuICAgICAgICAgICAgICAgIGRlcHMgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGRlcE5hbWUsIHJlbElkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vV2FpdCBmb3IgbmV4dCB0aWNrIHRvIGNhbGwgYmFjayB0aGUgcmVxdWlyZSBjYWxsLlxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGRlcHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhbWRSZXF1aXJlLnRvVXJsID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgICAgICBpZiAoZmlsZVBhdGguaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShmaWxlUGF0aCwgcGF0aC5kaXJuYW1lKG1vZHVsZS5maWxlbmFtZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFtZFJlcXVpcmU7XG4gICAgfTtcblxuICAgIC8vRmF2b3IgZXhwbGljaXQgdmFsdWUsIHBhc3NlZCBpbiBpZiB0aGUgbW9kdWxlIHdhbnRzIHRvIHN1cHBvcnQgTm9kZSAwLjQuXG4gICAgcmVxdWlyZUZuID0gcmVxdWlyZUZuIHx8IGZ1bmN0aW9uIHJlcSgpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5yZXF1aXJlLmFwcGx5KG1vZHVsZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcnVuRmFjdG9yeShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICB2YXIgciwgZSwgbSwgcmVzdWx0O1xuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgZSA9IGxvYWRlckNhY2hlW2lkXSA9IHt9O1xuICAgICAgICAgICAgbSA9IHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdXJpOiBfX2ZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL09ubHkgc3VwcG9ydCBvbmUgZGVmaW5lIGNhbGwgcGVyIGZpbGVcbiAgICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWRlZmluZSB3aXRoIG5vIG1vZHVsZSBJRCBjYW5ub3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHBlciBmaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vVXNlIHRoZSByZWFsIHZhcmlhYmxlcyBmcm9tIG5vZGVcbiAgICAgICAgICAgIC8vVXNlIG1vZHVsZS5leHBvcnRzIGZvciBleHBvcnRzLCBzaW5jZVxuICAgICAgICAgICAgLy90aGUgZXhwb3J0cyBpbiBoZXJlIGlzIGFtZGVmaW5lIGV4cG9ydHMuXG4gICAgICAgICAgICBlID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgICAgICBtID0gbW9kdWxlO1xuICAgICAgICAgICAgciA9IG1ha2VSZXF1aXJlKHJlcXVpcmVGbiwgZSwgbSwgbW9kdWxlLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vSWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llcywgdGhleSBhcmUgc3RyaW5ncywgc28gbmVlZFxuICAgICAgICAvL3RvIGNvbnZlcnQgdGhlbSB0byBkZXBlbmRlbmN5IHZhbHVlcy5cbiAgICAgICAgaWYgKGRlcHMpIHtcbiAgICAgICAgICAgIGRlcHMgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByKGRlcE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0NhbGwgdGhlIGZhY3Rvcnkgd2l0aCB0aGUgcmlnaHQgZGVwZW5kZW5jaWVzLlxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3RvcnkuYXBwbHkobS5leHBvcnRzLCBkZXBzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhY3Rvcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG0uZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IG0uZXhwb3J0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0cmluZ1JlcXVpcmUgPSBmdW5jdGlvbiAoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBpZCwgcmVsSWQpIHtcbiAgICAgICAgLy9TcGxpdCB0aGUgSUQgYnkgYSAhIHNvIHRoYXRcbiAgICAgICAgdmFyIGluZGV4ID0gaWQuaW5kZXhPZignIScpLFxuICAgICAgICAgICAgb3JpZ2luYWxJZCA9IGlkLFxuICAgICAgICAgICAgcHJlZml4LCBwbHVnaW47XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSBub3JtYWxpemUoaWQsIHJlbElkKTtcblxuICAgICAgICAgICAgLy9TdHJhaWdodCBtb2R1bGUgbG9va3VwLiBJZiBpdCBpcyBvbmUgb2YgdGhlIHNwZWNpYWwgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgLy9kZWFsIHdpdGggaXQsIG90aGVyd2lzZSwgZGVsZWdhdGUgdG8gbm9kZS5cbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ3JlcXVpcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ2V4cG9ydHMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvYWRlckNhY2hlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmluZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIHJ1bkZhY3RvcnkuYXBwbHkobnVsbCwgZGVmaW5lQ2FjaGVbaWRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZihzeXN0ZW1SZXF1aXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeXN0ZW1SZXF1aXJlKG9yaWdpbmFsSWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9kdWxlIHdpdGggSUQ6ICcgKyBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9UaGVyZSBpcyBhIHBsdWdpbiBpbiBwbGF5LlxuICAgICAgICAgICAgcHJlZml4ID0gaWQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKGluZGV4ICsgMSwgaWQubGVuZ3RoKTtcblxuICAgICAgICAgICAgcGx1Z2luID0gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHByZWZpeCwgcmVsSWQpO1xuXG4gICAgICAgICAgICBpZiAocGx1Z2luLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIGlkID0gcGx1Z2luLm5vcm1hbGl6ZShpZCwgbWFrZU5vcm1hbGl6ZShyZWxJZCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL05vcm1hbGl6ZSB0aGUgSUQgbm9ybWFsbHkuXG4gICAgICAgICAgICAgICAgaWQgPSBub3JtYWxpemUoaWQsIHJlbElkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvYWRlckNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5sb2FkKGlkLCBtYWtlUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSwgbWFrZUxvYWQoaWQpLCB7fSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vQ3JlYXRlIGEgZGVmaW5lIGZ1bmN0aW9uIHNwZWNpZmljIHRvIHRoZSBtb2R1bGUgYXNraW5nIGZvciBhbWRlZmluZS5cbiAgICBmdW5jdGlvbiBkZWZpbmUoaWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSBpZDtcbiAgICAgICAgICAgIGlkID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBpZDtcbiAgICAgICAgICAgIGlkID0gZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXBzICYmICFBcnJheS5pc0FycmF5KGRlcHMpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZGVwcztcbiAgICAgICAgICAgIGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlcHMpIHtcbiAgICAgICAgICAgIGRlcHMgPSBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vU2V0IHVwIHByb3BlcnRpZXMgZm9yIHRoaXMgbW9kdWxlLiBJZiBhbiBJRCwgdGhlbiB1c2VcbiAgICAgICAgLy9pbnRlcm5hbCBjYWNoZS4gSWYgbm8gSUQsIHRoZW4gdXNlIHRoZSBleHRlcm5hbCB2YXJpYWJsZXNcbiAgICAgICAgLy9mb3IgdGhpcyBub2RlIG1vZHVsZS5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAvL1B1dCB0aGUgbW9kdWxlIGluIGRlZXAgZnJlZXplIHVudGlsIHRoZXJlIGlzIGFcbiAgICAgICAgICAgIC8vcmVxdWlyZSBjYWxsIGZvciBpdC5cbiAgICAgICAgICAgIGRlZmluZUNhY2hlW2lkXSA9IFtpZCwgZGVwcywgZmFjdG9yeV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vZGVmaW5lLnJlcXVpcmUsIHdoaWNoIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSB2YWx1ZXMgaW4gdGhlXG4gICAgLy9jYWNoZS4gVXNlZnVsIGZvciBBTUQgbW9kdWxlcyB0aGF0IGFsbCBoYXZlIElEcyBpbiB0aGUgZmlsZSxcbiAgICAvL2J1dCBuZWVkIHRvIGZpbmFsbHkgZXhwb3J0IGEgdmFsdWUgdG8gbm9kZSBiYXNlZCBvbiBvbmUgb2YgdGhvc2VcbiAgICAvL0lEcy5cbiAgICBkZWZpbmUucmVxdWlyZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmUuYW1kID0ge307XG5cbiAgICByZXR1cm4gZGVmaW5lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFtZGVmaW5lO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBkb2NibG9ja1JlID0gL15cXHMqKFxcL1xcKlxcKigufFxccj9cXG4pKj9cXCpcXC8pLztcbnZhciBsdHJpbVJlID0gL15cXHMqLztcbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3QoY29udGVudHMpIHtcbiAgdmFyIG1hdGNoID0gY29udGVudHMubWF0Y2goZG9jYmxvY2tSZSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaFswXS5yZXBsYWNlKGx0cmltUmUsICcnKSB8fCAnJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cblxudmFyIGNvbW1lbnRTdGFydFJlID0gL15cXC9cXCpcXCo/LztcbnZhciBjb21tZW50RW5kUmUgPSAvXFwqK1xcLyQvO1xudmFyIHdzUmUgPSAvW1xcdCBdKy9nO1xudmFyIHN0cmluZ1N0YXJ0UmUgPSAvKFxccj9cXG58XikgKlxcKi9nO1xudmFyIG11bHRpbGluZVJlID0gLyg/Ol58XFxyP1xcbikgKihAW15cXHJcXG5dKj8pICpcXHI/XFxuICooW15AXFxyXFxuXFxzXVteQFxcclxcbl0rPykgKlxccj9cXG4vZztcbnZhciBwcm9wZXJ0eVJlID0gLyg/Ol58XFxyP1xcbikgKkAoXFxTKykgKihbXlxcclxcbl0qKS9nO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50c1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGRvY2Jsb2NrKSB7XG4gIGRvY2Jsb2NrID0gZG9jYmxvY2tcbiAgICAucmVwbGFjZShjb21tZW50U3RhcnRSZSwgJycpXG4gICAgLnJlcGxhY2UoY29tbWVudEVuZFJlLCAnJylcbiAgICAucmVwbGFjZSh3c1JlLCAnICcpXG4gICAgLnJlcGxhY2Uoc3RyaW5nU3RhcnRSZSwgJyQxJyk7XG5cbiAgLy8gTm9ybWFsaXplIG11bHRpLWxpbmUgZGlyZWN0aXZlc1xuICB2YXIgcHJldiA9ICcnO1xuICB3aGlsZSAocHJldiAhPSBkb2NibG9jaykge1xuICAgIHByZXYgPSBkb2NibG9jaztcbiAgICBkb2NibG9jayA9IGRvY2Jsb2NrLnJlcGxhY2UobXVsdGlsaW5lUmUsIFwiXFxuJDEgJDJcXG5cIik7XG4gIH1cbiAgZG9jYmxvY2sgPSBkb2NibG9jay50cmltKCk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHByb3BlcnR5UmUuZXhlYyhkb2NibG9jaykpIHtcbiAgICByZXN1bHQucHVzaChbbWF0Y2hbMV0sIG1hdGNoWzJdXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFNhbWUgYXMgcGFyc2UgYnV0IHJldHVybnMgYW4gb2JqZWN0IG9mIHByb3A6IHZhbHVlIGluc3RlYWQgb2YgYXJyYXkgb2YgcGFyaXNcbiAqIElmIGEgcHJvcGVydHkgYXBwZXJzIG1vcmUgdGhhbiBvbmNlIHRoZSBsYXN0IG9uZSB3aWxsIGJlIHJldHVybmVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXNPYmplY3QoZG9jYmxvY2spIHtcbiAgdmFyIHBhaXJzID0gcGFyc2UoZG9jYmxvY2spO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbcGFpcnNbaV1bMF1dID0gcGFpcnNbaV1bMV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5leHBvcnRzLmV4dHJhY3QgPSBleHRyYWN0O1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUFzT2JqZWN0ID0gcGFyc2VBc09iamVjdDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qanNsaW50IG5vZGU6IHRydWUqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlc3ByaW1hID0gcmVxdWlyZSgnZXNwcmltYS1mYicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgZ2V0Qm91bmRhcnlOb2RlID0gdXRpbHMuZ2V0Qm91bmRhcnlOb2RlO1xudmFyIGRlY2xhcmVJZGVudEluU2NvcGUgPSB1dGlscy5kZWNsYXJlSWRlbnRJbkxvY2FsU2NvcGU7XG52YXIgaW5pdFNjb3BlTWV0YWRhdGEgPSB1dGlscy5pbml0U2NvcGVNZXRhZGF0YTtcbnZhciBTeW50YXggPSBlc3ByaW1hLlN5bnRheDtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIF9ub2RlSXNDbG9zdXJlU2NvcGVCb3VuZGFyeShub2RlLCBwYXJlbnROb2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcGFyZW50SXNGdW5jdGlvbiA9XG4gICAgcGFyZW50Tm9kZS50eXBlID09PSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvblxuICAgIHx8IHBhcmVudE5vZGUudHlwZSA9PT0gU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvblxuICAgIHx8IHBhcmVudE5vZGUudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuXG4gIHZhciBwYXJlbnRJc0N1cmx5bGVzc0Fycm93RnVuYyA9XG4gICAgcGFyZW50Tm9kZS50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAmJiBub2RlID09PSBwYXJlbnROb2RlLmJvZHk7XG5cbiAgcmV0dXJuIHBhcmVudElzRnVuY3Rpb25cbiAgICAgICAgICYmIChub2RlLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCB8fCBwYXJlbnRJc0N1cmx5bGVzc0Fycm93RnVuYyk7XG59XG5cbmZ1bmN0aW9uIF9ub2RlSXNCbG9ja1Njb3BlQm91bmRhcnkobm9kZSwgcGFyZW50Tm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSBTeW50YXguUHJvZ3JhbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBub2RlLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudFxuICAgICAgICAgJiYgcGFyZW50Tm9kZS50eXBlID09PSBTeW50YXguQ2F0Y2hDbGF1c2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7YXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZShub2RlLCBwYXRoLCBzdGF0ZSkge1xuICAvKmpzaGludCAtVzAwNCovXG4gIC8vIENyZWF0ZSBhIHNjb3BlIHN0YWNrIGVudHJ5IGlmIHRoaXMgaXMgdGhlIGZpcnN0IG5vZGUgd2UndmUgZW5jb3VudGVyZWQgaW5cbiAgLy8gaXRzIGxvY2FsIHNjb3BlXG4gIHZhciBzdGFydEluZGV4ID0gbnVsbDtcbiAgdmFyIHBhcmVudE5vZGUgPSBwYXRoWzBdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZSkgJiYgc3RhdGUubG9jYWxTY29wZS5wYXJlbnROb2RlICE9PSBwYXJlbnROb2RlKSB7XG4gICAgaWYgKF9ub2RlSXNDbG9zdXJlU2NvcGVCb3VuZGFyeShub2RlLCBwYXJlbnROb2RlKSkge1xuICAgICAgdmFyIHNjb3BlSXNTdHJpY3QgPSBzdGF0ZS5zY29wZUlzU3RyaWN0O1xuICAgICAgaWYgKCFzY29wZUlzU3RyaWN0XG4gICAgICAgICAgJiYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50XG4gICAgICAgICAgICAgIHx8IG5vZGUudHlwZSA9PT0gU3ludGF4LlByb2dyYW0pKSB7XG4gICAgICAgICAgc2NvcGVJc1N0cmljdCA9XG4gICAgICAgICAgICBub2RlLmJvZHkubGVuZ3RoID4gMFxuICAgICAgICAgICAgJiYgbm9kZS5ib2R5WzBdLnR5cGUgPT09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50XG4gICAgICAgICAgICAmJiBub2RlLmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlID09PSBTeW50YXguTGl0ZXJhbFxuICAgICAgICAgICAgJiYgbm9kZS5ib2R5WzBdLmV4cHJlc3Npb24udmFsdWUgPT09ICd1c2Ugc3RyaWN0JztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LlByb2dyYW0pIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHN0YXRlLmcuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgc3RhdGUgPSB1dGlscy51cGRhdGVTdGF0ZShzdGF0ZSwge1xuICAgICAgICAgIHNjb3BlSXNTdHJpY3Q6IHNjb3BlSXNTdHJpY3RcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydEluZGV4ID0gc3RhdGUuZy5idWZmZXIubGVuZ3RoICsgMTtcbiAgICAgICAgc3RhdGUgPSB1dGlscy51cGRhdGVTdGF0ZShzdGF0ZSwge1xuICAgICAgICAgIGxvY2FsU2NvcGU6IHtcbiAgICAgICAgICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gICAgICAgICAgICBwYXJlbnRTY29wZTogc3RhdGUubG9jYWxTY29wZSxcbiAgICAgICAgICAgIGlkZW50aWZpZXJzOiB7fSxcbiAgICAgICAgICAgIHRlbXBWYXJJbmRleDogMCxcbiAgICAgICAgICAgIHRlbXBWYXJzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2NvcGVJc1N0cmljdDogc2NvcGVJc1N0cmljdFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBbGwgZnVuY3Rpb25zIGhhdmUgYW4gaW1wbGljaXQgJ2FyZ3VtZW50cycgb2JqZWN0IGluIHNjb3BlXG4gICAgICAgIGRlY2xhcmVJZGVudEluU2NvcGUoJ2FyZ3VtZW50cycsIGluaXRTY29wZU1ldGFkYXRhKG5vZGUpLCBzdGF0ZSk7XG5cbiAgICAgICAgLy8gSW5jbHVkZSBmdW5jdGlvbiBhcmcgaWRlbnRpZmllcnMgaW4gdGhlIHNjb3BlIGJvdW5kYXJpZXMgb2YgdGhlXG4gICAgICAgIC8vIGZ1bmN0aW9uXG4gICAgICAgIGlmIChwYXJlbnROb2RlLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHBhcmFtO1xuICAgICAgICAgIHZhciBtZXRhZGF0YSA9IGluaXRTY29wZU1ldGFkYXRhKHBhcmVudE5vZGUsIHBhdGguc2xpY2UoMSksIHBhdGhbMF0pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcmFtID0gcGFyZW50Tm9kZS5wYXJhbXNbaV07XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgZGVjbGFyZUlkZW50SW5TY29wZShwYXJhbS5uYW1lLCBtZXRhZGF0YSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY2x1ZGUgcmVzdCBhcmcgaWRlbnRpZmllcnMgaW4gdGhlIHNjb3BlIGJvdW5kYXJpZXMgb2YgdGhlaXJcbiAgICAgICAgLy8gZnVuY3Rpb25zXG4gICAgICAgIGlmIChwYXJlbnROb2RlLnJlc3QpIHtcbiAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBpbml0U2NvcGVNZXRhZGF0YShcbiAgICAgICAgICAgIHBhcmVudE5vZGUsXG4gICAgICAgICAgICBwYXRoLnNsaWNlKDEpLFxuICAgICAgICAgICAgcGF0aFswXVxuICAgICAgICAgICk7XG4gICAgICAgICAgZGVjbGFyZUlkZW50SW5TY29wZShwYXJlbnROb2RlLnJlc3QubmFtZSwgbWV0YWRhdGEsIHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5hbWVkIEZ1bmN0aW9uRXhwcmVzc2lvbnMgc2NvcGUgdGhlaXIgbmFtZSB3aXRoaW4gdGhlIGJvZHkgYmxvY2sgb2ZcbiAgICAgICAgLy8gdGhlbXNlbHZlcyBvbmx5XG4gICAgICAgIGlmIChwYXJlbnROb2RlLnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb24gJiYgcGFyZW50Tm9kZS5pZCkge1xuICAgICAgICAgIHZhciBtZXRhRGF0YSA9XG4gICAgICAgICAgICBpbml0U2NvcGVNZXRhZGF0YShwYXJlbnROb2RlLCBwYXRoLnBhcmVudE5vZGVzbGljZSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgZGVjbGFyZUlkZW50SW5TY29wZShwYXJlbnROb2RlLmlkLm5hbWUsIG1ldGFEYXRhLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVHJhdmVyc2UgYW5kIGZpbmQgYWxsIGxvY2FsIGlkZW50aWZpZXJzIGluIHRoaXMgY2xvc3VyZSBmaXJzdCB0b1xuICAgICAgLy8gYWNjb3VudCBmb3IgZnVuY3Rpb24vdmFyaWFibGUgZGVjbGFyYXRpb24gaG9pc3RpbmdcbiAgICAgIGNvbGxlY3RDbG9zdXJlSWRlbnRzQW5kVHJhdmVyc2Uobm9kZSwgcGF0aCwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChfbm9kZUlzQmxvY2tTY29wZUJvdW5kYXJ5KG5vZGUsIHBhcmVudE5vZGUpKSB7XG4gICAgICBzdGFydEluZGV4ID0gc3RhdGUuZy5idWZmZXIubGVuZ3RoO1xuICAgICAgc3RhdGUgPSB1dGlscy51cGRhdGVTdGF0ZShzdGF0ZSwge1xuICAgICAgICBsb2NhbFNjb3BlOiB7XG4gICAgICAgICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgICAgICAgICBwYXJlbnRTY29wZTogc3RhdGUubG9jYWxTY29wZSxcbiAgICAgICAgICBpZGVudGlmaWVyczoge30sXG4gICAgICAgICAgdGVtcFZhckluZGV4OiAwLFxuICAgICAgICAgIHRlbXBWYXJzOiBbXVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhcmVudE5vZGUudHlwZSA9PT0gU3ludGF4LkNhdGNoQ2xhdXNlKSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGluaXRTY29wZU1ldGFkYXRhKFxuICAgICAgICAgIHBhcmVudE5vZGUsXG4gICAgICAgICAgcGF0aC5zbGljZSgxKSxcbiAgICAgICAgICBwYXJlbnROb2RlXG4gICAgICAgICk7XG4gICAgICAgIGRlY2xhcmVJZGVudEluU2NvcGUocGFyZW50Tm9kZS5wYXJhbS5uYW1lLCBtZXRhZGF0YSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgY29sbGVjdEJsb2NrSWRlbnRzQW5kVHJhdmVyc2Uobm9kZSwgcGF0aCwgc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE9ubHkgY2F0Y2h1cCgpIGJlZm9yZSBhbmQgYWZ0ZXIgdHJhdmVyc2luZyBhIGNoaWxkIG5vZGVcbiAgZnVuY3Rpb24gdHJhdmVyc2VyKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gICAgbm9kZS5yYW5nZSAmJiB1dGlscy5jYXRjaHVwKG5vZGUucmFuZ2VbMF0sIHN0YXRlKTtcbiAgICB0cmF2ZXJzZShub2RlLCBwYXRoLCBzdGF0ZSk7XG4gICAgbm9kZS5yYW5nZSAmJiB1dGlscy5jYXRjaHVwKG5vZGUucmFuZ2VbMV0sIHN0YXRlKTtcbiAgfVxuXG4gIHV0aWxzLmFuYWx5emVBbmRUcmF2ZXJzZSh3YWxrZXIsIHRyYXZlcnNlciwgbm9kZSwgcGF0aCwgc3RhdGUpO1xuXG4gIC8vIEluamVjdCB0ZW1wIHZhcmlhYmxlcyBpbnRvIHRoZSBzY29wZS5cbiAgaWYgKHN0YXJ0SW5kZXggIT09IG51bGwpIHtcbiAgICB1dGlscy5pbmplY3RUZW1wVmFyRGVjbGFyYXRpb25zKHN0YXRlLCBzdGFydEluZGV4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2xsZWN0Q2xvc3VyZUlkZW50c0FuZFRyYXZlcnNlKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHV0aWxzLmFuYWx5emVBbmRUcmF2ZXJzZShcbiAgICB2aXNpdExvY2FsQ2xvc3VyZUlkZW50aWZpZXJzLFxuICAgIGNvbGxlY3RDbG9zdXJlSWRlbnRzQW5kVHJhdmVyc2UsXG4gICAgbm9kZSxcbiAgICBwYXRoLFxuICAgIHN0YXRlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RCbG9ja0lkZW50c0FuZFRyYXZlcnNlKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHV0aWxzLmFuYWx5emVBbmRUcmF2ZXJzZShcbiAgICB2aXNpdExvY2FsQmxvY2tJZGVudGlmaWVycyxcbiAgICBjb2xsZWN0QmxvY2tJZGVudHNBbmRUcmF2ZXJzZSxcbiAgICBub2RlLFxuICAgIHBhdGgsXG4gICAgc3RhdGVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdmlzaXRMb2NhbENsb3N1cmVJZGVudGlmaWVycyhub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB2YXIgbWV0YURhdGE7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246XG4gICAgY2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxuICAgICAgLy8gRnVuY3Rpb24gZXhwcmVzc2lvbnMgZG9uJ3QgZ2V0IHRoZWlyIG5hbWVzIChpZiB0aGVyZSBpcyBvbmUpIGFkZGVkIHRvXG4gICAgICAvLyB0aGUgY2xvc3VyZSBzY29wZSB0aGV5J3JlIGRlZmluZWQgaW5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFN5bnRheC5DbGFzc0RlY2xhcmF0aW9uOlxuICAgIGNhc2UgU3ludGF4LkNsYXNzRXhwcmVzc2lvbjpcbiAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgaWYgKG5vZGUuaWQpIHtcbiAgICAgICAgbWV0YURhdGEgPSBpbml0U2NvcGVNZXRhZGF0YShnZXRCb3VuZGFyeU5vZGUocGF0aCksIHBhdGguc2xpY2UoKSwgbm9kZSk7XG4gICAgICAgIGRlY2xhcmVJZGVudEluU2NvcGUobm9kZS5pZC5uYW1lLCBtZXRhRGF0YSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjpcbiAgICAgIC8vIFZhcmlhYmxlcyBoYXZlIGZ1bmN0aW9uLWxvY2FsIHNjb3BlXG4gICAgICBpZiAocGF0aFswXS5raW5kID09PSAndmFyJykge1xuICAgICAgICBtZXRhRGF0YSA9IGluaXRTY29wZU1ldGFkYXRhKGdldEJvdW5kYXJ5Tm9kZShwYXRoKSwgcGF0aC5zbGljZSgpLCBub2RlKTtcbiAgICAgICAgZGVjbGFyZUlkZW50SW5TY29wZShub2RlLmlkLm5hbWUsIG1ldGFEYXRhLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiB2aXNpdExvY2FsQmxvY2tJZGVudGlmaWVycyhub2RlLCBwYXRoLCBzdGF0ZSkge1xuICAvLyBUT0RPOiBTdXBwb3J0ICdsZXQnIGhlcmUuLi5tYXliZS4uLm9uZSBkYXkuLi5vciBzb21ldGhpbmcuLi5cbiAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkNhdGNoQ2xhdXNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhbGtlcihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB2YXIgdmlzaXRvcnMgPSBzdGF0ZS5nLnZpc2l0b3JzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpc2l0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHZpc2l0b3JzW2ldLnRlc3Qobm9kZSwgcGF0aCwgc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdmlzaXRvcnNbaV0odHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIF9hc3RDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXRBc3RGb3JTb3VyY2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmIChfYXN0Q2FjaGVbc291cmNlXSAmJiAhb3B0aW9ucy5kaXNhYmxlQXN0Q2FjaGUpIHtcbiAgICByZXR1cm4gX2FzdENhY2hlW3NvdXJjZV07XG4gIH1cbiAgdmFyIGFzdCA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7XG4gICAgY29tbWVudDogdHJ1ZSxcbiAgICBsb2M6IHRydWUsXG4gICAgcmFuZ2U6IHRydWUsXG4gICAgc291cmNlVHlwZTogb3B0aW9ucy5zb3VyY2VUeXBlXG4gIH0pO1xuICBpZiAoIW9wdGlvbnMuZGlzYWJsZUFzdENhY2hlKSB7XG4gICAgX2FzdENhY2hlW3NvdXJjZV0gPSBhc3Q7XG4gIH1cbiAgcmV0dXJuIGFzdDtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIGFsbCBhdmFpbGFibGUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBzb3VyY2VcbiAqIEBwYXJhbSB7YXJyYXl9IHZpc2l0b3JzXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gKiBAcGFyYW0gez9vYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKHZpc2l0b3JzLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBhc3Q7XG4gIHRyeSB7XG4gICAgYXN0ID0gZ2V0QXN0Rm9yU291cmNlKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGUubWVzc2FnZSA9ICdQYXJzZSBFcnJvcjogJyArIGUubWVzc2FnZTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIHZhciBzdGF0ZSA9IHV0aWxzLmNyZWF0ZVN0YXRlKHNvdXJjZSwgYXN0LCBvcHRpb25zKTtcbiAgc3RhdGUuZy52aXNpdG9ycyA9IHZpc2l0b3JzO1xuXG4gIGlmIChvcHRpb25zLnNvdXJjZU1hcCkge1xuICAgIHZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCdzb3VyY2UtbWFwJykuU291cmNlTWFwR2VuZXJhdG9yO1xuICAgIHN0YXRlLmcuc291cmNlTWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7ZmlsZTogb3B0aW9ucy5maWxlbmFtZSB8fCAndHJhbnNmb3JtZWQuanMnfSk7XG4gIH1cblxuICB0cmF2ZXJzZShhc3QsIFtdLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXAoc291cmNlLmxlbmd0aCwgc3RhdGUpO1xuXG4gIHZhciByZXQgPSB7Y29kZTogc3RhdGUuZy5idWZmZXIsIGV4dHJhOiBzdGF0ZS5nLmV4dHJhfTtcbiAgaWYgKG9wdGlvbnMuc291cmNlTWFwKSB7XG4gICAgcmV0LnNvdXJjZU1hcCA9IHN0YXRlLmcuc291cmNlTWFwO1xuICAgIHJldC5zb3VyY2VNYXBGaWxlbmFtZSA9ICBvcHRpb25zLmZpbGVuYW1lIHx8ICdzb3VyY2UuanMnO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuZXhwb3J0cy5TeW50YXggPSBTeW50YXg7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKmpzbGludCBub2RlOiB0cnVlKi9cbnZhciBTeW50YXggPSByZXF1aXJlKCdlc3ByaW1hLWZiJykuU3ludGF4O1xudmFyIGxlYWRpbmdJbmRlbnRSZWdleHAgPSAvKF58XFxuKSggezJ9fFxcdCkvZztcbnZhciBub25XaGl0ZVJlZ2V4cCA9IC8oXFxTKS9nO1xuXG4vKipcbiAqIEEgYHN0YXRlYCBvYmplY3QgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHBhcnNlci4gSXQgaGFzIFwibG9jYWxcIiBhbmRcbiAqIFwiZ2xvYmFsXCIgcGFydHMuIEdsb2JhbCBjb250YWlucyBwYXJzZXIgcG9zaXRpb24sIHNvdXJjZSwgZXRjLiBMb2NhbCBjb250YWluc1xuICogc2NvcGUgYmFzZWQgcHJvcGVydGllcyBsaWtlIGN1cnJlbnQgY2xhc3MgbmFtZS4gU3RhdGUgc2hvdWxkIGNvbnRhaW4gYWxsIHRoZVxuICogaW5mbyByZXF1aXJlZCBmb3IgdHJhbnNmb3JtYXRpb24uIEl0J3MgdGhlIG9ubHkgbWFuZGF0b3J5IG9iamVjdCB0aGF0IGlzXG4gKiBiZWluZyBwYXNzZWQgdG8gZXZlcnkgZnVuY3Rpb24gaW4gdHJhbnNmb3JtIGNoYWluLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc291cmNlXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRyYW5zZm9ybU9wdGlvbnNcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RhdGUoc291cmNlLCByb290Tm9kZSwgdHJhbnNmb3JtT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEEgdHJlZSByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgbG9jYWwgc2NvcGUgKGFuZCBpdHMgbGV4aWNhbCBzY29wZSBjaGFpbilcbiAgICAgKiBVc2VmdWwgZm9yIHRyYWNraW5nIGlkZW50aWZpZXJzIGZyb20gcGFyZW50IHNjb3BlcywgZXRjLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9jYWxTY29wZToge1xuICAgICAgcGFyZW50Tm9kZTogcm9vdE5vZGUsXG4gICAgICBwYXJlbnRTY29wZTogbnVsbCxcbiAgICAgIGlkZW50aWZpZXJzOiB7fSxcbiAgICAgIHRlbXBWYXJJbmRleDogMCxcbiAgICAgIHRlbXBWYXJzOiBbXVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgKGFuZCwgaWYgYXBwbGljYWJsZSwgZXhwcmVzc2lvbikgb2YgdGhlIHN1cGVyIGNsYXNzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBzdXBlckNsYXNzOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lc3BhY2UgdG8gdXNlIHdoZW4gbXVuZ2luZyBpZGVudGlmaWVyc1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgbXVuZ2VOYW1lc3BhY2U6ICcnLFxuICAgIC8qKlxuICAgICAqIFJlZiB0byB0aGUgbm9kZSBmb3IgdGhlIGN1cnJlbnQgTWV0aG9kRGVmaW5pdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbWV0aG9kTm9kZTogbnVsbCxcbiAgICAvKipcbiAgICAgKiBSZWYgdG8gdGhlIG5vZGUgZm9yIHRoZSBGdW5jdGlvbkV4cHJlc3Npb24gb2YgdGhlIGVuY2xvc2luZ1xuICAgICAqIE1ldGhvZERlZmluaXRpb25cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIG1ldGhvZEZ1bmNOb2RlOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGVuY2xvc2luZyBjbGFzc1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgY2xhc3NOYW1lOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgd2UncmUgY3VycmVudGx5IHdpdGhpbiBhIGBzdHJpY3RgIHNjb3BlXG4gICAgICogQHR5cGUge0Jvb2x9XG4gICAgICovXG4gICAgc2NvcGVJc1N0cmljdDogbnVsbCxcbiAgICAvKipcbiAgICAgKiBJbmRlbnRhdGlvbiBvZmZzZXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGluZGVudEJ5OiAwLFxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBzdGF0ZSAobm90IGFmZmVjdGVkIGJ5IHVwZGF0ZVN0YXRlKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZzoge1xuICAgICAgLyoqXG4gICAgICAgKiBBIHNldCBvZiBnZW5lcmFsIG9wdGlvbnMgdGhhdCB0cmFuc2Zvcm1hdGlvbnMgY2FuIGNvbnNpZGVyIHdoaWxlIGRvaW5nXG4gICAgICAgKiBhIHRyYW5zZm9ybWF0aW9uOlxuICAgICAgICpcbiAgICAgICAqIC0gbWluaWZ5XG4gICAgICAgKiAgIFNwZWNpZmllcyB0aGF0IHRyYW5zZm9ybWF0aW9uIHN0ZXBzIHNob3VsZCBkbyB0aGVpciBiZXN0IHRvIG1pbmlmeVxuICAgICAgICogICB0aGUgb3V0cHV0IHNvdXJjZSB3aGVuIHBvc3NpYmxlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcGxhY2VzIHdoZXJlXG4gICAgICAgKiAgIG1pbmlmaWNhdGlvbiBvcHRpbWl6YXRpb25zIGFyZSBwb3NzaWJsZSB3aXRoIGhpZ2hlci1sZXZlbCBjb250ZXh0XG4gICAgICAgKiAgIGluZm8gdGhhbiB3aGF0IGpzeG1pbiBjYW4gcHJvdmlkZS5cbiAgICAgICAqXG4gICAgICAgKiAgIEZvciBleGFtcGxlLCB0aGUgRVM2IGNsYXNzIHRyYW5zZm9ybSB3aWxsIG1pbmlmeSBtdW5nZWQgcHJpdmF0ZVxuICAgICAgICogICB2YXJpYWJsZXMgaWYgdGhpcyBmbGFnIGlzIHNldC5cbiAgICAgICAqL1xuICAgICAgb3B0czogdHJhbnNmb3JtT3B0aW9ucyxcbiAgICAgIC8qKlxuICAgICAgICogQ3VycmVudCBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGNvZGVcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgLyoqXG4gICAgICAgKiBBdXhpbGlhcnkgZGF0YSB0byBiZSByZXR1cm5lZCBieSB0cmFuc2Zvcm1zXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBleHRyYToge30sXG4gICAgICAvKipcbiAgICAgICAqIEJ1ZmZlciBjb250YWluaW5nIHRoZSByZXN1bHRcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGJ1ZmZlcjogJycsXG4gICAgICAvKipcbiAgICAgICAqIFNvdXJjZSB0aGF0IGlzIGJlaW5nIHRyYW5zZm9ybWVkXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWNoZWQgcGFyc2VkIGRvY2Jsb2NrIChzZWUgZ2V0RG9jYmxvY2spXG4gICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICovXG4gICAgICBkb2NibG9jazogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoZSB0aGluZyB3YXMgdXNlZFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHRhZ05hbWVzcGFjZVVzZWQ6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIElmIHVzaW5nIGJvbHQgeGpzIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaXNCb2x0OiB1bmRlZmluZWQsXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byByZWNvcmQgc291cmNlIG1hcCAoZXhwZW5zaXZlKSBvciBub3RcbiAgICAgICAqIEB0eXBlIHtTb3VyY2VNYXBHZW5lcmF0b3J8bnVsbH1cbiAgICAgICAqL1xuICAgICAgc291cmNlTWFwOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIEZpbGVuYW1lIG9mIHRoZSBmaWxlIGJlaW5nIHByb2Nlc3NlZC4gV2lsbCBiZSByZXR1cm5lZCBhcyBhIHNvdXJjZVxuICAgICAgICogYXR0cmlidXRlIGluIHRoZSBzb3VyY2UgbWFwXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZU1hcEZpbGVuYW1lOiAnc291cmNlLmpzJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBPbmx5IHdoZW4gc291cmNlIG1hcCBpcyB1c2VkOiBsYXN0IGxpbmUgaW4gdGhlIHNvdXJjZSBmb3Igd2hpY2hcbiAgICAgICAqIHNvdXJjZSBtYXAgd2FzIGdlbmVyYXRlZFxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgc291cmNlTGluZTogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBPbmx5IHdoZW4gc291cmNlIG1hcCBpcyB1c2VkOiBsYXN0IGxpbmUgaW4gdGhlIGJ1ZmZlciBmb3Igd2hpY2hcbiAgICAgICAqIHNvdXJjZSBtYXAgd2FzIGdlbmVyYXRlZFxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgYnVmZmVyTGluZTogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9wLWxldmVsIFByb2dyYW0gQVNUIGZvciB0aGUgb3JpZ2luYWwgZmlsZS5cbiAgICAgICAqL1xuICAgICAgb3JpZ2luYWxQcm9ncmFtQVNUOiBudWxsLFxuXG4gICAgICBzb3VyY2VDb2x1bW46IDAsXG4gICAgICBidWZmZXJDb2x1bW46IDBcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIGNvcHkgb2YgYSBnaXZlbiBzdGF0ZSB3aXRoIFwidXBkYXRlXCIgYW5kIHJldHVybnMgYW4gdXBkYXRlZCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0gIHtvYmplY3R9IHVwZGF0ZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShzdGF0ZSwgdXBkYXRlKSB7XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKHN0YXRlKTtcbiAgT2JqZWN0LmtleXModXBkYXRlKS5mb3JFYWNoKGZ1bmN0aW9uKHVwZGF0ZWRLZXkpIHtcbiAgICByZXRbdXBkYXRlZEtleV0gPSB1cGRhdGVbdXBkYXRlZEtleV07XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgc3RhdGUgZmlsbCB0aGUgcmVzdWx0aW5nIGJ1ZmZlciBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UgdXAgdG9cbiAqIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjb250ZW50VHJhbnNmb3JtZXIgT3B0aW9uYWwgY2FsbGJhY2sgdG8gdHJhbnNmb3JtIG5ld2x5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkIGNvbnRlbnQuXG4gKi9cbmZ1bmN0aW9uIGNhdGNodXAoZW5kLCBzdGF0ZSwgY29udGVudFRyYW5zZm9ybWVyKSB7XG4gIGlmIChlbmQgPCBzdGF0ZS5nLnBvc2l0aW9uKSB7XG4gICAgLy8gY2Fubm90IG1vdmUgYmFja3dhcmRzXG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzb3VyY2UgPSBzdGF0ZS5nLnNvdXJjZS5zdWJzdHJpbmcoc3RhdGUuZy5wb3NpdGlvbiwgZW5kKTtcbiAgdmFyIHRyYW5zZm9ybWVkID0gdXBkYXRlSW5kZW50KHNvdXJjZSwgc3RhdGUpO1xuICBpZiAoc3RhdGUuZy5zb3VyY2VNYXAgJiYgdHJhbnNmb3JtZWQpIHtcbiAgICAvLyByZWNvcmQgd2hlcmUgd2UgYXJlXG4gICAgc3RhdGUuZy5zb3VyY2VNYXAuYWRkTWFwcGluZyh7XG4gICAgICBnZW5lcmF0ZWQ6IHsgbGluZTogc3RhdGUuZy5idWZmZXJMaW5lLCBjb2x1bW46IHN0YXRlLmcuYnVmZmVyQ29sdW1uIH0sXG4gICAgICBvcmlnaW5hbDogeyBsaW5lOiBzdGF0ZS5nLnNvdXJjZUxpbmUsIGNvbHVtbjogc3RhdGUuZy5zb3VyY2VDb2x1bW4gfSxcbiAgICAgIHNvdXJjZTogc3RhdGUuZy5zb3VyY2VNYXBGaWxlbmFtZVxuICAgIH0pO1xuXG4gICAgLy8gcmVjb3JkIGxpbmUgYnJlYWtzIGluIHRyYW5zZm9ybWVkIHNvdXJjZVxuICAgIHZhciBzb3VyY2VMaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHRyYW5zZm9ybWVkTGluZXMgPSB0cmFuc2Zvcm1lZC5zcGxpdCgnXFxuJyk7XG4gICAgLy8gQWRkIGxpbmUgYnJlYWsgbWFwcGluZ3MgYmV0d2VlbiBsYXN0IGtub3duIG1hcHBpbmcgYW5kIHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gYWRkZWQgcGllY2UuIFNvIGZvciB0aGUgY29kZSBwaWVjZVxuICAgIC8vICAoZm9vLCBiYXIpO1xuICAgIC8vID4gdmFyIHggPSAyO1xuICAgIC8vID4gdmFyIGIgPSAzO1xuICAgIC8vICAgdmFyIGMgPVxuICAgIC8vIG9ubHkgYWRkIGxpbmVzIG1hcmtlZCB3aXRoIFwiPlwiOiAyLCAzLlxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc291cmNlTGluZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBzdGF0ZS5nLnNvdXJjZU1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7IGxpbmU6IHN0YXRlLmcuYnVmZmVyTGluZSwgY29sdW1uOiAwIH0sXG4gICAgICAgIG9yaWdpbmFsOiB7IGxpbmU6IHN0YXRlLmcuc291cmNlTGluZSwgY29sdW1uOiAwIH0sXG4gICAgICAgIHNvdXJjZTogc3RhdGUuZy5zb3VyY2VNYXBGaWxlbmFtZVxuICAgICAgfSk7XG4gICAgICBzdGF0ZS5nLnNvdXJjZUxpbmUrKztcbiAgICAgIHN0YXRlLmcuYnVmZmVyTGluZSsrO1xuICAgIH1cbiAgICAvLyBvZmZzZXQgZm9yIHRoZSBsYXN0IHBpZWNlXG4gICAgaWYgKHNvdXJjZUxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHN0YXRlLmcuc291cmNlTGluZSsrO1xuICAgICAgc3RhdGUuZy5idWZmZXJMaW5lKys7XG4gICAgICBzdGF0ZS5nLnNvdXJjZUNvbHVtbiA9IDA7XG4gICAgICBzdGF0ZS5nLmJ1ZmZlckNvbHVtbiA9IDA7XG4gICAgfVxuICAgIHN0YXRlLmcuc291cmNlQ29sdW1uICs9IHNvdXJjZUxpbmVzW3NvdXJjZUxpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICBzdGF0ZS5nLmJ1ZmZlckNvbHVtbiArPVxuICAgICAgdHJhbnNmb3JtZWRMaW5lc1t0cmFuc2Zvcm1lZExpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5nLmJ1ZmZlciArPVxuICAgIGNvbnRlbnRUcmFuc2Zvcm1lciA/IGNvbnRlbnRUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lZCkgOiB0cmFuc2Zvcm1lZDtcbiAgc3RhdGUuZy5wb3NpdGlvbiA9IGVuZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIG9yaWdpbmFsIHNvdXJjZSBmb3IgYW4gQVNUIG5vZGUuXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVTb3VyY2VUZXh0KG5vZGUsIHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5nLnNvdXJjZS5zdWJzdHJpbmcobm9kZS5yYW5nZVswXSwgbm9kZS5yYW5nZVsxXSk7XG59XG5cbmZ1bmN0aW9uIF9yZXBsYWNlTm9uV2hpdGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2Uobm9uV2hpdGVSZWdleHAsICcgJyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICovXG5mdW5jdGlvbiBfc3RyaXBOb25XaGl0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShub25XaGl0ZVJlZ2V4cCwgJycpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIHN5bnRhY3RpYyBjaGFyIGluXG4gKiB0aGUgcGVuZGluZyBzb3VyY2UuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIHNraXAgaW5zdGFuY2VzIG9mIHRoZSBzcGVjaWZpZWQgY2hhciBpZiB0aGV5IHNpdCBpbnNpZGUgYVxuICogICAgICAgY29tbWVudCBib2R5LlxuICpcbiAqIE5PVEU6IFRoaXMgZnVuY3Rpb24gYWxzbyBhc3N1bWVzIHRoYXQgdGhlIGJ1ZmZlcidzIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90XG4gKiAgICAgICBhbHJlYWR5IHdpdGhpbiBhIGNvbW1lbnQgb3IgYSBzdHJpbmcuIFRoaXMgaXMgcmFyZWx5IHRoZSBjYXNlIHNpbmNlIGFsbFxuICogICAgICAgb2YgdGhlIGJ1ZmZlci1hZHZhbmNlbWVudCB1dGlsaXR5IG1ldGhvZHMgdGVuZCB0byBiZSB1c2VkIG9uIHN5bnRhY3RpY1xuICogICAgICAgbm9kZXMnIHJhbmdlIHZhbHVlcyAtLSBidXQgaXQncyBhIHNtYWxsIGdvdGNoYSB0aGF0J3Mgd29ydGggbWVudGlvbmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dFN5bnRhY3RpY0NoYXJPZmZzZXQoY2hhciwgc3RhdGUpIHtcbiAgdmFyIHBlbmRpbmdTb3VyY2UgPSBzdGF0ZS5nLnNvdXJjZS5zdWJzdHJpbmcoc3RhdGUuZy5wb3NpdGlvbik7XG4gIHZhciBwZW5kaW5nU291cmNlTGluZXMgPSBwZW5kaW5nU291cmNlLnNwbGl0KCdcXG4nKTtcblxuICB2YXIgY2hhck9mZnNldCA9IDA7XG4gIHZhciBsaW5lO1xuICB2YXIgd2l0aGluQmxvY2tDb21tZW50ID0gZmFsc2U7XG4gIHZhciB3aXRoaW5TdHJpbmcgPSBmYWxzZTtcbiAgbGluZUxvb3A6IHdoaWxlICgobGluZSA9IHBlbmRpbmdTb3VyY2VMaW5lcy5zaGlmdCgpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGxpbmVFbmRQb3MgPSBjaGFyT2Zmc2V0ICsgbGluZS5sZW5ndGg7XG4gICAgY2hhckxvb3A6IGZvciAoOyBjaGFyT2Zmc2V0IDwgbGluZUVuZFBvczsgY2hhck9mZnNldCsrKSB7XG4gICAgICB2YXIgY3VyckNoYXIgPSBwZW5kaW5nU291cmNlW2NoYXJPZmZzZXRdO1xuICAgICAgaWYgKGN1cnJDaGFyID09PSAnXCInIHx8IGN1cnJDaGFyID09PSAnXFwnJykge1xuICAgICAgICB3aXRoaW5TdHJpbmcgPSAhd2l0aGluU3RyaW5nO1xuICAgICAgICBjb250aW51ZSBjaGFyTG9vcDtcbiAgICAgIH0gZWxzZSBpZiAod2l0aGluU3RyaW5nKSB7XG4gICAgICAgIGNvbnRpbnVlIGNoYXJMb29wO1xuICAgICAgfSBlbHNlIGlmIChjaGFyT2Zmc2V0ICsgMSA8IGxpbmVFbmRQb3MpIHtcbiAgICAgICAgdmFyIG5leHRUd29DaGFycyA9IGN1cnJDaGFyICsgbGluZVtjaGFyT2Zmc2V0ICsgMV07XG4gICAgICAgIGlmIChuZXh0VHdvQ2hhcnMgPT09ICcvLycpIHtcbiAgICAgICAgICBjaGFyT2Zmc2V0ID0gbGluZUVuZFBvcyArIDE7XG4gICAgICAgICAgY29udGludWUgbGluZUxvb3A7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFR3b0NoYXJzID09PSAnLyonKSB7XG4gICAgICAgICAgd2l0aGluQmxvY2tDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICBjaGFyT2Zmc2V0ICs9IDE7XG4gICAgICAgICAgY29udGludWUgY2hhckxvb3A7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFR3b0NoYXJzID09PSAnKi8nKSB7XG4gICAgICAgICAgd2l0aGluQmxvY2tDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgY2hhck9mZnNldCArPSAxO1xuICAgICAgICAgIGNvbnRpbnVlIGNoYXJMb29wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghd2l0aGluQmxvY2tDb21tZW50ICYmIGN1cnJDaGFyID09PSBjaGFyKSB7XG4gICAgICAgIHJldHVybiBjaGFyT2Zmc2V0ICsgc3RhdGUuZy5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBY2NvdW50IGZvciAnXFxuJ1xuICAgIGNoYXJPZmZzZXQrKztcbiAgICB3aXRoaW5TdHJpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignYCcgKyBjaGFyICsgJ2Agbm90IGZvdW5kIScpO1xufVxuXG4vKipcbiAqIENhdGNoZXMgdXAgYXMgYGNhdGNodXBgIGJ1dCByZXBsYWNlcyBub24td2hpdGVzcGFjZSBjaGFycyB3aXRoIHNwYWNlcy5cbiAqL1xuZnVuY3Rpb24gY2F0Y2h1cFdoaXRlT3V0KGVuZCwgc3RhdGUpIHtcbiAgY2F0Y2h1cChlbmQsIHN0YXRlLCBfcmVwbGFjZU5vbldoaXRlKTtcbn1cblxuLyoqXG4gKiBDYXRjaGVzIHVwIGFzIGBjYXRjaHVwYCBidXQgcmVtb3ZlcyBhbGwgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAqL1xuZnVuY3Rpb24gY2F0Y2h1cFdoaXRlU3BhY2UoZW5kLCBzdGF0ZSkge1xuICBjYXRjaHVwKGVuZCwgc3RhdGUsIF9zdHJpcE5vbldoaXRlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBub24tbmV3bGluZSBjaGFyYWN0ZXJzXG4gKi9cbnZhciByZU5vbk5ld2xpbmUgPSAvW15cXG5dL2c7XG5mdW5jdGlvbiBzdHJpcE5vbk5ld2xpbmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVOb25OZXdsaW5lLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xufVxuXG4vKipcbiAqIENhdGNoZXMgdXAgYXMgYGNhdGNodXBgIGJ1dCByZW1vdmVzIGFsbCBub24tbmV3bGluZSBjaGFyYWN0ZXJzLlxuICpcbiAqIEVxdWl2YWxlbnQgdG8gYXBwZW5kaW5nIGFzIG1hbnkgbmV3bGluZXMgYXMgdGhlcmUgYXJlIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAqIGJldHdlZW4gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGBlbmRgLlxuICovXG5mdW5jdGlvbiBjYXRjaHVwTmV3bGluZXMoZW5kLCBzdGF0ZSkge1xuICBjYXRjaHVwKGVuZCwgc3RhdGUsIHN0cmlwTm9uTmV3bGluZSk7XG59XG5cblxuLyoqXG4gKiBTYW1lIGFzIGNhdGNodXAgYnV0IGRvZXMgbm90IHRvdWNoIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGVuZFxuICogQHBhcmFtICB7b2JqZWN0fSBzdGF0ZVxuICovXG5mdW5jdGlvbiBtb3ZlKGVuZCwgc3RhdGUpIHtcbiAgLy8gbW92ZSB0aGUgaW50ZXJuYWwgY3Vyc29yc1xuICBpZiAoc3RhdGUuZy5zb3VyY2VNYXApIHtcbiAgICBpZiAoZW5kIDwgc3RhdGUuZy5wb3NpdGlvbikge1xuICAgICAgc3RhdGUuZy5wb3NpdGlvbiA9IDA7XG4gICAgICBzdGF0ZS5nLnNvdXJjZUxpbmUgPSAxO1xuICAgICAgc3RhdGUuZy5zb3VyY2VDb2x1bW4gPSAwO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5nLnNvdXJjZS5zdWJzdHJpbmcoc3RhdGUuZy5wb3NpdGlvbiwgZW5kKTtcbiAgICB2YXIgc291cmNlTGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgIGlmIChzb3VyY2VMaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICBzdGF0ZS5nLnNvdXJjZUxpbmUgKz0gc291cmNlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHN0YXRlLmcuc291cmNlQ29sdW1uID0gMDtcbiAgICB9XG4gICAgc3RhdGUuZy5zb3VyY2VDb2x1bW4gKz0gc291cmNlTGluZXNbc291cmNlTGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICB9XG4gIHN0YXRlLmcucG9zaXRpb24gPSBlbmQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyBhIHN0cmluZyBvZiB0ZXh0IHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqL1xuZnVuY3Rpb24gYXBwZW5kKHN0ciwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmcuc291cmNlTWFwICYmIHN0cikge1xuICAgIHN0YXRlLmcuc291cmNlTWFwLmFkZE1hcHBpbmcoe1xuICAgICAgZ2VuZXJhdGVkOiB7IGxpbmU6IHN0YXRlLmcuYnVmZmVyTGluZSwgY29sdW1uOiBzdGF0ZS5nLmJ1ZmZlckNvbHVtbiB9LFxuICAgICAgb3JpZ2luYWw6IHsgbGluZTogc3RhdGUuZy5zb3VyY2VMaW5lLCBjb2x1bW46IHN0YXRlLmcuc291cmNlQ29sdW1uIH0sXG4gICAgICBzb3VyY2U6IHN0YXRlLmcuc291cmNlTWFwRmlsZW5hbWVcbiAgICB9KTtcbiAgICB2YXIgdHJhbnNmb3JtZWRMaW5lcyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gICAgaWYgKHRyYW5zZm9ybWVkTGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgc3RhdGUuZy5idWZmZXJMaW5lICs9IHRyYW5zZm9ybWVkTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHN0YXRlLmcuYnVmZmVyQ29sdW1uID0gMDtcbiAgICB9XG4gICAgc3RhdGUuZy5idWZmZXJDb2x1bW4gKz1cbiAgICAgIHRyYW5zZm9ybWVkTGluZXNbdHJhbnNmb3JtZWRMaW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUuZy5idWZmZXIgKz0gc3RyO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBpbmRlbnQgdXNpbmcgc3RhdGUuaW5kZW50QnkgcHJvcGVydHkuIEluZGVudCBpcyBtZWFzdXJlZCBpblxuICogZG91YmxlIHNwYWNlcy4gVXBkYXRlcyBhIHNpbmdsZSBsaW5lIG9ubHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUluZGVudChzdHIsIHN0YXRlKSB7XG4gIC8qanNoaW50IC1XMDA0Ki9cbiAgdmFyIGluZGVudEJ5ID0gc3RhdGUuaW5kZW50Qnk7XG4gIGlmIChpbmRlbnRCeSA8IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IC1pbmRlbnRCeTsgaSsrKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShsZWFkaW5nSW5kZW50UmVnZXhwLCAnJDEnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRlbnRCeTsgaSsrKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShsZWFkaW5nSW5kZW50UmVnZXhwLCAnJDEkMiQyJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBpbmRlbnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIHVudGlsIFwic3RhcnRcIiBvciB0aGUgZmlyc3RcbiAqIGNoYXJhY3RlciBiZWZvcmUgc3RhcnQuXG4gKiBAZXhhbXBsZVxuICogICBcIiAgZm9vLmJhcigpXCJcbiAqICAgICAgICAgXlxuICogICAgICAgc3RhcnRcbiAqICAgaW5kZW50IHdpbGwgYmUgXCIgIFwiXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBzdGFydFxuICogQHBhcmFtICB7b2JqZWN0fSBzdGF0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbmRlbnRCZWZvcmUoc3RhcnQsIHN0YXRlKSB7XG4gIHZhciBlbmQgPSBzdGFydDtcbiAgc3RhcnQgPSBzdGFydCAtIDE7XG5cbiAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBzdGF0ZS5nLnNvdXJjZVtzdGFydF0gIT0gJ1xcbicpIHtcbiAgICBpZiAoIXN0YXRlLmcuc291cmNlW3N0YXJ0XS5tYXRjaCgvWyBcXHRdLykpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cbiAgICBzdGFydC0tO1xuICB9XG4gIHJldHVybiBzdGF0ZS5nLnNvdXJjZS5zdWJzdHJpbmcoc3RhcnQgKyAxLCBlbmQpO1xufVxuXG5mdW5jdGlvbiBnZXREb2NibG9jayhzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmcuZG9jYmxvY2spIHtcbiAgICB2YXIgZG9jYmxvY2sgPSByZXF1aXJlKCcuL2RvY2Jsb2NrJyk7XG4gICAgc3RhdGUuZy5kb2NibG9jayA9XG4gICAgICBkb2NibG9jay5wYXJzZUFzT2JqZWN0KGRvY2Jsb2NrLmV4dHJhY3Qoc3RhdGUuZy5zb3VyY2UpKTtcbiAgfVxuICByZXR1cm4gc3RhdGUuZy5kb2NibG9jaztcbn1cblxuZnVuY3Rpb24gaWRlbnRXaXRoaW5MZXhpY2FsU2NvcGUoaWRlbnROYW1lLCBzdGF0ZSwgc3RvcEJlZm9yZU5vZGUpIHtcbiAgdmFyIGN1cnJTY29wZSA9IHN0YXRlLmxvY2FsU2NvcGU7XG4gIHdoaWxlIChjdXJyU2NvcGUpIHtcbiAgICBpZiAoY3VyclNjb3BlLmlkZW50aWZpZXJzW2lkZW50TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHN0b3BCZWZvcmVOb2RlICYmIGN1cnJTY29wZS5wYXJlbnROb2RlID09PSBzdG9wQmVmb3JlTm9kZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY3VyclNjb3BlID0gY3VyclNjb3BlLnBhcmVudFNjb3BlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaWRlbnRJbkxvY2FsU2NvcGUoaWRlbnROYW1lLCBzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubG9jYWxTY29wZS5pZGVudGlmaWVyc1tpZGVudE5hbWVdICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGJvdW5kYXJ5Tm9kZVxuICogQHBhcmFtIHs/YXJyYXl9IHBhdGhcbiAqIEByZXR1cm4gez9vYmplY3R9IG5vZGVcbiAqL1xuZnVuY3Rpb24gaW5pdFNjb3BlTWV0YWRhdGEoYm91bmRhcnlOb2RlLCBwYXRoLCBub2RlKSB7XG4gIHJldHVybiB7XG4gICAgYm91bmRhcnlOb2RlOiBib3VuZGFyeU5vZGUsXG4gICAgYmluZGluZ1BhdGg6IHBhdGgsXG4gICAgYmluZGluZ05vZGU6IG5vZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZUlkZW50SW5Mb2NhbFNjb3BlKGlkZW50TmFtZSwgbWV0YURhdGEsIHN0YXRlKSB7XG4gIHN0YXRlLmxvY2FsU2NvcGUuaWRlbnRpZmllcnNbaWRlbnROYW1lXSA9IHtcbiAgICBib3VuZGFyeU5vZGU6IG1ldGFEYXRhLmJvdW5kYXJ5Tm9kZSxcbiAgICBwYXRoOiBtZXRhRGF0YS5iaW5kaW5nUGF0aCxcbiAgICBub2RlOiBtZXRhRGF0YS5iaW5kaW5nTm9kZSxcbiAgICBzdGF0ZTogT2JqZWN0LmNyZWF0ZShzdGF0ZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TGV4aWNhbEJpbmRpbmdNZXRhZGF0YShpZGVudE5hbWUsIHN0YXRlKSB7XG4gIHZhciBjdXJyU2NvcGUgPSBzdGF0ZS5sb2NhbFNjb3BlO1xuICB3aGlsZSAoY3VyclNjb3BlKSB7XG4gICAgaWYgKGN1cnJTY29wZS5pZGVudGlmaWVyc1tpZGVudE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjdXJyU2NvcGUuaWRlbnRpZmllcnNbaWRlbnROYW1lXTtcbiAgICB9XG5cbiAgICBjdXJyU2NvcGUgPSBjdXJyU2NvcGUucGFyZW50U2NvcGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TG9jYWxCaW5kaW5nTWV0YWRhdGEoaWRlbnROYW1lLCBzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubG9jYWxTY29wZS5pZGVudGlmaWVyc1tpZGVudE5hbWVdO1xufVxuXG4vKipcbiAqIEFwcGx5IHRoZSBnaXZlbiBhbmFseXplciBmdW5jdGlvbiB0byB0aGUgY3VycmVudCBub2RlLiBJZiB0aGUgYW5hbHl6ZXJcbiAqIGRvZXNuJ3QgcmV0dXJuIGZhbHNlLCB0cmF2ZXJzZSBlYWNoIGNoaWxkIG9mIHRoZSBjdXJyZW50IG5vZGUgdXNpbmcgdGhlIGdpdmVuXG4gKiB0cmF2ZXJzZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gYW5hbHl6ZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlclxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7YXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVxuICovXG5mdW5jdGlvbiBhbmFseXplQW5kVHJhdmVyc2UoYW5hbHl6ZXIsIHRyYXZlcnNlciwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSkge1xuICAgIGlmIChhbmFseXplcihub2RlLCBwYXRoLCBzdGF0ZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhdGgudW5zaGlmdChub2RlKTtcbiAgfVxuXG4gIGdldE9yZGVyZWRDaGlsZHJlbihub2RlKS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdHJhdmVyc2VyKGNoaWxkLCBwYXRoLCBzdGF0ZSk7XG4gIH0pO1xuXG4gIG5vZGUudHlwZSAmJiBwYXRoLnNoaWZ0KCk7XG59XG5cbi8qKlxuICogSXQgaXMgY3J1Y2lhbCB0aGF0IHdlIHRyYXZlcnNlIGluIG9yZGVyLCBvciBlbHNlIGNhdGNodXAoKSBvbiBhIGxhdGVyXG4gKiBub2RlIHRoYXQgaXMgcHJvY2Vzc2VkIG91dCBvZiBvcmRlciBjYW4gbW92ZSB0aGUgYnVmZmVyIHBhc3QgYSBub2RlXG4gKiB0aGF0IHdlIGhhdmVuJ3QgaGFuZGxlZCB5ZXQsIHByZXZlbnRpbmcgdXMgZnJvbSBtb2RpZnlpbmcgdGhhdCBub2RlLlxuICpcbiAqIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgbm9kZSBoYXMgbXVsdGlwbGUgcHJvcGVydGllcyBjb250YWluaW5nIGNoaWxkcmVuLlxuICogRm9yIGV4YW1wbGUsIFhKU0VsZW1lbnQgbm9kZXMgaGF2ZSBgb3BlbmluZ0VsZW1lbnRgLCBgY2xvc2luZ0VsZW1lbnRgIGFuZFxuICogYGNoaWxkcmVuYC4gSWYgd2UgdHJhdmVyc2UgYG9wZW5pbmdFbGVtZW50YCwgdGhlbiBgY2xvc2luZ0VsZW1lbnRgLCB0aGVuXG4gKiB3aGVuIHdlIGdldCB0byBgY2hpbGRyZW5gLCB0aGUgYnVmZmVyIGhhcyBhbHJlYWR5IGNhdWdodCB1cCB0byB0aGUgZW5kIG9mXG4gKiB0aGUgY2xvc2luZyBlbGVtZW50LCBhZnRlciB0aGUgY2hpbGRyZW4uXG4gKlxuICogVGhpcyBpcyBiYXNpY2FsbHkgYSBTY2h3YXJ0emlhbiB0cmFuc2Zvcm0uIENvbGxlY3RzIGFuIGFycmF5IG9mIGNoaWxkcmVuLFxuICogZWFjaCBvbmUgcmVwcmVzZW50ZWQgYXMgW2NoaWxkLCBzdGFydEluZGV4XTsgc29ydHMgdGhlIGFycmF5IGJ5IHN0YXJ0XG4gKiBpbmRleDsgdGhlbiB0cmF2ZXJzZXMgdGhlIGNoaWxkcmVuIGluIHRoYXQgb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIGdldE9yZGVyZWRDaGlsZHJlbihub2RlKSB7XG4gIHZhciBxdWV1ZSA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGVucXVldWVOb2RlV2l0aFN0YXJ0SW5kZXgocXVldWUsIG5vZGVba2V5XSk7XG4gICAgfVxuICB9XG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0pO1xuICByZXR1cm4gcXVldWUubWFwKGZ1bmN0aW9uKHBhaXIpIHsgcmV0dXJuIHBhaXJbMF07IH0pO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYW5hbHl6ZUFuZFRyYXZlcnNlIHdoaWNoIHF1ZXVlcyB1cCBhbGwgb2YgdGhlIGNoaWxkcmVuXG4gKiBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBDaGlsZHJlbiBjYW4gYWxzbyBiZSBmb3VuZCBpbiBhcnJheXMsIHNvIHdlIGJhc2ljYWxseSB3YW50IHRvIG1lcmdlIGFsbCBvZlxuICogdGhvc2UgYXJyYXlzIHRvZ2V0aGVyIHNvIHdlIGNhbiBzb3J0IHRoZW0gYW5kIHRoZW4gdHJhdmVyc2UgdGhlIGNoaWxkcmVuXG4gKiBpbiBvcmRlci5cbiAqXG4gKiBPbmUgZXhhbXBsZSBpcyB0aGUgUHJvZ3JhbSBub2RlLiBJdCBjb250YWlucyBgYm9keWAgYW5kIGBjb21tZW50c2AsIGJvdGhcbiAqIGFycmF5cy4gTGV4b2dyYXBoaWNhbGx5LCBjb21tZW50cyBhcmUgaW50ZXJzcGVyc2VkIHRocm91Z2hvdXQgdGhlIGJvZHlcbiAqIG5vZGVzLCBidXQgZXNwcmltYSdzIEFTVCBncm91cHMgdGhlbSB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZU5vZGVXaXRoU3RhcnRJbmRleChxdWV1ZSwgbm9kZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG5vZGUucmFuZ2UpIHtcbiAgICBxdWV1ZS5wdXNoKFtub2RlLCBub2RlLnJhbmdlWzBdXSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBub2RlLmxlbmd0aDsgaWkrKykge1xuICAgICAgZW5xdWV1ZU5vZGVXaXRoU3RhcnRJbmRleChxdWV1ZSwgbm9kZVtpaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgbm9kZSBvciBhbnkgb2YgaXRzIHN1Yi1ub2RlcyBjb250YWluc1xuICogYSBzeW50YWN0aWMgY29uc3RydWN0IG9mIHRoZSBwYXNzZWQgdHlwZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlIC0gQVNUIG5vZGUgdG8gdGVzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gbm9kZSB0eXBlIHRvIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNDaGlsZE9mVHlwZShub2RlLCB0eXBlKSB7XG4gIHJldHVybiBjb250YWluc0NoaWxkTWF0Y2hpbmcobm9kZSwgZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IHR5cGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb250YWluc0NoaWxkTWF0Y2hpbmcobm9kZSwgbWF0Y2hlcikge1xuICB2YXIgZm91bmRNYXRjaGluZ0NoaWxkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG5vZGVUeXBlQW5hbHl6ZXIobm9kZSkge1xuICAgIGlmIChtYXRjaGVyKG5vZGUpID09PSB0cnVlKSB7XG4gICAgICBmb3VuZE1hdGNoaW5nQ2hpbGQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub2RlVHlwZVRyYXZlcnNlcihjaGlsZCwgcGF0aCwgc3RhdGUpIHtcbiAgICBpZiAoIWZvdW5kTWF0Y2hpbmdDaGlsZCkge1xuICAgICAgZm91bmRNYXRjaGluZ0NoaWxkID0gY29udGFpbnNDaGlsZE1hdGNoaW5nKGNoaWxkLCBtYXRjaGVyKTtcbiAgICB9XG4gIH1cbiAgYW5hbHl6ZUFuZFRyYXZlcnNlKFxuICAgIG5vZGVUeXBlQW5hbHl6ZXIsXG4gICAgbm9kZVR5cGVUcmF2ZXJzZXIsXG4gICAgbm9kZSxcbiAgICBbXVxuICApO1xuICByZXR1cm4gZm91bmRNYXRjaGluZ0NoaWxkO1xufVxuXG52YXIgc2NvcGVUeXBlcyA9IHt9O1xuc2NvcGVUeXBlc1tTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25dID0gdHJ1ZTtcbnNjb3BlVHlwZXNbU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbl0gPSB0cnVlO1xuc2NvcGVUeXBlc1tTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbl0gPSB0cnVlO1xuc2NvcGVUeXBlc1tTeW50YXguUHJvZ3JhbV0gPSB0cnVlO1xuXG5mdW5jdGlvbiBnZXRCb3VuZGFyeU5vZGUocGF0aCkge1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgcGF0aC5sZW5ndGg7ICsraWkpIHtcbiAgICBpZiAoc2NvcGVUeXBlc1twYXRoW2lpXS50eXBlXSkge1xuICAgICAgcmV0dXJuIHBhdGhbaWldO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ0V4cGVjdGVkIHRvIGZpbmQgYSBub2RlIHdpdGggb25lIG9mIHRoZSBmb2xsb3dpbmcgdHlwZXMgaW4gcGF0aDpcXG4nICtcbiAgICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzY29wZVR5cGVzKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGVtcFZhcih0ZW1wVmFySW5kZXgpIHtcbiAgcmV0dXJuICckX18nICsgdGVtcFZhckluZGV4O1xufVxuXG5mdW5jdGlvbiBpbmplY3RUZW1wVmFyKHN0YXRlKSB7XG4gIHZhciB0ZW1wVmFyID0gJyRfXycgKyAoc3RhdGUubG9jYWxTY29wZS50ZW1wVmFySW5kZXgrKyk7XG4gIHN0YXRlLmxvY2FsU2NvcGUudGVtcFZhcnMucHVzaCh0ZW1wVmFyKTtcbiAgcmV0dXJuIHRlbXBWYXI7XG59XG5cbmZ1bmN0aW9uIGluamVjdFRlbXBWYXJEZWNsYXJhdGlvbnMoc3RhdGUsIGluZGV4KSB7XG4gIGlmIChzdGF0ZS5sb2NhbFNjb3BlLnRlbXBWYXJzLmxlbmd0aCkge1xuICAgIHN0YXRlLmcuYnVmZmVyID1cbiAgICAgIHN0YXRlLmcuYnVmZmVyLnNsaWNlKDAsIGluZGV4KSArXG4gICAgICAndmFyICcgKyBzdGF0ZS5sb2NhbFNjb3BlLnRlbXBWYXJzLmpvaW4oJywgJykgKyAnOycgK1xuICAgICAgc3RhdGUuZy5idWZmZXIuc2xpY2UoaW5kZXgpO1xuICAgIHN0YXRlLmxvY2FsU2NvcGUudGVtcFZhcnMgPSBbXTtcbiAgfVxufVxuXG5leHBvcnRzLmFuYWx5emVBbmRUcmF2ZXJzZSA9IGFuYWx5emVBbmRUcmF2ZXJzZTtcbmV4cG9ydHMuYXBwZW5kID0gYXBwZW5kO1xuZXhwb3J0cy5jYXRjaHVwID0gY2F0Y2h1cDtcbmV4cG9ydHMuY2F0Y2h1cE5ld2xpbmVzID0gY2F0Y2h1cE5ld2xpbmVzO1xuZXhwb3J0cy5jYXRjaHVwV2hpdGVPdXQgPSBjYXRjaHVwV2hpdGVPdXQ7XG5leHBvcnRzLmNhdGNodXBXaGl0ZVNwYWNlID0gY2F0Y2h1cFdoaXRlU3BhY2U7XG5leHBvcnRzLmNvbnRhaW5zQ2hpbGRNYXRjaGluZyA9IGNvbnRhaW5zQ2hpbGRNYXRjaGluZztcbmV4cG9ydHMuY29udGFpbnNDaGlsZE9mVHlwZSA9IGNvbnRhaW5zQ2hpbGRPZlR5cGU7XG5leHBvcnRzLmNyZWF0ZVN0YXRlID0gY3JlYXRlU3RhdGU7XG5leHBvcnRzLmRlY2xhcmVJZGVudEluTG9jYWxTY29wZSA9IGRlY2xhcmVJZGVudEluTG9jYWxTY29wZTtcbmV4cG9ydHMuZ2V0Qm91bmRhcnlOb2RlID0gZ2V0Qm91bmRhcnlOb2RlO1xuZXhwb3J0cy5nZXREb2NibG9jayA9IGdldERvY2Jsb2NrO1xuZXhwb3J0cy5nZXRMZXhpY2FsQmluZGluZ01ldGFkYXRhID0gZ2V0TGV4aWNhbEJpbmRpbmdNZXRhZGF0YTtcbmV4cG9ydHMuZ2V0TG9jYWxCaW5kaW5nTWV0YWRhdGEgPSBnZXRMb2NhbEJpbmRpbmdNZXRhZGF0YTtcbmV4cG9ydHMuZ2V0TmV4dFN5bnRhY3RpY0NoYXJPZmZzZXQgPSBnZXROZXh0U3ludGFjdGljQ2hhck9mZnNldDtcbmV4cG9ydHMuZ2V0Tm9kZVNvdXJjZVRleHQgPSBnZXROb2RlU291cmNlVGV4dDtcbmV4cG9ydHMuZ2V0T3JkZXJlZENoaWxkcmVuID0gZ2V0T3JkZXJlZENoaWxkcmVuO1xuZXhwb3J0cy5nZXRUZW1wVmFyID0gZ2V0VGVtcFZhcjtcbmV4cG9ydHMuaWRlbnRJbkxvY2FsU2NvcGUgPSBpZGVudEluTG9jYWxTY29wZTtcbmV4cG9ydHMuaWRlbnRXaXRoaW5MZXhpY2FsU2NvcGUgPSBpZGVudFdpdGhpbkxleGljYWxTY29wZTtcbmV4cG9ydHMuaW5kZW50QmVmb3JlID0gaW5kZW50QmVmb3JlO1xuZXhwb3J0cy5pbml0U2NvcGVNZXRhZGF0YSA9IGluaXRTY29wZU1ldGFkYXRhO1xuZXhwb3J0cy5pbmplY3RUZW1wVmFyID0gaW5qZWN0VGVtcFZhcjtcbmV4cG9ydHMuaW5qZWN0VGVtcFZhckRlY2xhcmF0aW9ucyA9IGluamVjdFRlbXBWYXJEZWNsYXJhdGlvbnM7XG5leHBvcnRzLm1vdmUgPSBtb3ZlO1xuZXhwb3J0cy5zY29wZVR5cGVzID0gc2NvcGVUeXBlcztcbmV4cG9ydHMudXBkYXRlSW5kZW50ID0gdXBkYXRlSW5kZW50O1xuZXhwb3J0cy51cGRhdGVTdGF0ZSA9IHVwZGF0ZVN0YXRlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSovXG5cbi8qKlxuICogRGVzdWdhcnMgRVM2IEFycm93IGZ1bmN0aW9ucyB0byBFUzMgZnVuY3Rpb24gZXhwcmVzc2lvbnMuXG4gKiBJZiB0aGUgZnVuY3Rpb24gY29udGFpbnMgYHRoaXNgIGV4cHJlc3Npb24gLS0gYXV0b21hdGljYWxseVxuICogYmluZHMgdGhlIGZ1bmN0aW9uIHRvIGN1cnJlbnQgdmFsdWUgb2YgYHRoaXNgLlxuICpcbiAqIFNpbmdsZSBwYXJhbWV0ZXIsIHNpbXBsZSBleHByZXNzaW9uOlxuICpcbiAqIFsxLCAyLCAzXS5tYXAoeCA9PiB4ICogeCk7XG4gKlxuICogWzEsIDIsIDNdLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4ICogeDsgfSk7XG4gKlxuICogU2V2ZXJhbCBwYXJhbWV0ZXJzLCBjb21wbGV4IGJsb2NrOlxuICpcbiAqIHRoaXMudXNlcnMuZm9yRWFjaCgodXNlciwgaWR4KSA9PiB7XG4gKiAgIHJldHVybiB0aGlzLmlzQWN0aXZlKGlkeCkgJiYgdGhpcy5zZW5kKHVzZXIpO1xuICogfSk7XG4gKlxuICogdGhpcy51c2Vycy5mb3JFYWNoKGZ1bmN0aW9uKHVzZXIsIGlkeCkge1xuICogICByZXR1cm4gdGhpcy5pc0FjdGl2ZShpZHgpICYmIHRoaXMuc2VuZCh1c2VyKTtcbiAqIH0uYmluZCh0aGlzKSk7XG4gKlxuICovXG52YXIgcmVzdFBhcmFtVmlzaXRvcnMgPSByZXF1aXJlKCcuL2VzNi1yZXN0LXBhcmFtLXZpc2l0b3JzJyk7XG52YXIgZGVzdHJ1Y3R1cmluZ1Zpc2l0b3JzID0gcmVxdWlyZSgnLi9lczYtZGVzdHJ1Y3R1cmluZy12aXNpdG9ycycpO1xuXG52YXIgU3ludGF4ID0gcmVxdWlyZSgnZXNwcmltYS1mYicpLlN5bnRheDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3NyYy91dGlscycpO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdmlzaXRBcnJvd0Z1bmN0aW9uKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB2YXIgbm90SW5FeHByZXNzaW9uID0gKHBhdGhbMF0udHlwZSA9PT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpO1xuXG4gIC8vIFdyYXAgYSBmdW5jdGlvbiBpbnRvIGEgZ3JvdXBpbmcgb3BlcmF0b3IsIGlmIGl0J3Mgbm90XG4gIC8vIGluIHRoZSBleHByZXNzaW9uIHBvc2l0aW9uLlxuICBpZiAobm90SW5FeHByZXNzaW9uKSB7XG4gICAgdXRpbHMuYXBwZW5kKCcoJywgc3RhdGUpO1xuICB9XG5cbiAgdXRpbHMuYXBwZW5kKCdmdW5jdGlvbicsIHN0YXRlKTtcbiAgcmVuZGVyUGFyYW1zKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSk7XG5cbiAgLy8gU2tpcCBhcnJvdy5cbiAgdXRpbHMuY2F0Y2h1cFdoaXRlU3BhY2Uobm9kZS5ib2R5LnJhbmdlWzBdLCBzdGF0ZSk7XG5cbiAgdmFyIHJlbmRlckJvZHkgPSBub2RlLmJvZHkudHlwZSA9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnRcbiAgICA/IHJlbmRlclN0YXRlbWVudEJvZHlcbiAgICA6IHJlbmRlckV4cHJlc3Npb25Cb2R5O1xuXG4gIHBhdGgudW5zaGlmdChub2RlKTtcbiAgcmVuZGVyQm9keSh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpO1xuICBwYXRoLnNoaWZ0KCk7XG5cbiAgLy8gQmluZCB0aGUgZnVuY3Rpb24gb25seSBpZiBgdGhpc2AgdmFsdWUgaXMgdXNlZFxuICAvLyBpbnNpZGUgaXQgb3IgaW5zaWRlIGFueSBzdWItZXhwcmVzc2lvbi5cbiAgdmFyIGNvbnRhaW5zQmluZGluZ1N5bnRheCA9XG4gICAgdXRpbHMuY29udGFpbnNDaGlsZE1hdGNoaW5nKG5vZGUuYm9keSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4LlRoaXNFeHByZXNzaW9uXG4gICAgICAgICAgICAgfHwgKG5vZGUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgJiYgbm9kZS5uYW1lID09PSBcInN1cGVyXCIpO1xuICAgIH0pO1xuXG4gIGlmIChjb250YWluc0JpbmRpbmdTeW50YXgpIHtcbiAgICB1dGlscy5hcHBlbmQoJy5iaW5kKHRoaXMpJywgc3RhdGUpO1xuICB9XG5cbiAgdXRpbHMuY2F0Y2h1cFdoaXRlU3BhY2Uobm9kZS5yYW5nZVsxXSwgc3RhdGUpO1xuXG4gIC8vIENsb3NlIHdyYXBwZXIgaWYgbm90IGluIHRoZSBleHByZXNzaW9uLlxuICBpZiAobm90SW5FeHByZXNzaW9uKSB7XG4gICAgdXRpbHMuYXBwZW5kKCcpJywgc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQYXJhbXModHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIC8vIFRvIHByZXNlcnZlIGlubGluZSB0eXBlY2hlY2tpbmcgZGlyZWN0aXZlcywgd2VcbiAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBwYXJlbnMtZnJlZSBhbmQgcGFyYW50aGVzaXplZCBzaW5nbGUgcGFyYW0uXG4gIGlmIChpc1BhcmVuc0ZyZWVTaW5nbGVQYXJhbShub2RlLCBzdGF0ZSkgfHwgIW5vZGUucGFyYW1zLmxlbmd0aCkge1xuICAgIHV0aWxzLmFwcGVuZCgnKCcsIHN0YXRlKTtcbiAgfVxuICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoICE9PSAwKSB7XG4gICAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICAgIHRyYXZlcnNlKG5vZGUucGFyYW1zLCBwYXRoLCBzdGF0ZSk7XG4gICAgcGF0aC51bnNoaWZ0KCk7XG4gIH1cbiAgdXRpbHMuYXBwZW5kKCcpJywgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBpc1BhcmVuc0ZyZWVTaW5nbGVQYXJhbShub2RlLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmXG4gICAgc3RhdGUuZy5zb3VyY2Vbc3RhdGUuZy5wb3NpdGlvbl0gIT09ICcoJztcbn1cblxuZnVuY3Rpb24gcmVuZGVyRXhwcmVzc2lvbkJvZHkodHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIC8vIFdyYXAgc2ltcGxlIGV4cHJlc3Npb24gYm9kaWVzIGludG8gYSBibG9ja1xuICAvLyB3aXRoIGV4cGxpY2l0IHJldHVybiBzdGF0ZW1lbnQuXG4gIHV0aWxzLmFwcGVuZCgneycsIHN0YXRlKTtcblxuICAvLyBTcGVjaWFsIGhhbmRsaW5nIG9mIHJlc3QgcGFyYW0uXG4gIGlmIChub2RlLnJlc3QpIHtcbiAgICB1dGlscy5hcHBlbmQoXG4gICAgICByZXN0UGFyYW1WaXNpdG9ycy5yZW5kZXJSZXN0UGFyYW1TZXR1cChub2RlLCBzdGF0ZSksXG4gICAgICBzdGF0ZVxuICAgICk7XG4gIH1cblxuICAvLyBTcGVjaWFsIGhhbmRsaW5nIG9mIGRlc3RydWN0dXJlZCBwYXJhbXMuXG4gIGRlc3RydWN0dXJpbmdWaXNpdG9ycy5yZW5kZXJEZXN0cnVjdHVyZWRDb21wb25lbnRzKFxuICAgIG5vZGUsXG4gICAgdXRpbHMudXBkYXRlU3RhdGUoc3RhdGUsIHtcbiAgICAgIGxvY2FsU2NvcGU6IHtcbiAgICAgICAgcGFyZW50Tm9kZTogc3RhdGUucGFyZW50Tm9kZSxcbiAgICAgICAgcGFyZW50U2NvcGU6IHN0YXRlLnBhcmVudFNjb3BlLFxuICAgICAgICBpZGVudGlmaWVyczogc3RhdGUuaWRlbnRpZmllcnMsXG4gICAgICAgIHRlbXBWYXJJbmRleDogMFxuICAgICAgfVxuICAgIH0pXG4gICk7XG5cbiAgdXRpbHMuYXBwZW5kKCdyZXR1cm4gJywgc3RhdGUpO1xuICByZW5kZXJTdGF0ZW1lbnRCb2R5KHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSk7XG4gIHV0aWxzLmFwcGVuZCgnO30nLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN0YXRlbWVudEJvZHkodHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHRyYXZlcnNlKG5vZGUuYm9keSwgcGF0aCwgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwKG5vZGUuYm9keS5yYW5nZVsxXSwgc3RhdGUpO1xufVxuXG52aXNpdEFycm93RnVuY3Rpb24udGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcbn07XG5cbmV4cG9ydHMudmlzaXRvckxpc3QgPSBbXG4gIHZpc2l0QXJyb3dGdW5jdGlvblxuXTtcblxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAwNC1wcmVzZW50IEZhY2Vib29rLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG4vKmdsb2JhbCBleHBvcnRzOnRydWUqL1xuXG4vKipcbiAqIEltcGxlbWVudHMgRVM2IGNhbGwgc3ByZWFkLlxuICpcbiAqIGluc3RhbmNlLm1ldGhvZChhLCBiLCBjLCAuLi5kKVxuICpcbiAqIGluc3RhbmNlLm1ldGhvZC5hcHBseShpbnN0YW5jZSwgW2EsIGIsIGNdLmNvbmNhdChkKSlcbiAqXG4gKi9cblxudmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzcHJpbWEtZmInKS5TeW50YXg7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9zcmMvdXRpbHMnKTtcblxuZnVuY3Rpb24gcHJvY2Vzcyh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMubW92ZShub2RlLnJhbmdlWzBdLCBzdGF0ZSk7XG4gIHRyYXZlcnNlKG5vZGUsIHBhdGgsIHN0YXRlKTtcbiAgdXRpbHMuY2F0Y2h1cChub2RlLnJhbmdlWzFdLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHZpc2l0Q2FsbFNwcmVhZCh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMuY2F0Y2h1cChub2RlLnJhbmdlWzBdLCBzdGF0ZSk7XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pIHtcbiAgICAvLyBJbnB1dCAgPSBuZXcgU2V0KDEsIDIsIC4uLmxpc3QpXG4gICAgLy8gT3V0cHV0ID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShTZXQsIFtudWxsLCAxLCAyXS5jb25jYXQobGlzdCkpKVxuICAgIHV0aWxzLmFwcGVuZCgnbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSgnLCBzdGF0ZSk7XG4gICAgcHJvY2Vzcyh0cmF2ZXJzZSwgbm9kZS5jYWxsZWUsIHBhdGgsIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChub2RlLmNhbGxlZS50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbikge1xuICAgIC8vIElucHV0ICA9IGdldCgpLmZuKDEsIDIsIC4uLm1vcmUpXG4gICAgLy8gT3V0cHV0ID0gKF8gPSBnZXQoKSkuZm4uYXBwbHkoXywgWzEsIDJdLmFwcGx5KG1vcmUpKVxuICAgIHZhciB0ZW1wVmFyID0gdXRpbHMuaW5qZWN0VGVtcFZhcihzdGF0ZSk7XG4gICAgdXRpbHMuYXBwZW5kKCcoJyArIHRlbXBWYXIgKyAnID0gJywgc3RhdGUpO1xuICAgIHByb2Nlc3ModHJhdmVyc2UsIG5vZGUuY2FsbGVlLm9iamVjdCwgcGF0aCwgc3RhdGUpO1xuICAgIHV0aWxzLmFwcGVuZCgnKScsIHN0YXRlKTtcbiAgICBpZiAobm9kZS5jYWxsZWUucHJvcGVydHkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgIHV0aWxzLmFwcGVuZCgnLicsIHN0YXRlKTtcbiAgICAgIHByb2Nlc3ModHJhdmVyc2UsIG5vZGUuY2FsbGVlLnByb3BlcnR5LCBwYXRoLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWxzLmFwcGVuZCgnWycsIHN0YXRlKTtcbiAgICAgIHByb2Nlc3ModHJhdmVyc2UsIG5vZGUuY2FsbGVlLnByb3BlcnR5LCBwYXRoLCBzdGF0ZSk7XG4gICAgICB1dGlscy5hcHBlbmQoJ10nLCBzdGF0ZSk7XG4gICAgfVxuICAgIHV0aWxzLmFwcGVuZCgnLmFwcGx5KCcgKyB0ZW1wVmFyLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW5wdXQgID0gbWF4KDEsIDIsIC4uLmxpc3QpXG4gICAgLy8gT3V0cHV0ID0gbWF4LmFwcGx5KG51bGwsIFsxLCAyXS5jb25jYXQobGlzdCkpXG4gICAgdmFyIG5lZWRzVG9CZVdyYXBwZWRJblBhcmVudGhlc2lzID1cbiAgICAgIG5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uIHx8XG4gICAgICBub2RlLmNhbGxlZS50eXBlID09PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xuICAgIGlmIChuZWVkc1RvQmVXcmFwcGVkSW5QYXJlbnRoZXNpcykge1xuICAgICAgdXRpbHMuYXBwZW5kKCcoJywgc3RhdGUpO1xuICAgIH1cbiAgICBwcm9jZXNzKHRyYXZlcnNlLCBub2RlLmNhbGxlZSwgcGF0aCwgc3RhdGUpO1xuICAgIGlmIChuZWVkc1RvQmVXcmFwcGVkSW5QYXJlbnRoZXNpcykge1xuICAgICAgdXRpbHMuYXBwZW5kKCcpJywgc3RhdGUpO1xuICAgIH1cbiAgICB1dGlscy5hcHBlbmQoJy5hcHBseShudWxsJywgc3RhdGUpO1xuICB9XG4gIHV0aWxzLmFwcGVuZCgnLCAnLCBzdGF0ZSk7XG5cbiAgdmFyIGFyZ3MgPSBub2RlLmFyZ3VtZW50cy5zbGljZSgpO1xuICB2YXIgc3ByZWFkID0gYXJncy5wb3AoKTtcbiAgaWYgKGFyZ3MubGVuZ3RoIHx8IG5vZGUudHlwZSA9PT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pIHtcbiAgICB1dGlscy5hcHBlbmQoJ1snLCBzdGF0ZSk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pIHtcbiAgICAgIHV0aWxzLmFwcGVuZCgnbnVsbCcgKyAoYXJncy5sZW5ndGggPyAnLCAnIDogJycpLCBzdGF0ZSk7XG4gICAgfVxuICAgIHdoaWxlIChhcmdzLmxlbmd0aCkge1xuICAgICAgdmFyIGFyZyA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgIHV0aWxzLm1vdmUoYXJnLnJhbmdlWzBdLCBzdGF0ZSk7XG4gICAgICB0cmF2ZXJzZShhcmcsIHBhdGgsIHN0YXRlKTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICB1dGlscy5jYXRjaHVwKGFyZ3NbMF0ucmFuZ2VbMF0sIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLmNhdGNodXAoYXJnLnJhbmdlWzFdLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHV0aWxzLmFwcGVuZCgnXS5jb25jYXQoJywgc3RhdGUpO1xuICAgIHByb2Nlc3ModHJhdmVyc2UsIHNwcmVhZC5hcmd1bWVudCwgcGF0aCwgc3RhdGUpO1xuICAgIHV0aWxzLmFwcGVuZCgnKScsIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzKHRyYXZlcnNlLCBzcHJlYWQuYXJndW1lbnQsIHBhdGgsIHN0YXRlKTtcbiAgfVxuICB1dGlscy5hcHBlbmQobm9kZS50eXBlID09PSBTeW50YXguTmV3RXhwcmVzc2lvbiA/ICcpKScgOiAnKScsIHN0YXRlKTtcblxuICB1dGlscy5tb3ZlKG5vZGUucmFuZ2VbMV0sIHN0YXRlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52aXNpdENhbGxTcHJlYWQudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgKFxuICAgICAgbm9kZS50eXBlID09PSBTeW50YXguQ2FsbEV4cHJlc3Npb24gfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gU3ludGF4Lk5ld0V4cHJlc3Npb25cbiAgICApICYmXG4gICAgbm9kZS5hcmd1bWVudHMubGVuZ3RoID4gMCAmJlxuICAgIG5vZGUuYXJndW1lbnRzW25vZGUuYXJndW1lbnRzLmxlbmd0aCAtIDFdLnR5cGUgPT09IFN5bnRheC5TcHJlYWRFbGVtZW50XG4gICk7XG59O1xuXG5leHBvcnRzLnZpc2l0b3JMaXN0ID0gW1xuICB2aXNpdENhbGxTcHJlYWQsXG5dO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qanNsaW50IG5vZGU6dHJ1ZSovXG5cbi8qKlxuICogQHR5cGVjaGVja3NcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmFzZTYyID0gcmVxdWlyZSgnYmFzZTYyJyk7XG52YXIgU3ludGF4ID0gcmVxdWlyZSgnZXNwcmltYS1mYicpLlN5bnRheDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3NyYy91dGlscycpO1xudmFyIHJlc2VydmVkV29yZHNIZWxwZXIgPSByZXF1aXJlKCcuL3Jlc2VydmVkLXdvcmRzLWhlbHBlcicpO1xuXG52YXIgZGVjbGFyZUlkZW50SW5Mb2NhbFNjb3BlID0gdXRpbHMuZGVjbGFyZUlkZW50SW5Mb2NhbFNjb3BlO1xudmFyIGluaXRTY29wZU1ldGFkYXRhID0gdXRpbHMuaW5pdFNjb3BlTWV0YWRhdGE7XG5cbnZhciBTVVBFUl9QUk9UT19JREVOVF9QUkVGSVggPSAnX19fX1N1cGVyUHJvdG9PZic7XG5cbnZhciBfYW5vbkNsYXNzVVVJRENvdW50ZXIgPSAwO1xudmFyIF9tdW5nZWRTeW1ib2xNYXBzID0ge307XG5cbmZ1bmN0aW9uIHJlc2V0U3ltYm9scygpIHtcbiAgX2Fub25DbGFzc1VVSURDb3VudGVyID0gMDtcbiAgX211bmdlZFN5bWJvbE1hcHMgPSB7fTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGdlbmVyYXRlIGEgdW5pcXVlIGNsYXNzIGZvciB1c2Ugd2l0aCBjb2RlLWdlbnMgZm9yIGFub255bW91cyBjbGFzc1xuICogZXhwcmVzc2lvbnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIF9nZW5lcmF0ZUFub255bW91c0NsYXNzTmFtZShzdGF0ZSkge1xuICB2YXIgbXVuZ2VOYW1lc3BhY2UgPSBzdGF0ZS5tdW5nZU5hbWVzcGFjZSB8fCAnJztcbiAgcmV0dXJuICdfX19fQ2xhc3MnICsgbXVuZ2VOYW1lc3BhY2UgKyBiYXNlNjIuZW5jb2RlKF9hbm9uQ2xhc3NVVUlEQ291bnRlcisrKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBpZGVudGlmaWVyIG5hbWUsIG11bmdlIGl0IHVzaW5nIHRoZSBjdXJyZW50IHN0YXRlJ3MgbXVuZ2VOYW1lc3BhY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkZW50TmFtZVxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIF9nZXRNdW5nZWROYW1lKGlkZW50TmFtZSwgc3RhdGUpIHtcbiAgdmFyIG11bmdlTmFtZXNwYWNlID0gc3RhdGUubXVuZ2VOYW1lc3BhY2U7XG4gIHZhciBzaG91bGRNaW5pZnkgPSBzdGF0ZS5nLm9wdHMubWluaWZ5O1xuXG4gIGlmIChzaG91bGRNaW5pZnkpIHtcbiAgICBpZiAoIV9tdW5nZWRTeW1ib2xNYXBzW211bmdlTmFtZXNwYWNlXSkge1xuICAgICAgX211bmdlZFN5bWJvbE1hcHNbbXVuZ2VOYW1lc3BhY2VdID0ge1xuICAgICAgICBzeW1ib2xNYXA6IHt9LFxuICAgICAgICBpZGVudFVVSURDb3VudGVyOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzeW1ib2xNYXAgPSBfbXVuZ2VkU3ltYm9sTWFwc1ttdW5nZU5hbWVzcGFjZV0uc3ltYm9sTWFwO1xuICAgIGlmICghc3ltYm9sTWFwW2lkZW50TmFtZV0pIHtcbiAgICAgIHN5bWJvbE1hcFtpZGVudE5hbWVdID1cbiAgICAgICAgYmFzZTYyLmVuY29kZShfbXVuZ2VkU3ltYm9sTWFwc1ttdW5nZU5hbWVzcGFjZV0uaWRlbnRVVUlEQ291bnRlcisrKTtcbiAgICB9XG4gICAgaWRlbnROYW1lID0gc3ltYm9sTWFwW2lkZW50TmFtZV07XG4gIH1cbiAgcmV0dXJuICckJyArIG11bmdlTmFtZXNwYWNlICsgaWRlbnROYW1lO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIHN1cGVyIGNsYXNzIGluZm9ybWF0aW9uIGZyb20gYSBjbGFzcyBub2RlLlxuICpcbiAqIEluZm9ybWF0aW9uIGluY2x1ZGVzIG5hbWUgb2YgdGhlIHN1cGVyIGNsYXNzIGFuZC9vciB0aGUgZXhwcmVzc2lvbiBzdHJpbmdcbiAqIChpZiBleHRlbmRpbmcgZnJvbSBhbiBleHByZXNzaW9uKVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gX2dldFN1cGVyQ2xhc3NJbmZvKG5vZGUsIHN0YXRlKSB7XG4gIHZhciByZXQgPSB7XG4gICAgbmFtZTogbnVsbCxcbiAgICBleHByZXNzaW9uOiBudWxsXG4gIH07XG4gIGlmIChub2RlLnN1cGVyQ2xhc3MpIHtcbiAgICBpZiAobm9kZS5zdXBlckNsYXNzLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICByZXQubmFtZSA9IG5vZGUuc3VwZXJDbGFzcy5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFeHRlbnNpb24gZnJvbSBhbiBleHByZXNzaW9uXG4gICAgICByZXQubmFtZSA9IF9nZW5lcmF0ZUFub255bW91c0NsYXNzTmFtZShzdGF0ZSk7XG4gICAgICByZXQuZXhwcmVzc2lvbiA9IHN0YXRlLmcuc291cmNlLnN1YnN0cmluZyhcbiAgICAgICAgbm9kZS5zdXBlckNsYXNzLnJhbmdlWzBdLFxuICAgICAgICBub2RlLnN1cGVyQ2xhc3MucmFuZ2VbMV1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVXNlZCB3aXRoIC5maWx0ZXIoKSB0byBmaW5kIHRoZSBjb25zdHJ1Y3RvciBtZXRob2QgaW4gYSBsaXN0IG9mXG4gKiBNZXRob2REZWZpbml0aW9uIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbGFzc0VsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIF9pc0NvbnN0cnVjdG9yTWV0aG9kKGNsYXNzRWxlbWVudCkge1xuICByZXR1cm4gY2xhc3NFbGVtZW50LnR5cGUgPT09IFN5bnRheC5NZXRob2REZWZpbml0aW9uICYmXG4gICAgICAgICBjbGFzc0VsZW1lbnQua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmXG4gICAgICAgICBjbGFzc0VsZW1lbnQua2V5Lm5hbWUgPT09ICdjb25zdHJ1Y3Rvcic7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX3Nob3VsZE11bmdlSWRlbnRpZmllcihub2RlLCBzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgICEhc3RhdGUubWV0aG9kRnVuY05vZGUgJiZcbiAgICAhdXRpbHMuZ2V0RG9jYmxvY2soc3RhdGUpLmhhc093blByb3BlcnR5KCdwcmV2ZW50TXVuZ2UnKSAmJlxuICAgIC9eXyg/IV8pLy50ZXN0KG5vZGUubmFtZSlcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZVxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7YXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVxuICovXG5mdW5jdGlvbiB2aXNpdENsYXNzTWV0aG9kKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmcub3B0cy5lczUgJiYgKG5vZGUua2luZCA9PT0gJ2dldCcgfHwgbm9kZS5raW5kID09PSAnc2V0JykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVGhpcyB0cmFuc2Zvcm0gZG9lcyBub3Qgc3VwcG9ydCAnICsgbm9kZS5raW5kICsgJ3RlciBtZXRob2RzIGZvciBFUzYgJyArXG4gICAgICAnY2xhc3Nlcy4gKGxpbmU6ICcgKyBub2RlLmxvYy5zdGFydC5saW5lICsgJywgY29sOiAnICtcbiAgICAgIG5vZGUubG9jLnN0YXJ0LmNvbHVtbiArICcpJ1xuICAgICk7XG4gIH1cbiAgc3RhdGUgPSB1dGlscy51cGRhdGVTdGF0ZShzdGF0ZSwge1xuICAgIG1ldGhvZE5vZGU6IG5vZGVcbiAgfSk7XG4gIHV0aWxzLmNhdGNodXAobm9kZS5yYW5nZVswXSwgc3RhdGUpO1xuICBwYXRoLnVuc2hpZnQobm9kZSk7XG4gIHRyYXZlcnNlKG5vZGUudmFsdWUsIHBhdGgsIHN0YXRlKTtcbiAgcGF0aC5zaGlmdCgpO1xuICByZXR1cm4gZmFsc2U7XG59XG52aXNpdENsYXNzTWV0aG9kLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguTWV0aG9kRGVmaW5pdGlvbjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge2FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqL1xuZnVuY3Rpb24gdmlzaXRDbGFzc0Z1bmN0aW9uRXhwcmVzc2lvbih0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdmFyIG1ldGhvZE5vZGUgPSBwYXRoWzBdO1xuICB2YXIgaXNHZXR0ZXIgPSBtZXRob2ROb2RlLmtpbmQgPT09ICdnZXQnO1xuICB2YXIgaXNTZXR0ZXIgPSBtZXRob2ROb2RlLmtpbmQgPT09ICdzZXQnO1xuXG4gIHN0YXRlID0gdXRpbHMudXBkYXRlU3RhdGUoc3RhdGUsIHtcbiAgICBtZXRob2RGdW5jTm9kZTogbm9kZVxuICB9KTtcblxuICBpZiAobWV0aG9kTm9kZS5rZXkubmFtZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgIHV0aWxzLmFwcGVuZCgnZnVuY3Rpb24gJyArIHN0YXRlLmNsYXNzTmFtZSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtZXRob2RBY2Nlc3NvckNvbXB1dGVkID0gZmFsc2U7XG4gICAgdmFyIG1ldGhvZEFjY2Vzc29yO1xuICAgIHZhciBwcm90b3R5cGVPclN0YXRpYyA9IG1ldGhvZE5vZGUuc3RhdGljID8gJycgOiAnLnByb3RvdHlwZSc7XG4gICAgdmFyIG9iamVjdEFjY2Vzc29yID0gc3RhdGUuY2xhc3NOYW1lICsgcHJvdG90eXBlT3JTdGF0aWM7XG5cbiAgICBpZiAobWV0aG9kTm9kZS5rZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgIC8vIGZvbygpIHt9XG4gICAgICBtZXRob2RBY2Nlc3NvciA9IG1ldGhvZE5vZGUua2V5Lm5hbWU7XG4gICAgICBpZiAoX3Nob3VsZE11bmdlSWRlbnRpZmllcihtZXRob2ROb2RlLmtleSwgc3RhdGUpKSB7XG4gICAgICAgIG1ldGhvZEFjY2Vzc29yID0gX2dldE11bmdlZE5hbWUobWV0aG9kQWNjZXNzb3IsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0dldHRlciB8fCBpc1NldHRlcikge1xuICAgICAgICBtZXRob2RBY2Nlc3NvciA9IEpTT04uc3RyaW5naWZ5KG1ldGhvZEFjY2Vzc29yKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzZXJ2ZWRXb3Jkc0hlbHBlci5pc1Jlc2VydmVkV29yZChtZXRob2RBY2Nlc3NvcikpIHtcbiAgICAgICAgbWV0aG9kQWNjZXNzb3JDb21wdXRlZCA9IHRydWU7XG4gICAgICAgIG1ldGhvZEFjY2Vzc29yID0gSlNPTi5zdHJpbmdpZnkobWV0aG9kQWNjZXNzb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWV0aG9kTm9kZS5rZXkudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgIC8vICdmb28gYmFyJygpIHt9ICB8IGdldCAnZm9vIGJhcicoKSB7fSB8IHNldCAnZm9vIGJhcicoKSB7fVxuICAgICAgbWV0aG9kQWNjZXNzb3IgPSBKU09OLnN0cmluZ2lmeShtZXRob2ROb2RlLmtleS52YWx1ZSk7XG4gICAgICBtZXRob2RBY2Nlc3NvckNvbXB1dGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNTZXR0ZXIgfHwgaXNHZXR0ZXIpIHtcbiAgICAgIHV0aWxzLmFwcGVuZChcbiAgICAgICAgJ09iamVjdC5kZWZpbmVQcm9wZXJ0eSgnICtcbiAgICAgICAgICBvYmplY3RBY2Nlc3NvciArICcsJyArXG4gICAgICAgICAgbWV0aG9kQWNjZXNzb3IgKyAnLCcgK1xuICAgICAgICAgICd7Y29uZmlndXJhYmxlOnRydWUsJyArXG4gICAgICAgICAgbWV0aG9kTm9kZS5raW5kICsgJzpmdW5jdGlvbicsXG4gICAgICAgIHN0YXRlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZy5vcHRzLmVzMykge1xuICAgICAgICBpZiAobWV0aG9kQWNjZXNzb3JDb21wdXRlZCkge1xuICAgICAgICAgIG1ldGhvZEFjY2Vzc29yID0gJ1snICsgbWV0aG9kQWNjZXNzb3IgKyAnXSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kQWNjZXNzb3IgPSAnLicgKyBtZXRob2RBY2Nlc3NvcjtcbiAgICAgICAgfVxuICAgICAgICB1dGlscy5hcHBlbmQoXG4gICAgICAgICAgb2JqZWN0QWNjZXNzb3IgK1xuICAgICAgICAgIG1ldGhvZEFjY2Vzc29yICsgJz1mdW5jdGlvbicgKyAobm9kZS5nZW5lcmF0b3IgPyAnKicgOiAnJyksXG4gICAgICAgICAgc3RhdGVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghbWV0aG9kQWNjZXNzb3JDb21wdXRlZCkge1xuICAgICAgICAgIG1ldGhvZEFjY2Vzc29yID0gSlNPTi5zdHJpbmdpZnkobWV0aG9kQWNjZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxzLmFwcGVuZChcbiAgICAgICAgICAnT2JqZWN0LmRlZmluZVByb3BlcnR5KCcgK1xuICAgICAgICAgICAgb2JqZWN0QWNjZXNzb3IgKyAnLCcgK1xuICAgICAgICAgICAgbWV0aG9kQWNjZXNzb3IgKyAnLCcgK1xuICAgICAgICAgICAgJ3t3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLCcgK1xuICAgICAgICAgICAgJ3ZhbHVlOmZ1bmN0aW9uJyArIChub2RlLmdlbmVyYXRvciA/ICcqJyA6ICcnKSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1dGlscy5tb3ZlKG1ldGhvZE5vZGUua2V5LnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHV0aWxzLmFwcGVuZCgnKCcsIHN0YXRlKTtcblxuICB2YXIgcGFyYW1zID0gbm9kZS5wYXJhbXM7XG4gIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgIHV0aWxzLmNhdGNodXBOZXdsaW5lcyhwYXJhbXNbMF0ucmFuZ2VbMF0sIHN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdXRpbHMuY2F0Y2h1cChub2RlLnBhcmFtc1tpXS5yYW5nZVswXSwgc3RhdGUpO1xuICAgICAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICAgICAgdHJhdmVyc2UocGFyYW1zW2ldLCBwYXRoLCBzdGF0ZSk7XG4gICAgICBwYXRoLnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3NpbmdQYXJlblBvc2l0aW9uID0gdXRpbHMuZ2V0TmV4dFN5bnRhY3RpY0NoYXJPZmZzZXQoJyknLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXBXaGl0ZVNwYWNlKGNsb3NpbmdQYXJlblBvc2l0aW9uLCBzdGF0ZSk7XG5cbiAgdmFyIG9wZW5pbmdCcmFja2V0UG9zaXRpb24gPSB1dGlscy5nZXROZXh0U3ludGFjdGljQ2hhck9mZnNldCgneycsIHN0YXRlKTtcbiAgdXRpbHMuY2F0Y2h1cChvcGVuaW5nQnJhY2tldFBvc2l0aW9uICsgMSwgc3RhdGUpO1xuXG4gIGlmICghc3RhdGUuc2NvcGVJc1N0cmljdCkge1xuICAgIHV0aWxzLmFwcGVuZCgnXCJ1c2Ugc3RyaWN0XCI7Jywgc3RhdGUpO1xuICAgIHN0YXRlID0gdXRpbHMudXBkYXRlU3RhdGUoc3RhdGUsIHtcbiAgICAgIHNjb3BlSXNTdHJpY3Q6IHRydWVcbiAgICB9KTtcbiAgfVxuICB1dGlscy5tb3ZlKG5vZGUuYm9keS5yYW5nZVswXSArICd7Jy5sZW5ndGgsIHN0YXRlKTtcblxuICBwYXRoLnVuc2hpZnQobm9kZSk7XG4gIHRyYXZlcnNlKG5vZGUuYm9keSwgcGF0aCwgc3RhdGUpO1xuICBwYXRoLnNoaWZ0KCk7XG4gIHV0aWxzLmNhdGNodXAobm9kZS5ib2R5LnJhbmdlWzFdLCBzdGF0ZSk7XG5cbiAgaWYgKG1ldGhvZE5vZGUua2V5Lm5hbWUgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICBpZiAoaXNHZXR0ZXIgfHwgaXNTZXR0ZXIgfHwgIXN0YXRlLmcub3B0cy5lczMpIHtcbiAgICAgIHV0aWxzLmFwcGVuZCgnfSknLCBzdGF0ZSk7XG4gICAgfVxuICAgIHV0aWxzLmFwcGVuZCgnOycsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52aXNpdENsYXNzRnVuY3Rpb25FeHByZXNzaW9uLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgICAmJiBwYXRoWzBdLnR5cGUgPT09IFN5bnRheC5NZXRob2REZWZpbml0aW9uO1xufTtcblxuZnVuY3Rpb24gdmlzaXRDbGFzc01ldGhvZFBhcmFtKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB2YXIgcGFyYW1OYW1lID0gbm9kZS5uYW1lO1xuICBpZiAoX3Nob3VsZE11bmdlSWRlbnRpZmllcihub2RlLCBzdGF0ZSkpIHtcbiAgICBwYXJhbU5hbWUgPSBfZ2V0TXVuZ2VkTmFtZShub2RlLm5hbWUsIHN0YXRlKTtcbiAgfVxuICB1dGlscy5hcHBlbmQocGFyYW1OYW1lLCBzdGF0ZSk7XG4gIHV0aWxzLm1vdmUobm9kZS5yYW5nZVsxXSwgc3RhdGUpO1xufVxudmlzaXRDbGFzc01ldGhvZFBhcmFtLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICBpZiAoIXBhdGhbMF0gfHwgIXBhdGhbMV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFyZW50RnVuY0V4cHIgPSBwYXRoWzBdO1xuICB2YXIgcGFyZW50Q2xhc3NNZXRob2QgPSBwYXRoWzFdO1xuXG4gIHJldHVybiBwYXJlbnRGdW5jRXhwci50eXBlID09PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgICAmJiBwYXJlbnRDbGFzc01ldGhvZC50eXBlID09PSBTeW50YXguTWV0aG9kRGVmaW5pdGlvblxuICAgICAgICAgJiYgbm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge2FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqL1xuZnVuY3Rpb24gX3JlbmRlckNsYXNzQm9keSh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHN0YXRlLmNsYXNzTmFtZTtcbiAgdmFyIHN1cGVyQ2xhc3MgPSBzdGF0ZS5zdXBlckNsYXNzO1xuXG4gIC8vIFNldCB1cCBwcm90b3R5cGUgb2YgY29uc3RydWN0b3Igb24gc2FtZSBsaW5lIGFzIGBleHRlbmRzYCBmb3IgbGluZS1udW1iZXJcbiAgLy8gcHJlc2VydmF0aW9uLiBUaGlzIHJlbGllcyBvbiBmdW5jdGlvbi1ob2lzdGluZyBpZiBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGlzXG4gIC8vIGRlZmluZWQgaW4gdGhlIGNsYXNzIGJvZHkuXG4gIGlmIChzdXBlckNsYXNzLm5hbWUpIHtcbiAgICAvLyBJZiB0aGUgc3VwZXIgY2xhc3MgaXMgYW4gZXhwcmVzc2lvbiwgd2UgbmVlZCB0byBtZW1vaXplIHRoZSBvdXRwdXQgb2YgdGhlXG4gICAgLy8gZXhwcmVzc2lvbiBpbnRvIHRoZSBnZW5lcmF0ZWQgY2xhc3MgbmFtZSB2YXJpYWJsZSBhbmQgdXNlIHRoYXQgdG8gcmVmZXJcbiAgICAvLyB0byB0aGUgc3VwZXIgY2xhc3MgZ29pbmcgZm9yd2FyZC4gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vICAgY2xhc3MgRm9vIGV4dGVuZHMgbWl4aW4oQmFyLCBCYXopIHt9XG4gICAgLy8gICAgIC0tdHJhbnNmb3JtcyB0by0tXG4gICAgLy8gICBmdW5jdGlvbiBGb28oKSB7fSB2YXIgX19fX0NsYXNzMEJsYWggPSBtaXhpbihCYXIsIEJheik7XG4gICAgaWYgKHN1cGVyQ2xhc3MuZXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdXRpbHMuYXBwZW5kKFxuICAgICAgICAndmFyICcgKyBzdXBlckNsYXNzLm5hbWUgKyAnPScgKyBzdXBlckNsYXNzLmV4cHJlc3Npb24gKyAnOycsXG4gICAgICAgIHN0YXRlXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBrZXlOYW1lID0gc3VwZXJDbGFzcy5uYW1lICsgJ19fX19LZXknO1xuICAgIHZhciBrZXlOYW1lRGVjbGFyYXRvciA9ICcnO1xuICAgIGlmICghdXRpbHMuaWRlbnRXaXRoaW5MZXhpY2FsU2NvcGUoa2V5TmFtZSwgc3RhdGUpKSB7XG4gICAgICBrZXlOYW1lRGVjbGFyYXRvciA9ICd2YXIgJztcbiAgICAgIGRlY2xhcmVJZGVudEluTG9jYWxTY29wZShrZXlOYW1lLCBpbml0U2NvcGVNZXRhZGF0YShub2RlKSwgc3RhdGUpO1xuICAgIH1cbiAgICB1dGlscy5hcHBlbmQoXG4gICAgICAnZm9yKCcgKyBrZXlOYW1lRGVjbGFyYXRvciArIGtleU5hbWUgKyAnIGluICcgKyBzdXBlckNsYXNzLm5hbWUgKyAnKXsnICtcbiAgICAgICAgJ2lmKCcgKyBzdXBlckNsYXNzLm5hbWUgKyAnLmhhc093blByb3BlcnR5KCcgKyBrZXlOYW1lICsgJykpeycgK1xuICAgICAgICAgIGNsYXNzTmFtZSArICdbJyArIGtleU5hbWUgKyAnXT0nICtcbiAgICAgICAgICAgIHN1cGVyQ2xhc3MubmFtZSArICdbJyArIGtleU5hbWUgKyAnXTsnICtcbiAgICAgICAgJ30nICtcbiAgICAgICd9JyxcbiAgICAgIHN0YXRlXG4gICAgKTtcblxuICAgIHZhciBzdXBlclByb3RvSWRlbnRTdHIgPSBTVVBFUl9QUk9UT19JREVOVF9QUkVGSVggKyBzdXBlckNsYXNzLm5hbWU7XG4gICAgaWYgKCF1dGlscy5pZGVudFdpdGhpbkxleGljYWxTY29wZShzdXBlclByb3RvSWRlbnRTdHIsIHN0YXRlKSkge1xuICAgICAgdXRpbHMuYXBwZW5kKFxuICAgICAgICAndmFyICcgKyBzdXBlclByb3RvSWRlbnRTdHIgKyAnPScgKyBzdXBlckNsYXNzLm5hbWUgKyAnPT09bnVsbD8nICtcbiAgICAgICAgJ251bGw6JyArIHN1cGVyQ2xhc3MubmFtZSArICcucHJvdG90eXBlOycsXG4gICAgICAgIHN0YXRlXG4gICAgICApO1xuICAgICAgZGVjbGFyZUlkZW50SW5Mb2NhbFNjb3BlKHN1cGVyUHJvdG9JZGVudFN0ciwgaW5pdFNjb3BlTWV0YWRhdGEobm9kZSksIHN0YXRlKTtcbiAgICB9XG5cbiAgICB1dGlscy5hcHBlbmQoXG4gICAgICBjbGFzc05hbWUgKyAnLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKCcgKyBzdXBlclByb3RvSWRlbnRTdHIgKyAnKTsnLFxuICAgICAgc3RhdGVcbiAgICApO1xuICAgIHV0aWxzLmFwcGVuZChcbiAgICAgIGNsYXNzTmFtZSArICcucHJvdG90eXBlLmNvbnN0cnVjdG9yPScgKyBjbGFzc05hbWUgKyAnOycsXG4gICAgICBzdGF0ZVxuICAgICk7XG4gICAgdXRpbHMuYXBwZW5kKFxuICAgICAgY2xhc3NOYW1lICsgJy5fX3N1cGVyQ29uc3RydWN0b3JfXz0nICsgc3VwZXJDbGFzcy5uYW1lICsgJzsnLFxuICAgICAgc3RhdGVcbiAgICApO1xuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBubyBjb25zdHJ1Y3RvciBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBjbGFzcyBib2R5LCBjcmVhdGUgYW5cbiAgLy8gZW1wdHkgY29uc3RydWN0b3IgZnVuY3Rpb24gYXQgdGhlIHRvcCAoc2FtZSBsaW5lIGFzIHRoZSBjbGFzcyBrZXl3b3JkKVxuICBpZiAoIW5vZGUuYm9keS5ib2R5LmZpbHRlcihfaXNDb25zdHJ1Y3Rvck1ldGhvZCkucG9wKCkpIHtcbiAgICB1dGlscy5hcHBlbmQoJ2Z1bmN0aW9uICcgKyBjbGFzc05hbWUgKyAnKCl7Jywgc3RhdGUpO1xuICAgIGlmICghc3RhdGUuc2NvcGVJc1N0cmljdCkge1xuICAgICAgdXRpbHMuYXBwZW5kKCdcInVzZSBzdHJpY3RcIjsnLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdXBlckNsYXNzLm5hbWUpIHtcbiAgICAgIHV0aWxzLmFwcGVuZChcbiAgICAgICAgJ2lmKCcgKyBzdXBlckNsYXNzLm5hbWUgKyAnIT09bnVsbCl7JyArXG4gICAgICAgIHN1cGVyQ2xhc3MubmFtZSArICcuYXBwbHkodGhpcyxhcmd1bWVudHMpO30nLFxuICAgICAgICBzdGF0ZVxuICAgICAgKTtcbiAgICB9XG4gICAgdXRpbHMuYXBwZW5kKCd9Jywgc3RhdGUpO1xuICB9XG5cbiAgdXRpbHMubW92ZShub2RlLmJvZHkucmFuZ2VbMF0gKyAneycubGVuZ3RoLCBzdGF0ZSk7XG4gIHRyYXZlcnNlKG5vZGUuYm9keSwgcGF0aCwgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwV2hpdGVTcGFjZShub2RlLnJhbmdlWzFdLCBzdGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge2FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqL1xuZnVuY3Rpb24gdmlzaXRDbGFzc0RlY2xhcmF0aW9uKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB2YXIgY2xhc3NOYW1lID0gbm9kZS5pZC5uYW1lO1xuICB2YXIgc3VwZXJDbGFzcyA9IF9nZXRTdXBlckNsYXNzSW5mbyhub2RlLCBzdGF0ZSk7XG5cbiAgc3RhdGUgPSB1dGlscy51cGRhdGVTdGF0ZShzdGF0ZSwge1xuICAgIG11bmdlTmFtZXNwYWNlOiBjbGFzc05hbWUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3VwZXJDbGFzczogc3VwZXJDbGFzc1xuICB9KTtcblxuICBfcmVuZGVyQ2xhc3NCb2R5KHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxudmlzaXRDbGFzc0RlY2xhcmF0aW9uLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguQ2xhc3NEZWNsYXJhdGlvbjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge2FycmF5fSBwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqL1xuZnVuY3Rpb24gdmlzaXRDbGFzc0V4cHJlc3Npb24odHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHZhciBjbGFzc05hbWUgPSBub2RlLmlkICYmIG5vZGUuaWQubmFtZSB8fCBfZ2VuZXJhdGVBbm9ueW1vdXNDbGFzc05hbWUoc3RhdGUpO1xuICB2YXIgc3VwZXJDbGFzcyA9IF9nZXRTdXBlckNsYXNzSW5mbyhub2RlLCBzdGF0ZSk7XG5cbiAgdXRpbHMuYXBwZW5kKCcoZnVuY3Rpb24oKXsnLCBzdGF0ZSk7XG5cbiAgc3RhdGUgPSB1dGlscy51cGRhdGVTdGF0ZShzdGF0ZSwge1xuICAgIG11bmdlTmFtZXNwYWNlOiBjbGFzc05hbWUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3VwZXJDbGFzczogc3VwZXJDbGFzc1xuICB9KTtcblxuICBfcmVuZGVyQ2xhc3NCb2R5KHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSk7XG5cbiAgdXRpbHMuYXBwZW5kKCdyZXR1cm4gJyArIGNsYXNzTmFtZSArICc7fSkoKScsIHN0YXRlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxudmlzaXRDbGFzc0V4cHJlc3Npb24udGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFN5bnRheC5DbGFzc0V4cHJlc3Npb247XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHthcnJheX0gcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKi9cbmZ1bmN0aW9uIHZpc2l0UHJpdmF0ZUlkZW50aWZpZXIodHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHV0aWxzLmFwcGVuZChfZ2V0TXVuZ2VkTmFtZShub2RlLm5hbWUsIHN0YXRlKSwgc3RhdGUpO1xuICB1dGlscy5tb3ZlKG5vZGUucmFuZ2VbMV0sIHN0YXRlKTtcbn1cbnZpc2l0UHJpdmF0ZUlkZW50aWZpZXIudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIF9zaG91bGRNdW5nZUlkZW50aWZpZXIobm9kZSwgc3RhdGUpKSB7XG4gICAgLy8gQWx3YXlzIG11bmdlIG5vbi1jb21wdXRlZCBwcm9wZXJ0aWVzIG9mIE1lbWJlckV4cHJlc3Npb25zXG4gICAgLy8gKGEgbGEgcHJldmVudGluZyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBvZiB1bm93bmVkIG9iamVjdHMpXG4gICAgaWYgKHBhdGhbMF0udHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgcGF0aFswXS5vYmplY3QgIT09IG5vZGVcbiAgICAgICAgJiYgcGF0aFswXS5jb21wdXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBtdW5nZSBpZGVudGlmaWVycyB0aGF0IHdlcmUgZGVjbGFyZWQgd2l0aGluIHRoZSBtZXRob2QgZnVuY3Rpb25cbiAgICAvLyBzY29wZVxuICAgIGlmICh1dGlscy5pZGVudFdpdGhpbkxleGljYWxTY29wZShub2RlLm5hbWUsIHN0YXRlLCBzdGF0ZS5tZXRob2RGdW5jTm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBtdW5nZSBwcml2YXRlIGtleXMgb24gb2JqZWN0IGxpdGVyYWxzIGRlZmluZWQgd2l0aGluIGEgbWV0aG9kJ3NcbiAgICAvLyBzY29wZS5cbiAgICBpZiAocGF0aFswXS50eXBlID09PSBTeW50YXguUHJvcGVydHlcbiAgICAgICAgJiYgcGF0aFsxXS50eXBlID09PSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIG11bmdlIGZ1bmN0aW9uIHBhcmFtZXRlcnNcbiAgICBpZiAocGF0aFswXS50eXBlID09PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgIHx8IHBhdGhbMF0udHlwZSA9PT0gU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb25cbiAgICAgICAgfHwgcGF0aFswXS50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aFswXS5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGhbMF0ucGFyYW1zW2ldID09PSBub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZVxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7YXJyYXl9IHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVxuICovXG5mdW5jdGlvbiB2aXNpdFN1cGVyQ2FsbEV4cHJlc3Npb24odHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHZhciBzdXBlckNsYXNzTmFtZSA9IHN0YXRlLnN1cGVyQ2xhc3MubmFtZTtcblxuICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICBpZiAoX2lzQ29uc3RydWN0b3JNZXRob2Qoc3RhdGUubWV0aG9kTm9kZSkpIHtcbiAgICAgIHV0aWxzLmFwcGVuZChzdXBlckNsYXNzTmFtZSArICcuY2FsbCgnLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcm90b1Byb3AgPSBTVVBFUl9QUk9UT19JREVOVF9QUkVGSVggKyBzdXBlckNsYXNzTmFtZTtcbiAgICAgIGlmIChzdGF0ZS5tZXRob2ROb2RlLmtleS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICBwcm90b1Byb3AgKz0gJy4nICsgc3RhdGUubWV0aG9kTm9kZS5rZXkubmFtZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubWV0aG9kTm9kZS5rZXkudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgcHJvdG9Qcm9wICs9ICdbJyArIEpTT04uc3RyaW5naWZ5KHN0YXRlLm1ldGhvZE5vZGUua2V5LnZhbHVlKSArICddJztcbiAgICAgIH1cbiAgICAgIHV0aWxzLmFwcGVuZChwcm90b1Byb3AgKyBcIi5jYWxsKFwiLCBzdGF0ZSk7XG4gICAgfVxuICAgIHV0aWxzLm1vdmUobm9kZS5jYWxsZWUucmFuZ2VbMV0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChub2RlLmNhbGxlZS50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbikge1xuICAgIHV0aWxzLmFwcGVuZChTVVBFUl9QUk9UT19JREVOVF9QUkVGSVggKyBzdXBlckNsYXNzTmFtZSwgc3RhdGUpO1xuICAgIHV0aWxzLm1vdmUobm9kZS5jYWxsZWUub2JqZWN0LnJhbmdlWzFdLCBzdGF0ZSk7XG5cbiAgICBpZiAobm9kZS5jYWxsZWUuY29tcHV0ZWQpIHtcbiAgICAgIC8vIFtcImFcIiArIFwiYlwiXVxuICAgICAgdXRpbHMuY2F0Y2h1cChub2RlLmNhbGxlZS5wcm9wZXJ0eS5yYW5nZVsxXSArICddJy5sZW5ndGgsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gLmFiXG4gICAgICB1dGlscy5hcHBlbmQoJy4nICsgbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSwgc3RhdGUpO1xuICAgIH1cblxuICAgIHV0aWxzLmFwcGVuZCgnLmNhbGwoJywgc3RhdGUpO1xuICAgIHV0aWxzLm1vdmUobm9kZS5jYWxsZWUucmFuZ2VbMV0sIHN0YXRlKTtcbiAgfVxuXG4gIHV0aWxzLmFwcGVuZCgndGhpcycsIHN0YXRlKTtcbiAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICB1dGlscy5hcHBlbmQoJywnLCBzdGF0ZSk7XG4gICAgdXRpbHMuY2F0Y2h1cFdoaXRlU3BhY2Uobm9kZS5hcmd1bWVudHNbMF0ucmFuZ2VbMF0sIHN0YXRlKTtcbiAgICB0cmF2ZXJzZShub2RlLmFyZ3VtZW50cywgcGF0aCwgc3RhdGUpO1xuICB9XG5cbiAgdXRpbHMuY2F0Y2h1cFdoaXRlU3BhY2Uobm9kZS5yYW5nZVsxXSwgc3RhdGUpO1xuICB1dGlscy5hcHBlbmQoJyknLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbnZpc2l0U3VwZXJDYWxsRXhwcmVzc2lvbi50ZXN0ID0gZnVuY3Rpb24obm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnN1cGVyQ2xhc3MgJiYgbm9kZS50eXBlID09PSBTeW50YXguQ2FsbEV4cHJlc3Npb24pIHtcbiAgICB2YXIgY2FsbGVlID0gbm9kZS5jYWxsZWU7XG4gICAgaWYgKGNhbGxlZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBjYWxsZWUubmFtZSA9PT0gJ3N1cGVyJ1xuICAgICAgICB8fCBjYWxsZWUudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvblxuICAgICAgICAgICAmJiBjYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdzdXBlcicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHthcnJheX0gcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKi9cbmZ1bmN0aW9uIHZpc2l0U3VwZXJNZW1iZXJFeHByZXNzaW9uKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB2YXIgc3VwZXJDbGFzc05hbWUgPSBzdGF0ZS5zdXBlckNsYXNzLm5hbWU7XG5cbiAgdXRpbHMuYXBwZW5kKFNVUEVSX1BST1RPX0lERU5UX1BSRUZJWCArIHN1cGVyQ2xhc3NOYW1lLCBzdGF0ZSk7XG4gIHV0aWxzLm1vdmUobm9kZS5vYmplY3QucmFuZ2VbMV0sIHN0YXRlKTtcbn1cbnZpc2l0U3VwZXJNZW1iZXJFeHByZXNzaW9uLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuc3VwZXJDbGFzc1xuICAgICAgICAgJiYgbm9kZS50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvblxuICAgICAgICAgJiYgbm9kZS5vYmplY3QudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXJcbiAgICAgICAgICYmIG5vZGUub2JqZWN0Lm5hbWUgPT09ICdzdXBlcic7XG59O1xuXG5leHBvcnRzLnJlc2V0U3ltYm9scyA9IHJlc2V0U3ltYm9scztcblxuZXhwb3J0cy52aXNpdG9yTGlzdCA9IFtcbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uLFxuICB2aXNpdENsYXNzRXhwcmVzc2lvbixcbiAgdmlzaXRDbGFzc0Z1bmN0aW9uRXhwcmVzc2lvbixcbiAgdmlzaXRDbGFzc01ldGhvZCxcbiAgdmlzaXRDbGFzc01ldGhvZFBhcmFtLFxuICB2aXNpdFByaXZhdGVJZGVudGlmaWVyLFxuICB2aXNpdFN1cGVyQ2FsbEV4cHJlc3Npb24sXG4gIHZpc2l0U3VwZXJNZW1iZXJFeHByZXNzaW9uXG5dO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKmdsb2JhbCBleHBvcnRzOnRydWUqL1xuXG4vKipcbiAqIEltcGxlbWVudHMgRVM2IGRlc3RydWN0dXJpbmcgYXNzaWdubWVudCBhbmQgcGF0dGVybiBtYXRjaG5nLlxuICpcbiAqIGZ1bmN0aW9uIGluaXQoe3BvcnQsIGlwLCBjb29yZHM6IFt4LCB5XX0pIHtcbiAqICAgcmV0dXJuICh4ICYmIHkpID8ge2lkLCBwb3J0fSA6IHtpcH07XG4gKiB9O1xuICpcbiAqIGZ1bmN0aW9uIGluaXQoJF9fMCkge1xuICogICB2YXJcbiAqICAgIHBvcnQgPSAkX18wLnBvcnQsXG4gKiAgICBpcCA9ICRfXzAuaXAsXG4gKiAgICAkX18xID0gJF9fMC5jb29yZHMsXG4gKiAgICB4ID0gJF9fMVswXSxcbiAqICAgIHkgPSAkX18xWzFdO1xuICogICByZXR1cm4gKHggJiYgeSkgPyB7aWQsIHBvcnR9IDoge2lwfTtcbiAqIH1cbiAqXG4gKiB2YXIgeCwge2lwLCBwb3J0fSA9IGluaXQoe2lwLCBwb3J0fSk7XG4gKlxuICogdmFyIHgsICRfXzAgPSBpbml0KHtpcCwgcG9ydH0pLCBpcCA9ICRfXzAuaXAsIHBvcnQgPSAkX18wLnBvcnQ7XG4gKlxuICovXG52YXIgU3ludGF4ID0gcmVxdWlyZSgnZXNwcmltYS1mYicpLlN5bnRheDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3NyYy91dGlscycpO1xuXG52YXIgcmVzZXJ2ZWRXb3Jkc0hlbHBlciA9IHJlcXVpcmUoJy4vcmVzZXJ2ZWQtd29yZHMtaGVscGVyJyk7XG52YXIgcmVzdFBhcmFtVmlzaXRvcnMgPSByZXF1aXJlKCcuL2VzNi1yZXN0LXBhcmFtLXZpc2l0b3JzJyk7XG52YXIgcmVzdFByb3BlcnR5SGVscGVycyA9IHJlcXVpcmUoJy4vZXM3LXJlc3QtcHJvcGVydHktaGVscGVycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAxLiBTdHJ1Y3R1cmVkIHZhcmlhYmxlIGRlY2xhcmF0aW9ucy5cbi8vXG4vLyB2YXIgW2EsIGJdID0gW2IsIGFdO1xuLy8gdmFyIHt4LCB5fSA9IHt5LCB4fTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdmlzaXRTdHJ1Y3R1cmVkVmFyaWFibGUodHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIC8vIEFsbG9jYXRlIG5ldyB0ZW1wIGZvciB0aGUgcGF0dGVybi5cbiAgdXRpbHMuYXBwZW5kKHV0aWxzLmdldFRlbXBWYXIoc3RhdGUubG9jYWxTY29wZS50ZW1wVmFySW5kZXgpICsgJz0nLCBzdGF0ZSk7XG4gIC8vIFNraXAgdGhlIHBhdHRlcm4gYW5kIGFzc2lnbiB0aGUgaW5pdCB0byB0aGUgdGVtcC5cbiAgdXRpbHMuY2F0Y2h1cFdoaXRlU3BhY2Uobm9kZS5pbml0LnJhbmdlWzBdLCBzdGF0ZSk7XG4gIHRyYXZlcnNlKG5vZGUuaW5pdCwgcGF0aCwgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwKG5vZGUuaW5pdC5yYW5nZVsxXSwgc3RhdGUpO1xuICAvLyBSZW5kZXIgdGhlIGRlc3RydWN0dXJlZCBkYXRhLlxuICB1dGlscy5hcHBlbmQoJywnICsgZ2V0RGVzdHJ1Y3R1cmVkQ29tcG9uZW50cyhub2RlLmlkLCBzdGF0ZSksIHN0YXRlKTtcbiAgc3RhdGUubG9jYWxTY29wZS50ZW1wVmFySW5kZXgrKztcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52aXNpdFN0cnVjdHVyZWRWYXJpYWJsZS50ZXN0ID0gZnVuY3Rpb24obm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvciAmJlxuICAgIGlzU3RydWN0dXJlZFBhdHRlcm4obm9kZS5pZCk7XG59O1xuXG5mdW5jdGlvbiBpc1N0cnVjdHVyZWRQYXR0ZXJuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4Lk9iamVjdFBhdHRlcm4gfHxcbiAgICBub2RlLnR5cGUgPT09IFN5bnRheC5BcnJheVBhdHRlcm47XG59XG5cbi8vIE1haW4gZnVuY3Rpb24gd2hpY2ggZG9lcyBhY3R1YWwgcmVjdXJzaXZlIGRlc3RydWN0dXJpbmdcbi8vIG9mIG5lc3RlZCBjb21wbGV4IHN0cnVjdHVyZXMuXG5mdW5jdGlvbiBnZXREZXN0cnVjdHVyZWRDb21wb25lbnRzKG5vZGUsIHN0YXRlKSB7XG4gIHZhciB0bXBJbmRleCA9IHN0YXRlLmxvY2FsU2NvcGUudGVtcFZhckluZGV4O1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICB2YXIgcGF0dGVybkl0ZW1zID0gZ2V0UGF0dGVybkl0ZW1zKG5vZGUpO1xuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHBhdHRlcm5JdGVtcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdmFyIGl0ZW0gPSBwYXR0ZXJuSXRlbXNbaWR4XTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpdGVtLnR5cGUgPT09IFN5bnRheC5TcHJlYWRFbGVtZW50KSB7XG4gICAgICAvLyBTcHJlYWQvcmVzdCBvZiBhbiBhcnJheS5cbiAgICAgIC8vIFRPRE8oZG1pdHJ5cyk6IHN1cHBvcnQgc3ByZWFkIGluIHRoZSBtaWRkbGUgb2YgYSBwYXR0ZXJuXG4gICAgICAvLyBhbmQgYWxzbyBmb3IgZnVuY3Rpb24gcGFyYW0gcGF0dGVybnM6IFt4LCAuLi54cywgeV1cbiAgICAgIGNvbXBvbmVudHMucHVzaChpdGVtLmFyZ3VtZW50Lm5hbWUgK1xuICAgICAgICAnPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCcgK1xuICAgICAgICB1dGlscy5nZXRUZW1wVmFyKHRtcEluZGV4KSArICcsJyArIGlkeCArICcpJ1xuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpdGVtLnR5cGUgPT09IFN5bnRheC5TcHJlYWRQcm9wZXJ0eSkge1xuICAgICAgdmFyIHJlc3RFeHByZXNzaW9uID0gcmVzdFByb3BlcnR5SGVscGVycy5yZW5kZXJSZXN0RXhwcmVzc2lvbihcbiAgICAgICAgdXRpbHMuZ2V0VGVtcFZhcih0bXBJbmRleCksXG4gICAgICAgIHBhdHRlcm5JdGVtc1xuICAgICAgKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChpdGVtLmFyZ3VtZW50Lm5hbWUgKyAnPScgKyByZXN0RXhwcmVzc2lvbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBEZXBlbmRpbmcgb24gcGF0dGVybiB0eXBlIChBcnJheSBvciBPYmplY3QpLCB3ZSBnZXRcbiAgICAvLyBjb3JyZXNwb25kaW5nIHBhdHRlcm4gaXRlbSBwYXJ0cy5cbiAgICB2YXIgYWNjZXNzb3IgPSBnZXRQYXR0ZXJuSXRlbUFjY2Vzc29yKG5vZGUsIGl0ZW0sIHRtcEluZGV4LCBpZHgpO1xuICAgIHZhciB2YWx1ZSA9IGdldFBhdHRlcm5JdGVtVmFsdWUobm9kZSwgaXRlbSk7XG5cbiAgICAvLyBUT0RPKGRtaXRyeXMpOiBpbXBsZW1lbnQgZGVmYXVsdCB2YWx1ZXM6IHt4LCB5PTV9XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAvLyBTaW1wbGUgcGF0dGVybiBpdGVtLlxuICAgICAgY29tcG9uZW50cy5wdXNoKHZhbHVlLm5hbWUgKyAnPScgKyBhY2Nlc3Nvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbXBsZXggc3ViLXN0cnVjdHVyZS5cbiAgICAgIGNvbXBvbmVudHMucHVzaChcbiAgICAgICAgdXRpbHMuZ2V0VGVtcFZhcigrK3N0YXRlLmxvY2FsU2NvcGUudGVtcFZhckluZGV4KSArICc9JyArIGFjY2Vzc29yICtcbiAgICAgICAgJywnICsgZ2V0RGVzdHJ1Y3R1cmVkQ29tcG9uZW50cyh2YWx1ZSwgc3RhdGUpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzLmpvaW4oJywnKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF0dGVybkl0ZW1zKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucHJvcGVydGllcyB8fCBub2RlLmVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXR0ZXJuSXRlbUFjY2Vzc29yKG5vZGUsIHBhdHRlcm5JdGVtLCB0bXBJbmRleCwgaWR4KSB7XG4gIHZhciB0bXBOYW1lID0gdXRpbHMuZ2V0VGVtcFZhcih0bXBJbmRleCk7XG4gIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5PYmplY3RQYXR0ZXJuKSB7XG4gICAgaWYgKHJlc2VydmVkV29yZHNIZWxwZXIuaXNSZXNlcnZlZFdvcmQocGF0dGVybkl0ZW0ua2V5Lm5hbWUpKSB7XG4gICAgICByZXR1cm4gdG1wTmFtZSArICdbXCInICsgcGF0dGVybkl0ZW0ua2V5Lm5hbWUgKyAnXCJdJztcbiAgICB9IGVsc2UgaWYgKHBhdHRlcm5JdGVtLmtleS50eXBlID09PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIHRtcE5hbWUgKyAnWycgKyBKU09OLnN0cmluZ2lmeShwYXR0ZXJuSXRlbS5rZXkudmFsdWUpICsgJ10nO1xuICAgIH0gZWxzZSBpZiAocGF0dGVybkl0ZW0ua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gdG1wTmFtZSArICcuJyArIHBhdHRlcm5JdGVtLmtleS5uYW1lO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5BcnJheVBhdHRlcm4pIHtcbiAgICByZXR1cm4gdG1wTmFtZSArICdbJyArIGlkeCArICddJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXR0ZXJuSXRlbVZhbHVlKG5vZGUsIHBhdHRlcm5JdGVtKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFN5bnRheC5PYmplY3RQYXR0ZXJuXG4gICAgPyBwYXR0ZXJuSXRlbS52YWx1ZVxuICAgIDogcGF0dGVybkl0ZW07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDIuIEFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbi8vXG4vLyBbYSwgYl0gPSBbYiwgYV07XG4vLyAoe3gsIHl9ID0ge3ksIHh9KTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdmlzaXRTdHJ1Y3R1cmVkQXNzaWdubWVudCh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdmFyIGV4cHJOb2RlID0gbm9kZS5leHByZXNzaW9uO1xuICB1dGlscy5hcHBlbmQoJ3ZhciAnICsgdXRpbHMuZ2V0VGVtcFZhcihzdGF0ZS5sb2NhbFNjb3BlLnRlbXBWYXJJbmRleCkgKyAnPScsIHN0YXRlKTtcblxuICB1dGlscy5jYXRjaHVwV2hpdGVTcGFjZShleHByTm9kZS5yaWdodC5yYW5nZVswXSwgc3RhdGUpO1xuICB0cmF2ZXJzZShleHByTm9kZS5yaWdodCwgcGF0aCwgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwKGV4cHJOb2RlLnJpZ2h0LnJhbmdlWzFdLCBzdGF0ZSk7XG5cbiAgdXRpbHMuYXBwZW5kKFxuICAgICc7JyArIGdldERlc3RydWN0dXJlZENvbXBvbmVudHMoZXhwck5vZGUubGVmdCwgc3RhdGUpICsgJzsnLFxuICAgIHN0YXRlXG4gICk7XG5cbiAgdXRpbHMuY2F0Y2h1cFdoaXRlU3BhY2Uobm9kZS5yYW5nZVsxXSwgc3RhdGUpO1xuICBzdGF0ZS5sb2NhbFNjb3BlLnRlbXBWYXJJbmRleCsrO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbnZpc2l0U3RydWN0dXJlZEFzc2lnbm1lbnQudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIC8vIFdlIGNvbnNpZGVyIHRoZSBleHByZXNzaW9uIHN0YXRlbWVudCByYXRoZXIgdGhhbiBqdXN0IGFzc2lnbm1lbnRcbiAgLy8gZXhwcmVzc2lvbiB0byBjb3ZlciBjYXNlIHdpdGggb2JqZWN0IHBhdHRlcnMgd2hpY2ggc2hvdWxkIGJlXG4gIC8vIHdyYXBwZWQgaW4gZ3JvdXBpbmcgb3BlcmF0b3I6ICh7eCwgeX0gPSB7eSwgeH0pO1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCAmJlxuICAgIG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiZcbiAgICBpc1N0cnVjdHVyZWRQYXR0ZXJuKG5vZGUuZXhwcmVzc2lvbi5sZWZ0KTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDMuIFN0cnVjdHVyZWQgcGFyYW1ldGVyLlxuLy9cbi8vIGZ1bmN0aW9uIGZvbyh7eCwgeX0pIHsgLi4uIH1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdmlzaXRTdHJ1Y3R1cmVkUGFyYW1ldGVyKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB1dGlscy5hcHBlbmQodXRpbHMuZ2V0VGVtcFZhcihnZXRQYXJhbUluZGV4KG5vZGUsIHBhdGgpKSwgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwV2hpdGVTcGFjZShub2RlLnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbUluZGV4KHBhcmFtTm9kZSwgcGF0aCkge1xuICB2YXIgZnVuY05vZGUgPSBwYXRoWzBdO1xuICB2YXIgdG1wSW5kZXggPSAwO1xuICBmb3IgKHZhciBrID0gMDsgayA8IGZ1bmNOb2RlLnBhcmFtcy5sZW5ndGg7IGsrKykge1xuICAgIHZhciBwYXJhbSA9IGZ1bmNOb2RlLnBhcmFtc1trXTtcbiAgICBpZiAocGFyYW0gPT09IHBhcmFtTm9kZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpc1N0cnVjdHVyZWRQYXR0ZXJuKHBhcmFtKSkge1xuICAgICAgdG1wSW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRtcEluZGV4O1xufVxuXG52aXNpdFN0cnVjdHVyZWRQYXJhbWV0ZXIudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBpc1N0cnVjdHVyZWRQYXR0ZXJuKG5vZGUpICYmIGlzRnVuY3Rpb25Ob2RlKHBhdGhbMF0pO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbk5vZGUobm9kZSkge1xuICByZXR1cm4gKG5vZGUudHlwZSA9PSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbiB8fFxuICAgIG5vZGUudHlwZSA9PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uIHx8XG4gICAgbm9kZS50eXBlID09IFN5bnRheC5NZXRob2REZWZpbml0aW9uIHx8XG4gICAgbm9kZS50eXBlID09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbik7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDQuIEZ1bmN0aW9uIGJvZHkgZm9yIHN0cnVjdHVyZWQgcGFyYW1ldGVycy5cbi8vXG4vLyBmdW5jdGlvbiBmb28oe3gsIHl9KSB7IHg7IHk7IH1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdmlzaXRGdW5jdGlvbkJvZHlGb3JTdHJ1Y3R1cmVkUGFyYW1ldGVyKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB2YXIgZnVuY05vZGUgPSBwYXRoWzBdO1xuXG4gIHV0aWxzLmNhdGNodXAoZnVuY05vZGUuYm9keS5yYW5nZVswXSArIDEsIHN0YXRlKTtcbiAgcmVuZGVyRGVzdHJ1Y3R1cmVkQ29tcG9uZW50cyhmdW5jTm9kZSwgc3RhdGUpO1xuXG4gIGlmIChmdW5jTm9kZS5yZXN0KSB7XG4gICAgdXRpbHMuYXBwZW5kKFxuICAgICAgcmVzdFBhcmFtVmlzaXRvcnMucmVuZGVyUmVzdFBhcmFtU2V0dXAoZnVuY05vZGUsIHN0YXRlKSxcbiAgICAgIHN0YXRlXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJEZXN0cnVjdHVyZWRDb21wb25lbnRzKGZ1bmNOb2RlLCBzdGF0ZSkge1xuICB2YXIgZGVzdHJ1Y3R1cmVkQ29tcG9uZW50cyA9IFtdO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgZnVuY05vZGUucGFyYW1zLmxlbmd0aDsgaysrKSB7XG4gICAgdmFyIHBhcmFtID0gZnVuY05vZGUucGFyYW1zW2tdO1xuICAgIGlmIChpc1N0cnVjdHVyZWRQYXR0ZXJuKHBhcmFtKSkge1xuICAgICAgZGVzdHJ1Y3R1cmVkQ29tcG9uZW50cy5wdXNoKFxuICAgICAgICBnZXREZXN0cnVjdHVyZWRDb21wb25lbnRzKHBhcmFtLCBzdGF0ZSlcbiAgICAgICk7XG4gICAgICBzdGF0ZS5sb2NhbFNjb3BlLnRlbXBWYXJJbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXN0cnVjdHVyZWRDb21wb25lbnRzLmxlbmd0aCkge1xuICAgIHV0aWxzLmFwcGVuZCgndmFyICcgKyBkZXN0cnVjdHVyZWRDb21wb25lbnRzLmpvaW4oJywnKSArICc7Jywgc3RhdGUpO1xuICB9XG59XG5cbnZpc2l0RnVuY3Rpb25Cb2R5Rm9yU3RydWN0dXJlZFBhcmFtZXRlci50ZXN0ID0gZnVuY3Rpb24obm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmIGlzRnVuY3Rpb25Ob2RlKHBhdGhbMF0pO1xufTtcblxuZXhwb3J0cy52aXNpdG9yTGlzdCA9IFtcbiAgdmlzaXRTdHJ1Y3R1cmVkVmFyaWFibGUsXG4gIHZpc2l0U3RydWN0dXJlZEFzc2lnbm1lbnQsXG4gIHZpc2l0U3RydWN0dXJlZFBhcmFtZXRlcixcbiAgdmlzaXRGdW5jdGlvbkJvZHlGb3JTdHJ1Y3R1cmVkUGFyYW1ldGVyXG5dO1xuXG5leHBvcnRzLnJlbmRlckRlc3RydWN0dXJlZENvbXBvbmVudHMgPSByZW5kZXJEZXN0cnVjdHVyZWRDb21wb25lbnRzO1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypqc2xpbnQgbm9kZTp0cnVlKi9cblxuLyoqXG4gKiBEZXN1Z2FycyBjb25jaXNlIG1ldGhvZHMgb2Ygb2JqZWN0cyB0byBmdW5jdGlvbiBleHByZXNzaW9ucy5cbiAqXG4gKiB2YXIgZm9vID0ge1xuICogICBtZXRob2QoeCwgeSkgeyAuLi4gfVxuICogfTtcbiAqXG4gKiB2YXIgZm9vID0ge1xuICogICBtZXRob2Q6IGZ1bmN0aW9uKHgsIHkpIHsgLi4uIH1cbiAqIH07XG4gKlxuICovXG5cbnZhciBTeW50YXggPSByZXF1aXJlKCdlc3ByaW1hLWZiJykuU3ludGF4O1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vc3JjL3V0aWxzJyk7XG52YXIgcmVzZXJ2ZWRXb3Jkc0hlbHBlciA9IHJlcXVpcmUoJy4vcmVzZXJ2ZWQtd29yZHMtaGVscGVyJyk7XG5cbmZ1bmN0aW9uIHZpc2l0T2JqZWN0Q29uY2lzZU1ldGhvZCh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdmFyIGlzR2VuZXJhdG9yID0gbm9kZS52YWx1ZS5nZW5lcmF0b3I7XG4gIGlmIChpc0dlbmVyYXRvcikge1xuICAgIHV0aWxzLmNhdGNodXBXaGl0ZVNwYWNlKG5vZGUucmFuZ2VbMF0gKyAxLCBzdGF0ZSk7XG4gIH1cbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHsgLy8gWzxleHByPl0oKSB7IC4uLn1cbiAgICB1dGlscy5jYXRjaHVwKG5vZGUua2V5LnJhbmdlWzFdICsgMSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHJlc2VydmVkV29yZHNIZWxwZXIuaXNSZXNlcnZlZFdvcmQobm9kZS5rZXkubmFtZSkpIHtcbiAgICB1dGlscy5jYXRjaHVwKG5vZGUua2V5LnJhbmdlWzBdLCBzdGF0ZSk7XG4gICAgdXRpbHMuYXBwZW5kKCdcIicsIHN0YXRlKTtcbiAgICB1dGlscy5jYXRjaHVwKG5vZGUua2V5LnJhbmdlWzFdLCBzdGF0ZSk7XG4gICAgdXRpbHMuYXBwZW5kKCdcIicsIHN0YXRlKTtcbiAgfVxuXG4gIHV0aWxzLmNhdGNodXAobm9kZS5rZXkucmFuZ2VbMV0sIHN0YXRlKTtcbiAgdXRpbHMuYXBwZW5kKFxuICAgICc6ZnVuY3Rpb24nICsgKGlzR2VuZXJhdG9yID8gJyonIDogJycpLFxuICAgIHN0YXRlXG4gICk7XG4gIHBhdGgudW5zaGlmdChub2RlKTtcbiAgdHJhdmVyc2Uobm9kZS52YWx1ZSwgcGF0aCwgc3RhdGUpO1xuICBwYXRoLnNoaWZ0KCk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmlzaXRPYmplY3RDb25jaXNlTWV0aG9kLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguUHJvcGVydHkgJiZcbiAgICBub2RlLnZhbHVlLnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb24gJiZcbiAgICBub2RlLm1ldGhvZCA9PT0gdHJ1ZTtcbn07XG5cbmV4cG9ydHMudmlzaXRvckxpc3QgPSBbXG4gIHZpc2l0T2JqZWN0Q29uY2lzZU1ldGhvZFxuXTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlKi9cblxuLyoqXG4gKiBEZXN1Z2FycyBFUzYgT2JqZWN0IExpdGVyYWwgc2hvcnQgbm90YXRpb25zIGludG8gRVMzIGZ1bGwgbm90YXRpb24uXG4gKlxuICogLy8gRWFzaWVyIHJldHVybiB2YWx1ZXMuXG4gKiBmdW5jdGlvbiBmb28oeCwgeSkge1xuICogICByZXR1cm4ge3gsIHl9OyAvLyB7eDogeCwgeTogeX1cbiAqIH07XG4gKlxuICogLy8gRGVzdHJ1Y3R1cmluZy5cbiAqIGZ1bmN0aW9uIGluaXQoe3BvcnQsIGlwLCBjb29yZHM6IHt4LCB5fX0pIHsgLi4uIH1cbiAqXG4gKi9cbnZhciBTeW50YXggPSByZXF1aXJlKCdlc3ByaW1hLWZiJykuU3ludGF4O1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vc3JjL3V0aWxzJyk7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB2aXNpdE9iamVjdExpdGVyYWxTaG9ydE5vdGF0aW9uKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB1dGlscy5jYXRjaHVwKG5vZGUua2V5LnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHV0aWxzLmFwcGVuZCgnOicgKyBub2RlLmtleS5uYW1lLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmlzaXRPYmplY3RMaXRlcmFsU2hvcnROb3RhdGlvbi50ZXN0ID0gZnVuY3Rpb24obm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4LlByb3BlcnR5ICYmXG4gICAgbm9kZS5raW5kID09PSAnaW5pdCcgJiZcbiAgICBub2RlLnNob3J0aGFuZCA9PT0gdHJ1ZSAmJlxuICAgIHBhdGhbMF0udHlwZSAhPT0gU3ludGF4Lk9iamVjdFBhdHRlcm47XG59O1xuXG5leHBvcnRzLnZpc2l0b3JMaXN0ID0gW1xuICB2aXNpdE9iamVjdExpdGVyYWxTaG9ydE5vdGF0aW9uXG5dO1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypqc2xpbnQgbm9kZTp0cnVlKi9cblxuLyoqXG4gKiBEZXN1Z2FycyBFUzYgcmVzdCBwYXJhbWV0ZXJzIGludG8gYW4gRVMzIGFyZ3VtZW50cyBhcnJheS5cbiAqXG4gKiBmdW5jdGlvbiBwcmludGYodGVtcGxhdGUsIC4uLmFyZ3MpIHtcbiAqICAgYXJncy5mb3JFYWNoKC4uLik7XG4gKiB9XG4gKlxuICogV2UgY291bGQgdXNlIGBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbGAsIGJ1dCB0aGF0IHVzYWdlIG9mIGFyZ3VtZW50cyBjYXVzZXNcbiAqIGZ1bmN0aW9ucyB0byBiZSBkZW9wdGltaXplZCBpbiBWOCwgc28gaW5zdGVhZCB3ZSB1c2UgYSBmb3ItbG9vcC5cbiAqXG4gKiBmdW5jdGlvbiBwcmludGYodGVtcGxhdGUpIHtcbiAqICAgZm9yICh2YXIgYXJncyA9IFtdLCAkX18wID0gMSwgJF9fMSA9IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzAgPCAkX18xOyAkX18wKyspXG4gKiAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1skX18wXSk7XG4gKiAgIGFyZ3MuZm9yRWFjaCguLi4pO1xuICogfVxuICpcbiAqL1xudmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzcHJpbWEtZmInKS5TeW50YXg7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9zcmMvdXRpbHMnKTtcblxuXG5cbmZ1bmN0aW9uIF9ub2RlSXNGdW5jdGlvbldpdGhSZXN0UGFyYW0obm9kZSkge1xuICByZXR1cm4gKG5vZGUudHlwZSA9PT0gU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb25cbiAgICAgICAgICB8fCBub2RlLnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgICB8fCBub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbilcbiAgICAgICAgICYmIG5vZGUucmVzdDtcbn1cblxuZnVuY3Rpb24gdmlzaXRGdW5jdGlvblBhcmFtc1dpdGhSZXN0UGFyYW0odHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIGlmIChub2RlLnBhcmFtZXRyaWNUeXBlKSB7XG4gICAgdXRpbHMuY2F0Y2h1cChub2RlLnBhcmFtZXRyaWNUeXBlLnJhbmdlWzBdLCBzdGF0ZSk7XG4gICAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICAgIHRyYXZlcnNlKG5vZGUucGFyYW1ldHJpY1R5cGUsIHBhdGgsIHN0YXRlKTtcbiAgICBwYXRoLnNoaWZ0KCk7XG4gIH1cblxuICAvLyBSZW5kZXIgcGFyYW1zLlxuICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICAgIHRyYXZlcnNlKG5vZGUucGFyYW1zLCBwYXRoLCBzdGF0ZSk7XG4gICAgcGF0aC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIC0zIGlzIGZvciAuLi4gb2YgdGhlIHJlc3QuXG4gICAgdXRpbHMuY2F0Y2h1cChub2RlLnJlc3QucmFuZ2VbMF0gLSAzLCBzdGF0ZSk7XG4gIH1cbiAgdXRpbHMuY2F0Y2h1cFdoaXRlU3BhY2Uobm9kZS5yZXN0LnJhbmdlWzFdLCBzdGF0ZSk7XG5cbiAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICB0cmF2ZXJzZShub2RlLmJvZHksIHBhdGgsIHN0YXRlKTtcbiAgcGF0aC5zaGlmdCgpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmlzaXRGdW5jdGlvblBhcmFtc1dpdGhSZXN0UGFyYW0udGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBfbm9kZUlzRnVuY3Rpb25XaXRoUmVzdFBhcmFtKG5vZGUpO1xufTtcblxuZnVuY3Rpb24gcmVuZGVyUmVzdFBhcmFtU2V0dXAoZnVuY3Rpb25Ob2RlLCBzdGF0ZSkge1xuICB2YXIgaWR4ID0gc3RhdGUubG9jYWxTY29wZS50ZW1wVmFySW5kZXgrKztcbiAgdmFyIGxlbiA9IHN0YXRlLmxvY2FsU2NvcGUudGVtcFZhckluZGV4Kys7XG5cbiAgcmV0dXJuICdmb3IgKHZhciAnICsgZnVuY3Rpb25Ob2RlLnJlc3QubmFtZSArICc9W10sJyArXG4gICAgdXRpbHMuZ2V0VGVtcFZhcihpZHgpICsgJz0nICsgZnVuY3Rpb25Ob2RlLnBhcmFtcy5sZW5ndGggKyAnLCcgK1xuICAgIHV0aWxzLmdldFRlbXBWYXIobGVuKSArICc9YXJndW1lbnRzLmxlbmd0aDsnICtcbiAgICB1dGlscy5nZXRUZW1wVmFyKGlkeCkgKyAnPCcgKyAgdXRpbHMuZ2V0VGVtcFZhcihsZW4pICsgJzsnICtcbiAgICB1dGlscy5nZXRUZW1wVmFyKGlkeCkgKyAnKyspICcgK1xuICAgIGZ1bmN0aW9uTm9kZS5yZXN0Lm5hbWUgKyAnLnB1c2goYXJndW1lbnRzWycgKyB1dGlscy5nZXRUZW1wVmFyKGlkeCkgKyAnXSk7Jztcbn1cblxuZnVuY3Rpb24gdmlzaXRGdW5jdGlvbkJvZHlXaXRoUmVzdFBhcmFtKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB1dGlscy5jYXRjaHVwKG5vZGUucmFuZ2VbMF0gKyAxLCBzdGF0ZSk7XG4gIHZhciBwYXJlbnROb2RlID0gcGF0aFswXTtcbiAgdXRpbHMuYXBwZW5kKHJlbmRlclJlc3RQYXJhbVNldHVwKHBhcmVudE5vZGUsIHN0YXRlKSwgc3RhdGUpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxudmlzaXRGdW5jdGlvbkJvZHlXaXRoUmVzdFBhcmFtLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnRcbiAgICAgICAgICYmIF9ub2RlSXNGdW5jdGlvbldpdGhSZXN0UGFyYW0ocGF0aFswXSk7XG59O1xuXG5leHBvcnRzLnJlbmRlclJlc3RQYXJhbVNldHVwID0gcmVuZGVyUmVzdFBhcmFtU2V0dXA7XG5leHBvcnRzLnZpc2l0b3JMaXN0ID0gW1xuICB2aXNpdEZ1bmN0aW9uUGFyYW1zV2l0aFJlc3RQYXJhbSxcbiAgdmlzaXRGdW5jdGlvbkJvZHlXaXRoUmVzdFBhcmFtXG5dO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qanNsaW50IG5vZGU6dHJ1ZSovXG5cbi8qKlxuICogQHR5cGVjaGVja3NcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGF4ID0gcmVxdWlyZSgnZXNwcmltYS1mYicpLlN5bnRheDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3NyYy91dGlscycpO1xuXG4vKipcbiAqIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLTEyLjEuOVxuICovXG5mdW5jdGlvbiB2aXNpdFRlbXBsYXRlTGl0ZXJhbCh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdmFyIHRlbXBsYXRlRWxlbWVudHMgPSBub2RlLnF1YXNpcztcblxuICB1dGlscy5hcHBlbmQoJygnLCBzdGF0ZSk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCB0ZW1wbGF0ZUVsZW1lbnRzLmxlbmd0aDsgaWkrKykge1xuICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnQgPSB0ZW1wbGF0ZUVsZW1lbnRzW2lpXTtcbiAgICBpZiAodGVtcGxhdGVFbGVtZW50LnZhbHVlLnJhdyAhPT0gJycpIHtcbiAgICAgIHV0aWxzLmFwcGVuZChnZXRDb29rZWRWYWx1ZSh0ZW1wbGF0ZUVsZW1lbnQpLCBzdGF0ZSk7XG4gICAgICBpZiAoIXRlbXBsYXRlRWxlbWVudC50YWlsKSB7XG4gICAgICAgIC8vICsgYmV0d2VlbiBlbGVtZW50IGFuZCBzdWJzdGl0dXRpb25cbiAgICAgICAgdXRpbHMuYXBwZW5kKCcgKyAnLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyBtYWludGFpbiBsaW5lIG51bWJlcnNcbiAgICAgIHV0aWxzLm1vdmUodGVtcGxhdGVFbGVtZW50LnJhbmdlWzBdLCBzdGF0ZSk7XG4gICAgICB1dGlscy5jYXRjaHVwTmV3bGluZXModGVtcGxhdGVFbGVtZW50LnJhbmdlWzFdLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHsgIC8vIHRlbXBsYXRlRWxlbWVudC52YWx1ZS5yYXcgPT09ICcnXG4gICAgICAvLyBDb25jYXRlbmF0IGFkamFjZW50IHN1YnN0aXR1dGlvbnMsIGUuZy4gYCR7eH0ke3l9YC4gRW1wdHkgdGVtcGxhdGVzXG4gICAgICAvLyBhcHBlYXIgYmVmb3JlIHRoZSBmaXJzdCBhbmQgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudCAtIG5vdGhpbmcgdG8gYWRkIGluXG4gICAgICAvLyB0aG9zZSBjYXNlcy5cbiAgICAgIGlmIChpaSA+IDAgJiYgIXRlbXBsYXRlRWxlbWVudC50YWlsKSB7XG4gICAgICAgIC8vICsgYmV0d2VlbiBzdWJzdGl0dXRpb24gYW5kIHN1YnN0aXR1dGlvblxuICAgICAgICB1dGlscy5hcHBlbmQoJyArICcsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlscy5tb3ZlKHRlbXBsYXRlRWxlbWVudC5yYW5nZVsxXSwgc3RhdGUpO1xuICAgIGlmICghdGVtcGxhdGVFbGVtZW50LnRhaWwpIHtcbiAgICAgIHZhciBzdWJzdGl0dXRpb24gPSBub2RlLmV4cHJlc3Npb25zW2lpXTtcbiAgICAgIGlmIChzdWJzdGl0dXRpb24udHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgfHxcbiAgICAgICAgICBzdWJzdGl0dXRpb24udHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gfHxcbiAgICAgICAgICBzdWJzdGl0dXRpb24udHlwZSA9PT0gU3ludGF4LkNhbGxFeHByZXNzaW9uKSB7XG4gICAgICAgIHV0aWxzLmNhdGNodXAoc3Vic3RpdHV0aW9uLnJhbmdlWzFdLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlscy5hcHBlbmQoJygnLCBzdGF0ZSk7XG4gICAgICAgIHRyYXZlcnNlKHN1YnN0aXR1dGlvbiwgcGF0aCwgc3RhdGUpO1xuICAgICAgICB1dGlscy5jYXRjaHVwKHN1YnN0aXR1dGlvbi5yYW5nZVsxXSwgc3RhdGUpO1xuICAgICAgICB1dGlscy5hcHBlbmQoJyknLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyBpZiBuZXh0IHRlbXBsYXRlRWxlbWVudCBpc24ndCBlbXB0eS4uLlxuICAgICAgaWYgKHRlbXBsYXRlRWxlbWVudHNbaWkgKyAxXS52YWx1ZS5jb29rZWQgIT09ICcnKSB7XG4gICAgICAgIHV0aWxzLmFwcGVuZCgnICsgJywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1dGlscy5tb3ZlKG5vZGUucmFuZ2VbMV0sIHN0YXRlKTtcbiAgdXRpbHMuYXBwZW5kKCcpJywgc3RhdGUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbnZpc2l0VGVtcGxhdGVMaXRlcmFsLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguVGVtcGxhdGVMaXRlcmFsO1xufTtcblxuLyoqXG4gKiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy0xMi4yLjZcbiAqL1xuZnVuY3Rpb24gdmlzaXRUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24odHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IG5vZGUucXVhc2k7XG4gIHZhciBudW1RdWFzaXMgPSB0ZW1wbGF0ZS5xdWFzaXMubGVuZ3RoO1xuXG4gIC8vIHByaW50IHRoZSB0YWdcbiAgdXRpbHMubW92ZShub2RlLnRhZy5yYW5nZVswXSwgc3RhdGUpO1xuICB0cmF2ZXJzZShub2RlLnRhZywgcGF0aCwgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwKG5vZGUudGFnLnJhbmdlWzFdLCBzdGF0ZSk7XG5cbiAgLy8gcHJpbnQgYXJyYXkgb2YgdGVtcGxhdGUgZWxlbWVudHNcbiAgdXRpbHMuYXBwZW5kKCcoZnVuY3Rpb24oKSB7IHZhciBzaXRlT2JqID0gWycsIHN0YXRlKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG51bVF1YXNpczsgaWkrKykge1xuICAgIHV0aWxzLmFwcGVuZChnZXRDb29rZWRWYWx1ZSh0ZW1wbGF0ZS5xdWFzaXNbaWldKSwgc3RhdGUpO1xuICAgIGlmIChpaSAhPT0gbnVtUXVhc2lzIC0gMSkge1xuICAgICAgdXRpbHMuYXBwZW5kKCcsICcsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgdXRpbHMuYXBwZW5kKCddOyBzaXRlT2JqLnJhdyA9IFsnLCBzdGF0ZSk7XG4gIGZvciAoaWkgPSAwOyBpaSA8IG51bVF1YXNpczsgaWkrKykge1xuICAgIHV0aWxzLmFwcGVuZChnZXRSYXdWYWx1ZSh0ZW1wbGF0ZS5xdWFzaXNbaWldKSwgc3RhdGUpO1xuICAgIGlmIChpaSAhPT0gbnVtUXVhc2lzIC0gMSkge1xuICAgICAgdXRpbHMuYXBwZW5kKCcsICcsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgdXRpbHMuYXBwZW5kKFxuICAgICddOyBPYmplY3QuZnJlZXplKHNpdGVPYmoucmF3KTsgT2JqZWN0LmZyZWV6ZShzaXRlT2JqKTsgcmV0dXJuIHNpdGVPYmo7IH0oKScsXG4gICAgc3RhdGVcbiAgKTtcblxuICAvLyBwcmludCBzdWJzdGl0dXRpb25zXG4gIGlmIChudW1RdWFzaXMgPiAxKSB7XG4gICAgZm9yIChpaSA9IDA7IGlpIDwgdGVtcGxhdGUuZXhwcmVzc2lvbnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHRlbXBsYXRlLmV4cHJlc3Npb25zW2lpXTtcbiAgICAgIHV0aWxzLmFwcGVuZCgnLCAnLCBzdGF0ZSk7XG5cbiAgICAgIC8vIG1haW50YWluIGxpbmUgbnVtYmVycyBieSBjYWxsaW5nIGNhdGNodXBXaGl0ZVNwYWNlIG92ZXIgdGhlIHdob2xlXG4gICAgICAvLyBwcmV2aW91cyBUZW1wbGF0ZUVsZW1lbnRcbiAgICAgIHV0aWxzLm1vdmUodGVtcGxhdGUucXVhc2lzW2lpXS5yYW5nZVswXSwgc3RhdGUpO1xuICAgICAgdXRpbHMuY2F0Y2h1cE5ld2xpbmVzKHRlbXBsYXRlLnF1YXNpc1tpaV0ucmFuZ2VbMV0sIHN0YXRlKTtcblxuICAgICAgdXRpbHMubW92ZShleHByZXNzaW9uLnJhbmdlWzBdLCBzdGF0ZSk7XG4gICAgICB0cmF2ZXJzZShleHByZXNzaW9uLCBwYXRoLCBzdGF0ZSk7XG4gICAgICB1dGlscy5jYXRjaHVwKGV4cHJlc3Npb24ucmFuZ2VbMV0sIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcmludCBibGFuayBsaW5lcyB0byBwdXNoIHRoZSBjbG9zaW5nICkgZG93biB0byBhY2NvdW50IGZvciB0aGUgZmluYWxcbiAgLy8gVGVtcGxhdGVFbGVtZW50LlxuICB1dGlscy5jYXRjaHVwTmV3bGluZXMobm9kZS5yYW5nZVsxXSwgc3RhdGUpO1xuXG4gIHV0aWxzLmFwcGVuZCgnKScsIHN0YXRlKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZpc2l0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xufTtcblxuZnVuY3Rpb24gZ2V0Q29va2VkVmFsdWUodGVtcGxhdGVFbGVtZW50KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0ZW1wbGF0ZUVsZW1lbnQudmFsdWUuY29va2VkKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmF3VmFsdWUodGVtcGxhdGVFbGVtZW50KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0ZW1wbGF0ZUVsZW1lbnQudmFsdWUucmF3KTtcbn1cblxuZXhwb3J0cy52aXNpdG9yTGlzdCA9IFtcbiAgdmlzaXRUZW1wbGF0ZUxpdGVyYWwsXG4gIHZpc2l0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXG5dO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qanNsaW50IG5vZGU6dHJ1ZSovXG5cbi8qKlxuICogRGVzdWdhcnMgRVM3IHJlc3QgcHJvcGVydGllcyBpbnRvIEVTNSBvYmplY3QgaXRlcmF0aW9uLlxuICovXG5cbnZhciBTeW50YXggPSByZXF1aXJlKCdlc3ByaW1hLWZiJykuU3ludGF4O1xuXG4vLyBUT0RPOiBUaGlzIGlzIGEgcHJldHR5IG1hc3NpdmUgaGVscGVyLCBpdCBzaG91bGQgb25seSBiZSBkZWZpbmVkIG9uY2UsIGluIHRoZVxuLy8gdHJhbnNmb3JtJ3MgcnVudGltZSBlbnZpcm9ubWVudC4gV2UgZG9uJ3QgY3VycmVudGx5IGhhdmUgYSBydW50aW1lIHRob3VnaC5cbnZhciByZXN0RnVuY3Rpb24gPVxuICAnKGZ1bmN0aW9uKHNvdXJjZSwgZXhjbHVzaW9uKSB7JyArXG4gICAgJ3ZhciByZXN0ID0ge307JyArXG4gICAgJ3ZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5OycgK1xuICAgICdpZiAoc291cmNlID09IG51bGwpIHsnICtcbiAgICAgICd0aHJvdyBuZXcgVHlwZUVycm9yKCk7JyArXG4gICAgJ30nICtcbiAgICAnZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeycgK1xuICAgICAgJ2lmIChoYXNPd24uY2FsbChzb3VyY2UsIGtleSkgJiYgIWhhc093bi5jYWxsKGV4Y2x1c2lvbiwga2V5KSkgeycgK1xuICAgICAgICAncmVzdFtrZXldID0gc291cmNlW2tleV07JyArXG4gICAgICAnfScgK1xuICAgICd9JyArXG4gICAgJ3JldHVybiByZXN0OycgK1xuICAnfSknO1xuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpIHtcbiAgdmFyIG5hbWVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgaWYgKHByb3BlcnR5LnR5cGUgPT09IFN5bnRheC5TcHJlYWRQcm9wZXJ0eSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgbmFtZXMucHVzaChwcm9wZXJ0eS5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZXMucHVzaChwcm9wZXJ0eS5rZXkubmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lcztcbn1cblxuZnVuY3Rpb24gZ2V0UmVzdEZ1bmN0aW9uQ2FsbChzb3VyY2UsIGV4Y2x1c2lvbikge1xuICByZXR1cm4gcmVzdEZ1bmN0aW9uICsgJygnICsgc291cmNlICsgJywnICsgZXhjbHVzaW9uICsgJyknO1xufVxuXG5mdW5jdGlvbiBnZXRTaW1wbGVTaGFsbG93Q29weShhY2Nlc3NvckV4cHJlc3Npb24pIHtcbiAgLy8gVGhpcyBjb3VsZCBiZSBmYXN0ZXIgd2l0aCAnT2JqZWN0LmFzc2lnbih7fSwgJyArIGFjY2Vzc29yRXhwcmVzc2lvbiArICcpJ1xuICAvLyBidXQgdG8gdW5pZnkgY29kZSBwYXRocyBhbmQgYXZvaWQgYSBFUzYgZGVwZW5kZW5jeSB3ZSB1c2UgdGhlIHNhbWVcbiAgLy8gaGVscGVyIGFzIGZvciB0aGUgZXhjbHVzaW9uIGNhc2UuXG4gIHJldHVybiBnZXRSZXN0RnVuY3Rpb25DYWxsKGFjY2Vzc29yRXhwcmVzc2lvbiwgJ3t9Jyk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJlc3RFeHByZXNzaW9uKGFjY2Vzc29yRXhwcmVzc2lvbiwgZXhjbHVkZWRQcm9wZXJ0aWVzKSB7XG4gIHZhciBleGNsdWRlZE5hbWVzID0gZ2V0UHJvcGVydHlOYW1lcyhleGNsdWRlZFByb3BlcnRpZXMpO1xuICBpZiAoIWV4Y2x1ZGVkTmFtZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdldFNpbXBsZVNoYWxsb3dDb3B5KGFjY2Vzc29yRXhwcmVzc2lvbik7XG4gIH1cbiAgcmV0dXJuIGdldFJlc3RGdW5jdGlvbkNhbGwoXG4gICAgYWNjZXNzb3JFeHByZXNzaW9uLFxuICAgICd7JyArIGV4Y2x1ZGVkTmFtZXMuam9pbignOjEsJykgKyAnOjF9J1xuICApO1xufVxuXG5leHBvcnRzLnJlbmRlclJlc3RFeHByZXNzaW9uID0gcmVuZGVyUmVzdEV4cHJlc3Npb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDA0LXByZXNlbnQgRmFjZWJvb2suIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSovXG5cbi8qKlxuICogSW1wbGVtZW50cyBFUzcgb2JqZWN0IHNwcmVhZCBwcm9wZXJ0eS5cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3NlYm1hcmtiYWdlL2FhODQ5Yzc5NzNjYjQ0NTJjNTQ3XG4gKlxuICogeyAuLi5hLCB4OiAxIH1cbiAqXG4gKiBPYmplY3QuYXNzaWduKHt9LCBhLCB7eDogMSB9KVxuICpcbiAqL1xuXG52YXIgU3ludGF4ID0gcmVxdWlyZSgnZXNwcmltYS1mYicpLlN5bnRheDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3NyYy91dGlscycpO1xuXG5mdW5jdGlvbiB2aXNpdE9iamVjdExpdGVyYWxTcHJlYWQodHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHV0aWxzLmNhdGNodXAobm9kZS5yYW5nZVswXSwgc3RhdGUpO1xuXG4gIHV0aWxzLmFwcGVuZCgnT2JqZWN0LmFzc2lnbih7Jywgc3RhdGUpO1xuXG4gIC8vIFNraXAgdGhlIG9yaWdpbmFsIHtcbiAgdXRpbHMubW92ZShub2RlLnJhbmdlWzBdICsgMSwgc3RhdGUpO1xuXG4gIHZhciBwcmV2aW91c1dhc1NwcmVhZCA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuICAgIGlmIChwcm9wZXJ0eS50eXBlID09PSBTeW50YXguU3ByZWFkUHJvcGVydHkpIHtcblxuICAgICAgLy8gQ2xvc2UgdGhlIHByZXZpb3VzIG9iamVjdCBvciBpbml0aWFsIG9iamVjdFxuICAgICAgaWYgKCFwcmV2aW91c1dhc1NwcmVhZCkge1xuICAgICAgICB1dGlscy5hcHBlbmQoJ30nLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHRoZXJlIHdpbGwgYmUgYSBjb21tYSB3aGVuIHdlIGNhdGNoIHVwLCBidXQgbm90IGJlZm9yZVxuICAgICAgICAvLyB0aGUgZmlyc3QgcHJvcGVydHkuXG4gICAgICAgIHV0aWxzLmFwcGVuZCgnLCcsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuY2F0Y2h1cChwcm9wZXJ0eS5yYW5nZVswXSwgc3RhdGUpO1xuXG4gICAgICAvLyBza2lwIC4uLlxuICAgICAgdXRpbHMubW92ZShwcm9wZXJ0eS5yYW5nZVswXSArIDMsIHN0YXRlKTtcblxuICAgICAgdHJhdmVyc2UocHJvcGVydHkuYXJndW1lbnQsIHBhdGgsIHN0YXRlKTtcblxuICAgICAgdXRpbHMuY2F0Y2h1cChwcm9wZXJ0eS5yYW5nZVsxXSwgc3RhdGUpO1xuXG4gICAgICBwcmV2aW91c1dhc1NwcmVhZCA9IHRydWU7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB1dGlscy5jYXRjaHVwKHByb3BlcnR5LnJhbmdlWzBdLCBzdGF0ZSk7XG5cbiAgICAgIGlmIChwcmV2aW91c1dhc1NwcmVhZCkge1xuICAgICAgICB1dGlscy5hcHBlbmQoJ3snLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHRyYXZlcnNlKHByb3BlcnR5LCBwYXRoLCBzdGF0ZSk7XG5cbiAgICAgIHV0aWxzLmNhdGNodXAocHJvcGVydHkucmFuZ2VbMV0sIHN0YXRlKTtcblxuICAgICAgcHJldmlvdXNXYXNTcHJlYWQgPSBmYWxzZTtcblxuICAgIH1cbiAgfVxuXG4gIC8vIFN0cmlwIGFueSBub24td2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBsYXN0IGl0ZW0gYW5kIHRoZSBlbmQuXG4gIC8vIFdlIG9ubHkgY2F0Y2ggdXAgb24gd2hpdGVzcGFjZSBzbyB0aGF0IHdlIGlnbm9yZSBhbnkgdHJhaWxpbmcgY29tbWFzIHdoaWNoXG4gIC8vIGFyZSBzdHJpcHBlZCBvdXQgZm9yIElFOCBzdXBwb3J0LiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gc3RyaXBzIG91dCBhbnlcbiAgLy8gdHJhaWxpbmcgY29tbWVudHMuXG4gIHV0aWxzLmNhdGNodXBXaGl0ZVNwYWNlKG5vZGUucmFuZ2VbMV0gLSAxLCBzdGF0ZSk7XG5cbiAgLy8gU2tpcCB0aGUgdHJhaWxpbmcgfVxuICB1dGlscy5tb3ZlKG5vZGUucmFuZ2VbMV0sIHN0YXRlKTtcblxuICBpZiAoIXByZXZpb3VzV2FzU3ByZWFkKSB7XG4gICAgdXRpbHMuYXBwZW5kKCd9Jywgc3RhdGUpO1xuICB9XG5cbiAgdXRpbHMuYXBwZW5kKCcpJywgc3RhdGUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbnZpc2l0T2JqZWN0TGl0ZXJhbFNwcmVhZC50ZXN0ID0gZnVuY3Rpb24obm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSAhPT0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGlnaHQgbG9vcCBvcHRpbWl6YXRpb25cbiAgdmFyIGhhc0F0TGVhc3RPbmVTcHJlYWRQcm9wZXJ0eSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wZXJ0eSA9IG5vZGUucHJvcGVydGllc1tpXTtcbiAgICBpZiAocHJvcGVydHkudHlwZSA9PT0gU3ludGF4LlNwcmVhZFByb3BlcnR5KSB7XG4gICAgICBoYXNBdExlYXN0T25lU3ByZWFkUHJvcGVydHkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHkua2luZCAhPT0gJ2luaXQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNBdExlYXN0T25lU3ByZWFkUHJvcGVydHk7XG59O1xuXG5leHBvcnRzLnZpc2l0b3JMaXN0ID0gW1xuICB2aXNpdE9iamVjdExpdGVyYWxTcHJlYWRcbl07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIEtFWVdPUkRTID0gW1xuICAnYnJlYWsnLCAnZG8nLCAnaW4nLCAndHlwZW9mJywgJ2Nhc2UnLCAnZWxzZScsICdpbnN0YW5jZW9mJywgJ3ZhcicsICdjYXRjaCcsXG4gICdleHBvcnQnLCAnbmV3JywgJ3ZvaWQnLCAnY2xhc3MnLCAnZXh0ZW5kcycsICdyZXR1cm4nLCAnd2hpbGUnLCAnY29uc3QnLFxuICAnZmluYWxseScsICdzdXBlcicsICd3aXRoJywgJ2NvbnRpbnVlJywgJ2ZvcicsICdzd2l0Y2gnLCAneWllbGQnLCAnZGVidWdnZXInLFxuICAnZnVuY3Rpb24nLCAndGhpcycsICdkZWZhdWx0JywgJ2lmJywgJ3Rocm93JywgJ2RlbGV0ZScsICdpbXBvcnQnLCAndHJ5J1xuXTtcblxudmFyIEZVVFVSRV9SRVNFUlZFRF9XT1JEUyA9IFtcbiAgJ2VudW0nLCAnYXdhaXQnLCAnaW1wbGVtZW50cycsICdwYWNrYWdlJywgJ3Byb3RlY3RlZCcsICdzdGF0aWMnLCAnaW50ZXJmYWNlJyxcbiAgJ3ByaXZhdGUnLCAncHVibGljJ1xuXTtcblxudmFyIExJVEVSQUxTID0gW1xuICAnbnVsbCcsXG4gICd0cnVlJyxcbiAgJ2ZhbHNlJ1xuXTtcblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXJlc2VydmVkLXdvcmRzXG52YXIgUkVTRVJWRURfV09SRFMgPSBbXS5jb25jYXQoXG4gIEtFWVdPUkRTLFxuICBGVVRVUkVfUkVTRVJWRURfV09SRFMsXG4gIExJVEVSQUxTXG4pO1xuXG52YXIgcmVzZXJ2ZWRXb3Jkc01hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5SRVNFUlZFRF9XT1JEUy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXNlcnZlZFdvcmRzTWFwW2tdID0gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIFRoaXMgbGlzdCBzaG91bGQgbm90IGdyb3cgYXMgbmV3IHJlc2VydmVkIHdvcmRzIGFyZSBpbnRyb2R1ZWQuIFRoaXMgbGlzdCBpc1xuICogb2Ygd29yZHMgdGhhdCBuZWVkIHRvIGJlIHF1b3RlZCBiZWNhdXNlIEVTMy1pc2ggYnJvd3NlcnMgZG8gbm90IGFsbG93IHRoZWlyXG4gKiB1c2UgYXMgaWRlbnRpZmllciBuYW1lcy5cbiAqL1xudmFyIEVTM19GVVRVUkVfUkVTRVJWRURfV09SRFMgPSBbXG4gICdlbnVtJywgJ2ltcGxlbWVudHMnLCAncGFja2FnZScsICdwcm90ZWN0ZWQnLCAnc3RhdGljJywgJ2ludGVyZmFjZScsXG4gICdwcml2YXRlJywgJ3B1YmxpYydcbl07XG5cbnZhciBFUzNfUkVTRVJWRURfV09SRFMgPSBbXS5jb25jYXQoXG4gIEtFWVdPUkRTLFxuICBFUzNfRlVUVVJFX1JFU0VSVkVEX1dPUkRTLFxuICBMSVRFUkFMU1xuKTtcblxudmFyIGVzM1Jlc2VydmVkV29yZHNNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuRVMzX1JFU0VSVkVEX1dPUkRTLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGVzM1Jlc2VydmVkV29yZHNNYXBba10gPSB0cnVlO1xufSk7XG5cbmV4cG9ydHMuaXNSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbih3b3JkKSB7XG4gIHJldHVybiAhIXJlc2VydmVkV29yZHNNYXBbd29yZF07XG59O1xuXG5leHBvcnRzLmlzRVMzUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24od29yZCkge1xuICByZXR1cm4gISFlczNSZXNlcnZlZFdvcmRzTWFwW3dvcmRdO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSovXG5cbnZhciBTeW50YXggPSByZXF1aXJlKCdlc3ByaW1hLWZiJykuU3ludGF4O1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vc3JjL3V0aWxzJyk7XG52YXIgcmVzZXJ2ZXJkV29yZHNIZWxwZXIgPSByZXF1aXJlKCcuL3Jlc2VydmVkLXdvcmRzLWhlbHBlcicpO1xuXG4vKipcbiAqIENvZGUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zcGljeWovZXMzaWZ5XG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCZW4gQWxwZXJ0XG4gKi9cblxuZnVuY3Rpb24gdmlzaXRQcm9wZXJ0eSh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMuY2F0Y2h1cChub2RlLmtleS5yYW5nZVswXSwgc3RhdGUpO1xuICB1dGlscy5hcHBlbmQoJ1wiJywgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwKG5vZGUua2V5LnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHV0aWxzLmFwcGVuZCgnXCInLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXAobm9kZS52YWx1ZS5yYW5nZVswXSwgc3RhdGUpO1xuICB0cmF2ZXJzZShub2RlLnZhbHVlLCBwYXRoLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmlzaXRQcm9wZXJ0eS50ZXN0ID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguUHJvcGVydHkgJiZcbiAgICBub2RlLmtleS50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJlxuICAgICFub2RlLm1ldGhvZCAmJlxuICAgICFub2RlLnNob3J0aGFuZCAmJlxuICAgICFub2RlLmNvbXB1dGVkICYmXG4gICAgcmVzZXJ2ZXJkV29yZHNIZWxwZXIuaXNFUzNSZXNlcnZlZFdvcmQobm9kZS5rZXkubmFtZSk7XG59O1xuXG5mdW5jdGlvbiB2aXNpdE1lbWJlckV4cHJlc3Npb24odHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHRyYXZlcnNlKG5vZGUub2JqZWN0LCBwYXRoLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXAobm9kZS5wcm9wZXJ0eS5yYW5nZVswXSAtIDEsIHN0YXRlKTtcbiAgdXRpbHMuYXBwZW5kKCdbJywgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwV2hpdGVTcGFjZShub2RlLnByb3BlcnR5LnJhbmdlWzBdLCBzdGF0ZSk7XG4gIHV0aWxzLmFwcGVuZCgnXCInLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXAobm9kZS5wcm9wZXJ0eS5yYW5nZVsxXSwgc3RhdGUpO1xuICB1dGlscy5hcHBlbmQoJ1wiXScsIHN0YXRlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52aXNpdE1lbWJlckV4cHJlc3Npb24udGVzdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiZcbiAgICBub2RlLnByb3BlcnR5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmXG4gICAgcmVzZXJ2ZXJkV29yZHNIZWxwZXIuaXNFUzNSZXNlcnZlZFdvcmQobm9kZS5wcm9wZXJ0eS5uYW1lKTtcbn07XG5cbmV4cG9ydHMudmlzaXRvckxpc3QgPSBbXG4gIHZpc2l0UHJvcGVydHksXG4gIHZpc2l0TWVtYmVyRXhwcmVzc2lvblxuXTtcbiIsInZhciBlc3ByaW1hID0gcmVxdWlyZSgnZXNwcmltYS1mYicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vc3JjL3V0aWxzJyk7XG5cbnZhciBTeW50YXggPSBlc3ByaW1hLlN5bnRheDtcblxuZnVuY3Rpb24gX2lzRnVuY3Rpb25Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb25cbiAgICAgICAgIHx8IG5vZGUudHlwZSA9PT0gU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICAgfHwgbm9kZS50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG59XG5cbmZ1bmN0aW9uIHZpc2l0Q2xhc3NQcm9wZXJ0eSh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMuY2F0Y2h1cChub2RlLnJhbmdlWzBdLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXBXaGl0ZU91dChub2RlLnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbnZpc2l0Q2xhc3NQcm9wZXJ0eS50ZXN0ID0gZnVuY3Rpb24obm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4LkNsYXNzUHJvcGVydHk7XG59O1xuXG5mdW5jdGlvbiB2aXNpdFR5cGVBbGlhcyh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMuY2F0Y2h1cFdoaXRlT3V0KG5vZGUucmFuZ2VbMV0sIHN0YXRlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxudmlzaXRUeXBlQWxpYXMudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFN5bnRheC5UeXBlQWxpYXM7XG59O1xuXG5mdW5jdGlvbiB2aXNpdFR5cGVDYXN0KHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICBwYXRoLnVuc2hpZnQobm9kZSk7XG4gIHRyYXZlcnNlKG5vZGUuZXhwcmVzc2lvbiwgcGF0aCwgc3RhdGUpO1xuICBwYXRoLnNoaWZ0KCk7XG5cbiAgdXRpbHMuY2F0Y2h1cChub2RlLnR5cGVBbm5vdGF0aW9uLnJhbmdlWzBdLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXBXaGl0ZU91dChub2RlLnR5cGVBbm5vdGF0aW9uLnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbnZpc2l0VHlwZUNhc3QudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFN5bnRheC5UeXBlQ2FzdEV4cHJlc3Npb247XG59O1xuXG5mdW5jdGlvbiB2aXNpdEludGVyZmFjZURlY2xhcmF0aW9uKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB1dGlscy5jYXRjaHVwV2hpdGVPdXQobm9kZS5yYW5nZVsxXSwgc3RhdGUpO1xuICByZXR1cm4gZmFsc2U7XG59XG52aXNpdEludGVyZmFjZURlY2xhcmF0aW9uLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguSW50ZXJmYWNlRGVjbGFyYXRpb247XG59O1xuXG5mdW5jdGlvbiB2aXNpdERlY2xhcmUodHJhdmVyc2UsIG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHV0aWxzLmNhdGNodXBXaGl0ZU91dChub2RlLnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbnZpc2l0RGVjbGFyZS50ZXN0ID0gZnVuY3Rpb24obm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFN5bnRheC5EZWNsYXJlVmFyaWFibGU6XG4gICAgY2FzZSBTeW50YXguRGVjbGFyZUZ1bmN0aW9uOlxuICAgIGNhc2UgU3ludGF4LkRlY2xhcmVDbGFzczpcbiAgICBjYXNlIFN5bnRheC5EZWNsYXJlTW9kdWxlOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gdmlzaXRGdW5jdGlvblBhcmFtZXRyaWNBbm5vdGF0aW9uKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB1dGlscy5jYXRjaHVwKG5vZGUucmFuZ2VbMF0sIHN0YXRlKTtcbiAgdXRpbHMuY2F0Y2h1cFdoaXRlT3V0KG5vZGUucmFuZ2VbMV0sIHN0YXRlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxudmlzaXRGdW5jdGlvblBhcmFtZXRyaWNBbm5vdGF0aW9uLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXG4gICAgICAgICAmJiBwYXRoWzBdXG4gICAgICAgICAmJiBfaXNGdW5jdGlvbk5vZGUocGF0aFswXSlcbiAgICAgICAgICYmIG5vZGUgPT09IHBhdGhbMF0udHlwZVBhcmFtZXRlcnM7XG59O1xuXG5mdW5jdGlvbiB2aXNpdEZ1bmN0aW9uUmV0dXJuQW5ub3RhdGlvbih0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMuY2F0Y2h1cChub2RlLnJhbmdlWzBdLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXBXaGl0ZU91dChub2RlLnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbnZpc2l0RnVuY3Rpb25SZXR1cm5Bbm5vdGF0aW9uLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gcGF0aFswXSAmJiBfaXNGdW5jdGlvbk5vZGUocGF0aFswXSkgJiYgbm9kZSA9PT0gcGF0aFswXS5yZXR1cm5UeXBlO1xufTtcblxuZnVuY3Rpb24gdmlzaXRPcHRpb25hbEZ1bmN0aW9uUGFyYW1ldGVyQW5ub3RhdGlvbih0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMuY2F0Y2h1cChub2RlLnJhbmdlWzBdICsgbm9kZS5uYW1lLmxlbmd0aCwgc3RhdGUpO1xuICB1dGlscy5jYXRjaHVwV2hpdGVPdXQobm9kZS5yYW5nZVsxXSwgc3RhdGUpO1xuICByZXR1cm4gZmFsc2U7XG59XG52aXNpdE9wdGlvbmFsRnVuY3Rpb25QYXJhbWV0ZXJBbm5vdGF0aW9uLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllclxuICAgICAgICAgJiYgbm9kZS5vcHRpb25hbFxuICAgICAgICAgJiYgcGF0aFswXVxuICAgICAgICAgJiYgX2lzRnVuY3Rpb25Ob2RlKHBhdGhbMF0pO1xufTtcblxuZnVuY3Rpb24gdmlzaXRUeXBlQW5ub3RhdGVkSWRlbnRpZmllcih0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMuY2F0Y2h1cChub2RlLnR5cGVBbm5vdGF0aW9uLnJhbmdlWzBdLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXBXaGl0ZU91dChub2RlLnR5cGVBbm5vdGF0aW9uLnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbnZpc2l0VHlwZUFubm90YXRlZElkZW50aWZpZXIudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG5vZGUudHlwZUFubm90YXRpb247XG59O1xuXG5mdW5jdGlvbiB2aXNpdFR5cGVBbm5vdGF0ZWRPYmplY3RPckFycmF5UGF0dGVybih0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgdXRpbHMuY2F0Y2h1cChub2RlLnR5cGVBbm5vdGF0aW9uLnJhbmdlWzBdLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXBXaGl0ZU91dChub2RlLnR5cGVBbm5vdGF0aW9uLnJhbmdlWzFdLCBzdGF0ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbnZpc2l0VHlwZUFubm90YXRlZE9iamVjdE9yQXJyYXlQYXR0ZXJuLnRlc3QgPSBmdW5jdGlvbihub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB2YXIgcmlnaHRUeXBlID0gbm9kZS50eXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVyblxuICAgICAgICAgICAgICAgIHx8IG5vZGUudHlwZSA9PT0gU3ludGF4LkFycmF5UGF0dGVybjtcbiAgcmV0dXJuIHJpZ2h0VHlwZSAmJiBub2RlLnR5cGVBbm5vdGF0aW9uO1xufTtcblxuLyoqXG4gKiBNZXRob2RzIGNhdXNlIHRyb3VibGUsIHNpbmNlIGVzcHJpbWEgcGFyc2VzIHRoZW0gYXMgYSBrZXkvdmFsdWUgcGFpciwgd2hlcmVcbiAqIHRoZSBsb2NhdGlvbiBvZiB0aGUgdmFsdWUgc3RhcnRzIGF0IHRoZSBtZXRob2QgYm9keS4gRm9yIGV4YW1wbGVcbiAqIHsgYmFyKHg6bnVtYmVyLC4uLnk6QXJyYXk8bnVtYmVyPik6bnVtYmVyIHt9IH1cbiAqIGlzIHBhcnNlZCBhc1xuICogeyBiYXI6IGZ1bmN0aW9uKHg6IG51bWJlciwgLi4ueTpBcnJheTxudW1iZXI+KTogbnVtYmVyIHt9IH1cbiAqIGV4Y2VwdCB0aGF0IHRoZSBsb2NhdGlvbiBvZiB0aGUgRnVuY3Rpb25FeHByZXNzaW9uIHZhbHVlIGlzIDQwLXNvbWV0aGluZyxcbiAqIHdoaWNoIGlzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZnVuY3Rpb24gYm9keS4gVGhpcyBtZWFucyB0aGF0IGJ5IHRoZSB0aW1lIHdlXG4gKiB2aXNpdCB0aGUgcGFyYW1zLCByZXN0IHBhcmFtLCBhbmQgcmV0dXJuIHR5cGUgb3JnYW5pY2FsbHksIHdlJ3ZlIGFscmVhZHlcbiAqIGNhdGNodXAoKSdkIHBhc3NlZCB0aGVtLlxuICovXG5mdW5jdGlvbiB2aXNpdE1ldGhvZCh0cmF2ZXJzZSwgbm9kZSwgcGF0aCwgc3RhdGUpIHtcbiAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICB0cmF2ZXJzZShub2RlLmtleSwgcGF0aCwgc3RhdGUpO1xuXG4gIHBhdGgudW5zaGlmdChub2RlLnZhbHVlKTtcbiAgdHJhdmVyc2Uobm9kZS52YWx1ZS5wYXJhbXMsIHBhdGgsIHN0YXRlKTtcbiAgbm9kZS52YWx1ZS5yZXN0ICYmIHRyYXZlcnNlKG5vZGUudmFsdWUucmVzdCwgcGF0aCwgc3RhdGUpO1xuICBub2RlLnZhbHVlLnJldHVyblR5cGUgJiYgdHJhdmVyc2Uobm9kZS52YWx1ZS5yZXR1cm5UeXBlLCBwYXRoLCBzdGF0ZSk7XG4gIHRyYXZlcnNlKG5vZGUudmFsdWUuYm9keSwgcGF0aCwgc3RhdGUpO1xuXG4gIHBhdGguc2hpZnQoKTtcblxuICBwYXRoLnNoaWZ0KCk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmlzaXRNZXRob2QudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiAobm9kZS50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgKG5vZGUubWV0aG9kIHx8IG5vZGUua2luZCA9PT0gXCJzZXRcIiB8fCBub2RlLmtpbmQgPT09IFwiZ2V0XCIpKVxuICAgICAgfHwgKG5vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIpO1xufTtcblxuZnVuY3Rpb24gdmlzaXRJbXBvcnRUeXBlKHRyYXZlcnNlLCBub2RlLCBwYXRoLCBzdGF0ZSkge1xuICB1dGlscy5jYXRjaHVwV2hpdGVPdXQobm9kZS5yYW5nZVsxXSwgc3RhdGUpO1xuICByZXR1cm4gZmFsc2U7XG59XG52aXNpdEltcG9ydFR5cGUudGVzdCA9IGZ1bmN0aW9uKG5vZGUsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09ICdJbXBvcnREZWNsYXJhdGlvbidcbiAgICAgICAgICYmIG5vZGUuaXNUeXBlO1xufTtcblxuZXhwb3J0cy52aXNpdG9yTGlzdCA9IFtcbiAgdmlzaXRDbGFzc1Byb3BlcnR5LFxuICB2aXNpdERlY2xhcmUsXG4gIHZpc2l0SW1wb3J0VHlwZSxcbiAgdmlzaXRJbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgdmlzaXRGdW5jdGlvblBhcmFtZXRyaWNBbm5vdGF0aW9uLFxuICB2aXNpdEZ1bmN0aW9uUmV0dXJuQW5ub3RhdGlvbixcbiAgdmlzaXRNZXRob2QsXG4gIHZpc2l0T3B0aW9uYWxGdW5jdGlvblBhcmFtZXRlckFubm90YXRpb24sXG4gIHZpc2l0VHlwZUFsaWFzLFxuICB2aXNpdFR5cGVDYXN0LFxuICB2aXNpdFR5cGVBbm5vdGF0ZWRJZGVudGlmaWVyLFxuICB2aXNpdFR5cGVBbm5vdGF0ZWRPYmplY3RPckFycmF5UGF0dGVyblxuXTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XHJcbnZhciBTeW50YXggPSByZXF1aXJlKCdqc3RyYW5zZm9ybScpLlN5bnRheDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ2pzdHJhbnNmb3JtL3NyYy91dGlscycpO1xuXG5mdW5jdGlvbiBjb21tYUFmdGVyTGFzdFBhcmVuKHZhbHVlKSB7XHJcbiAgdmFyIHN0YXRlID0gJ25vcm1hbCc7XHJcbiAgdmFyIGNvbW1hUG9zID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoc3RhdGUgPT09ICdub3JtYWwnKSB7XHJcbiAgICAgIGlmICh2YWx1ZS5zdWJzdHIoaSwgMikgPT09ICcvLycpIHtcclxuICAgICAgICBzdGF0ZSA9ICdzaW5nbGVsaW5lJztcclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuc3Vic3RyKGksIDIpID09PSAnLyonKSB7XHJcbiAgICAgICAgc3RhdGUgPSAnbXVsdGlsaW5lJztcclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuY2hhckF0KGkpLnRyaW0oKSAhPT0gJycpIHtcclxuICAgICAgICBjb21tYVBvcyA9IGkgKyAxO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnc2luZ2xlbGluZScgJiYgdmFsdWUuY2hhckF0KGkpID09PSAnXFxuJykge1xyXG4gICAgICBzdGF0ZSA9ICdub3JtYWwnO1xyXG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ211bHRpbGluZScgJiZcclxuICAgICAgICB2YWx1ZS5jaGFyQXQoaSkgPT09ICcqJyAmJlxyXG4gICAgICAgIGkgKyAxIDwgdmFsdWUubGVuZ3RoICYmXHJcbiAgICAgICAgdmFsdWUuY2hhckF0KGkgKyAxKSA9PT0gJy8nKSB7XHJcbiAgICAgIGkgKz0gMTtcclxuICAgICAgc3RhdGUgPSAnbm9ybWFsJztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygwLCBjb21tYVBvcykgKyAnLCAnICsgdHJpbUxlZnQodmFsdWUuc3Vic3RyaW5nKGNvbW1hUG9zKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlckpTWExpdGVyYWwob2JqZWN0LCBpc0xhc3QsIHN0YXRlLCBzdGFydCwgZW5kKSB7XHJcbiAgdmFyIGxpbmVzID0gb2JqZWN0LnZhbHVlLnNwbGl0KC9cXHJcXG58XFxufFxcci8pO1xuXG4gIGlmIChzdGFydCkge1xuICAgIHV0aWxzLmFwcGVuZChzdGFydCwgc3RhdGUpO1xuICB9XG5cbiAgdmFyIGxhc3ROb25FbXB0eUxpbmUgPSAwO1xuXG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSwgaW5kZXgpIHtcclxuICAgIGlmIChsaW5lLm1hdGNoKC9bXiBcXHRdLykpIHtcbiAgICAgIGxhc3ROb25FbXB0eUxpbmUgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSwgaW5kZXgpIHtcclxuICAgIHZhciBpc0ZpcnN0TGluZSA9IGluZGV4ID09PSAwO1xuICAgIHZhciBpc0xhc3RMaW5lID0gaW5kZXggPT09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGlzTGFzdE5vbkVtcHR5TGluZSA9IGluZGV4ID09PSBsYXN0Tm9uRW1wdHlMaW5lO1xuXG4gICAgLy8gcmVwbGFjZSByZW5kZXJlZCB3aGl0ZXNwYWNlIHRhYnMgd2l0aCBzcGFjZXNcbiAgICB2YXIgdHJpbW1lZExpbmUgPSBsaW5lLnJlcGxhY2UoL1xcdC9nLCAnICcpO1xuXG4gICAgLy8gdHJpbSB3aGl0ZXNwYWNlIHRvdWNoaW5nIGEgbmV3bGluZVxuICAgIGlmICghaXNGaXJzdExpbmUpIHtcbiAgICAgIHRyaW1tZWRMaW5lID0gdHJpbW1lZExpbmUucmVwbGFjZSgvXlsgXSsvLCAnJyk7XG4gICAgfVxuICAgIGlmICghaXNMYXN0TGluZSkge1xuICAgICAgdHJpbW1lZExpbmUgPSB0cmltbWVkTGluZS5yZXBsYWNlKC9bIF0rJC8sICcnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmlyc3RMaW5lKSB7XG4gICAgdXRpbHMuYXBwZW5kKGxpbmUubWF0Y2goL15bIFxcdF0qLylbMF0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAodHJpbW1lZExpbmUgfHwgaXNMYXN0Tm9uRW1wdHlMaW5lKSB7XG4gICAgICB1dGlscy5hcHBlbmQoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHRyaW1tZWRMaW5lKSArXG4gICAgICAgICghaXNMYXN0Tm9uRW1wdHlMaW5lID8gJyArIFxcJyBcXCcgKycgOiAnJyksXHJcbiAgICAgICAgc3RhdGUpO1xuXG4gICAgICBpZiAoaXNMYXN0Tm9uRW1wdHlMaW5lKSB7XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICB1dGlscy5hcHBlbmQoZW5kLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0xhc3QpIHtcbiAgICAgICAgICB1dGlscy5hcHBlbmQoJywgJywgc3RhdGUpO1xyXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb25seSByZXN0b3JlIHRhaWwgd2hpdGVzcGFjZSBpZiBsaW5lIGhhZCBsaXRlcmFsc1xuICAgICAgaWYgKHRyaW1tZWRMaW5lICYmICFpc0xhc3RMaW5lKSB7XG4gICAgICAgIHV0aWxzLmFwcGVuZChsaW5lLm1hdGNoKC9bIFxcdF0qJC8pWzBdLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0xhc3RMaW5lKSB7XG4gICAgICB1dGlscy5hcHBlbmQoJ1xcbicsIHN0YXRlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLm1vdmUob2JqZWN0LnJhbmdlWzFdLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckpTWEV4cHJlc3Npb25Db250YWluZXIodHJhdmVyc2UsIG9iamVjdCwgaXNMYXN0LCBwYXRoLCBzdGF0ZSkge1xyXG4gIC8vIFBsdXMgMSB0byBza2lwIGB7YC5cbiAgdXRpbHMubW92ZShvYmplY3QucmFuZ2VbMF0gKyAxLCBzdGF0ZSk7XG4gIHV0aWxzLmNhdGNodXAob2JqZWN0LmV4cHJlc3Npb24ucmFuZ2VbMF0sIHN0YXRlKTtcclxuICB0cmF2ZXJzZShvYmplY3QuZXhwcmVzc2lvbiwgcGF0aCwgc3RhdGUpO1xuXG4gIGlmICghaXNMYXN0ICYmIG9iamVjdC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5KU1hFbXB0eUV4cHJlc3Npb24pIHtcclxuICAgIC8vIElmIHdlIG5lZWQgdG8gYXBwZW5kIGEgY29tbWEsIG1ha2Ugc3VyZSB0byBkbyBzbyBhZnRlciB0aGUgZXhwcmVzc2lvbi5cbiAgICB1dGlscy5jYXRjaHVwKG9iamVjdC5leHByZXNzaW9uLnJhbmdlWzFdLCBzdGF0ZSwgdHJpbUxlZnQpO1xuICAgIHV0aWxzLmNhdGNodXAob2JqZWN0LnJhbmdlWzFdIC0gMSwgc3RhdGUsIGNvbW1hQWZ0ZXJMYXN0UGFyZW4pO1xyXG4gIH0gZWxzZSB7XHJcbiAgLy8gTWludXMgMSB0byBza2lwIGB9YC5cbiAgdXRpbHMuY2F0Y2h1cChvYmplY3QucmFuZ2VbMV0gLSAxLCBzdGF0ZSwgdHJpbUxlZnQpO1xuICB9XHJcbiAgdXRpbHMubW92ZShvYmplY3QucmFuZ2VbMV0sIHN0YXRlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBxdW90ZUF0dHJOYW1lKGF0dHIpIHtcbiAgLy8gUXVvdGUgaW52YWxpZCBKUyBpZGVudGlmaWVycy5cbiAgaWYgKCEvXlthLXpfJF1bYS16XFxkXyRdKiQvaS50ZXN0KGF0dHIpKSB7XG4gICAgcmV0dXJuICdcIicgKyBhdHRyICsgJ1wiJztcbiAgfVxuICByZXR1cm4gYXR0cjtcbn1cblxuZnVuY3Rpb24gdHJpbUxlZnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL15bIF0rLywgJycpO1xufVxuXG5leHBvcnRzLnJlbmRlckpTWEV4cHJlc3Npb25Db250YWluZXIgPSByZW5kZXJKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5leHBvcnRzLnJlbmRlckpTWExpdGVyYWwgPSByZW5kZXJKU1hMaXRlcmFsO1xyXG5leHBvcnRzLnF1b3RlQXR0ck5hbWUgPSBxdW90ZUF0dHJOYW1lO1xuZXhwb3J0cy50cmltTGVmdCA9IHRyaW1MZWZ0O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLypnbG9iYWwgZXhwb3J0czp0cnVlKi9cblxudmFyIFN5bnRheCA9IHJlcXVpcmUoJ2pzdHJhbnNmb3JtJykuU3ludGF4O1xudmFyIHV0aWxzID0gcmVxdWlyZSgnanN0cmFuc2Zvcm0vc3JjL3V0aWxzJyk7XG5cbnZhciByZW5kZXJKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gcmVxdWlyZSgnLi9qc3gnKS5yZW5kZXJKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xudmFyIHJlbmRlckpTWExpdGVyYWwgPSByZXF1aXJlKCcuL2pzeCcpLnJlbmRlckpTWExpdGVyYWw7XG52YXIgcXVvdGVBdHRyTmFtZSA9IHJlcXVpcmUoJy4vanN4JykucXVvdGVBdHRyTmFtZTtcblxudmFyIHRyaW1MZWZ0ID0gcmVxdWlyZSgnLi9qc3gnKS50cmltTGVmdDtcblxuLyoqXG4gKiBDdXN0b21pemVkIGRlc3VnYXIgcHJvY2Vzc29yIGZvciBSZWFjdCBKU1guIEN1cnJlbnRseTpcbiAqXG4gKiA8WD4gPC9YPiA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFgsIG51bGwpXG4gKiA8WCBwcm9wPVwiMVwiIC8+ID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoWCwge3Byb3A6ICcxJ30sIG51bGwpXG4gKiA8WCBwcm9wPVwiMlwiPjxZIC8+PC9YPiA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFgsIHtwcm9wOicyJ30sXG4gKiAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoWSwgbnVsbClcbiAqIClcbiAqIDxkaXYgLz4gPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsKVxuICovXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgbm9uLXdoaXRlc3BhY2UvcGFyZW50aGVzaXMgY2hhcmFjdGVyc1xuICovXG52YXIgcmVOb25XaGl0ZVBhcmVuID0gLyhbXlxcc1xcKFxcKV0pL2c7XG5mdW5jdGlvbiBzdHJpcE5vbldoaXRlUGFyZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVOb25XaGl0ZVBhcmVuLCAnJyk7XG59XG5cbnZhciB0YWdDb252ZW50aW9uID0gL15bYS16XXxcXC0vO1xuZnVuY3Rpb24gaXNUYWdOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIHRhZ0NvbnZlbnRpb24udGVzdChuYW1lKTtcbn1cblxuLy8gV2UgYXNzdW1lIHRoYXQgdGhlIE1pdGhyaWwgcnVudGltZSBpcyBhbHJlYWR5IGluIHNjb3BlXG52YXIgbVBhcnRzID0ge1xuICBzdGFydFRhZzogJ20oJyxcbiAgZW5kVGFnOiAnKScsXG4gIHN0YXJ0QXR0cnM6ICcsICcsXG4gIHN0YXJ0Q2hpbGRyZW46ICcsIFsnLFxuICBlbmRDaGlsZHJlbjogJ10nXG59O1xuXG52YXIgY29tcG9uZW50UGFydHMgPSB7XG4gIHN0YXJ0VGFnOiAnbS5jb21wb25lbnQoJyxcbiAgZW5kVGFnOiAnKScsXG4gIHN0YXJ0QXR0cnM6ICcsICcsXG4gIHN0YXJ0Q2hpbGRyZW46ICcsIFsnLFxuICBlbmRDaGlsZHJlbjogJ10nXG59O1xuXG52YXIgcHJlY29tcGlsZVBhcnRzID0ge1xuICBzdGFydFRhZzogJ3t0YWc6ICcsXG4gIGVuZFRhZzogJ30nLFxuICBzdGFydEF0dHJzOiAnLCBhdHRyczogJyxcbiAgc3RhcnRDaGlsZHJlbjogJywgY2hpbGRyZW46IFsnLFxuICBlbmRDaGlsZHJlbjogJ10nXG59O1xuXG5mdW5jdGlvbiB2aXNpdFJlYWN0VGFnKHByZWNvbXBpbGUsIHRyYXZlcnNlLCBvYmplY3QsIHBhdGgsIHN0YXRlKSB7XG4gIHZhciBwYXJ0cyA9IHByZWNvbXBpbGUgPyBwcmVjb21waWxlUGFydHMgOiBtUGFydHM7XG4gIHZhciBvcGVuaW5nRWxlbWVudCA9IG9iamVjdC5vcGVuaW5nRWxlbWVudDtcbiAgdmFyIG5hbWVPYmplY3QgPSBvcGVuaW5nRWxlbWVudC5uYW1lO1xuICB2YXIgYXR0cmlidXRlc09iamVjdCA9IG9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXM7XG5cbiAgdXRpbHMuY2F0Y2h1cChvcGVuaW5nRWxlbWVudC5yYW5nZVswXSwgc3RhdGUsIHRyaW1MZWZ0KTtcblxuICBpZiAobmFtZU9iamVjdC50eXBlID09PSBTeW50YXguSlNYTmFtZXNwYWNlZE5hbWUgJiYgbmFtZU9iamVjdC5uYW1lc3BhY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWVzcGFjZSB0YWdzIGFyZSBub3Qgc3VwcG9ydGVkLiBKU1ggaXMgbm90IFhNTC4nKTtcbiAgfVxuXG4gIHZhciBoYXNBdHRyaWJ1dGVzID0gYXR0cmlidXRlc09iamVjdC5sZW5ndGg7XG5cbiAgdmFyIGhhc0F0TGVhc3RPbmVTcHJlYWRQcm9wZXJ0eSA9IGF0dHJpYnV0ZXNPYmplY3Quc29tZShmdW5jdGlvbihhdHRyKSB7XG4gICAgcmV0dXJuIGF0dHIudHlwZSA9PT0gU3ludGF4LkpTWFNwcmVhZEF0dHJpYnV0ZTtcbiAgfSk7XG5cbiAgLy8gZmlsdGVyIG91dCB3aGl0ZXNwYWNlXG4gIHZhciBjaGlsZHJlblRvUmVuZGVyID0gb2JqZWN0LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiAhKGNoaWxkLnR5cGUgPT09IFN5bnRheC5MaXRlcmFsXG4gICAgICAgICAgICAgJiYgdHlwZW9mIGNoaWxkLnZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICYmIGNoaWxkLnZhbHVlLm1hdGNoKC9eWyBcXHRdKltcXHJcXG5dWyBcXHRcXHJcXG5dKiQvKSk7XG4gIH0pO1xuXG4gIHZhciBsYXN0UmVuZGVyYWJsZUluZGV4O1xuXG4gIGNoaWxkcmVuVG9SZW5kZXIuZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICBpZiAoY2hpbGQudHlwZSAhPT0gU3ludGF4LkpTWEV4cHJlc3Npb25Db250YWluZXIgfHxcbiAgICAgICAgY2hpbGQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguSlNYRW1wdHlFeHByZXNzaW9uKSB7XG4gICAgICBsYXN0UmVuZGVyYWJsZUluZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICB2YXIgaGFzQ2hpbGRyZW4gPSBsYXN0UmVuZGVyYWJsZUluZGV4ICE9PSB1bmRlZmluZWQ7XG5cbiAgaWYgKG5hbWVPYmplY3QudHlwZSA9PT0gU3ludGF4LkpTWElkZW50aWZpZXIgJiYgaXNUYWdOYW1lKG5hbWVPYmplY3QubmFtZSkpIHtcbiAgICB1dGlscy5hcHBlbmQocGFydHMuc3RhcnRUYWcsIHN0YXRlKTtcbiAgICB1dGlscy5hcHBlbmQoJ1wiJyArIG5hbWVPYmplY3QubmFtZSArICdcIicsIHN0YXRlKTtcbiAgICB1dGlscy5tb3ZlKG5hbWVPYmplY3QucmFuZ2VbMV0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGNvbXBvbmVudFBhcnRzO1xuICAgIC8vIFVzZSB1dGlscy5jYXRjaHVwIGluIHRoaXMgY2FzZSBzbyB3ZSBjYW4gZWFzaWx5IGhhbmRsZVxuICAgIC8vIEpTWE1lbWJlckV4cHJlc3Npb25zIHdoaWNoIGxvb2sgbGlrZSBGb28uQmFyLkJhei4gVGhpcyBhbHNvIGhhbmRsZXNcbiAgICAvLyBKU1hJZGVudGlmaWVycyB0aGF0IGFyZW4ndCBmYWxsYmFjayB0YWdzLlxuICAgIGlmIChoYXNBdHRyaWJ1dGVzIHx8IGhhc0NoaWxkcmVuKSB7XG4gICAgICB1dGlscy5hcHBlbmQocGFydHMuc3RhcnRUYWcsIHN0YXRlKTtcbiAgICB9XG4gICAgdXRpbHMubW92ZShuYW1lT2JqZWN0LnJhbmdlWzBdLCBzdGF0ZSk7XG4gICAgdXRpbHMuY2F0Y2h1cChuYW1lT2JqZWN0LnJhbmdlWzFdLCBzdGF0ZSk7XG4gIH1cblxuICAvLyBNaXRocmlsIGV4cGVjdHMgYW4gXCJhdHRyc1wiIHByb3BlcnR5IG9uIHByZS1jb21waWxlZCB0ZW1wbGF0ZXNcbiAgaWYgKGhhc0F0dHJpYnV0ZXMgfHwgcGFydHMgPT09IHByZWNvbXBpbGVQYXJ0cyB8fCBwYXJ0cyA9PT0gY29tcG9uZW50UGFydHMgJiYgaGFzQ2hpbGRyZW4pIHtcbiAgICB1dGlscy5hcHBlbmQocGFydHMuc3RhcnRBdHRycywgc3RhdGUpXG4gIH1cblxuICBpZiAoaGFzQXRMZWFzdE9uZVNwcmVhZFByb3BlcnR5KSB7XG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgT2JqZWN0LmFzc2lnbiBpcyBhdmFpbGFibGUgdG8gbWVyZ2Ugc3ByZWFkIGF0dHJpYnV0ZXNcbiAgICB1dGlscy5hcHBlbmQoJ09iamVjdC5hc3NpZ24oeycsIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChoYXNBdHRyaWJ1dGVzKSB7XG4gICAgdXRpbHMuYXBwZW5kKCd7Jywgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHBhcnRzID09PSBwcmVjb21waWxlUGFydHMgfHwgcGFydHMgPT09IGNvbXBvbmVudFBhcnRzICYmIGhhc0NoaWxkcmVuKSB7XG4gICAgdXRpbHMuYXBwZW5kKCd7fScsIHN0YXRlKTtcbiAgfVxuXG4gIC8vIGtlZXAgdHJhY2sgb2YgaWYgdGhlIHByZXZpb3VzIGF0dHJpYnV0ZSB3YXMgYSBzcHJlYWQgYXR0cmlidXRlXG4gIHZhciBwcmV2aW91c1dhc1NwcmVhZCA9IGZhbHNlO1xuXG4gIC8vIHdyaXRlIGF0dHJpYnV0ZXNcbiAgYXR0cmlidXRlc09iamVjdC5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIsIGluZGV4KSB7XG4gICAgdmFyIGlzTGFzdCA9IGluZGV4ID09PSBhdHRyaWJ1dGVzT2JqZWN0Lmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoYXR0ci50eXBlID09PSBTeW50YXguSlNYU3ByZWFkQXR0cmlidXRlKSB7XG4gICAgICAvLyBDbG9zZSB0aGUgcHJldmlvdXMgb2JqZWN0IG9yIGluaXRpYWwgb2JqZWN0XG4gICAgICBpZiAoIXByZXZpb3VzV2FzU3ByZWFkKSB7XG4gICAgICAgIHV0aWxzLmFwcGVuZCgnfSwgJywgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlIHRvIHRoZSBleHByZXNzaW9uIHN0YXJ0LCBpZ25vcmluZyBldmVyeXRoaW5nIGV4Y2VwdCBwYXJlbnRoZXNpc1xuICAgICAgLy8gYW5kIHdoaXRlc3BhY2UuXG4gICAgICB1dGlscy5jYXRjaHVwKGF0dHIucmFuZ2VbMF0sIHN0YXRlLCBzdHJpcE5vbldoaXRlUGFyZW4pO1xuICAgICAgLy8gUGx1cyAxIHRvIHNraXAgYHtgLlxuICAgICAgdXRpbHMubW92ZShhdHRyLnJhbmdlWzBdICsgMSwgc3RhdGUpO1xuICAgICAgdXRpbHMuY2F0Y2h1cChhdHRyLmFyZ3VtZW50LnJhbmdlWzBdLCBzdGF0ZSwgc3RyaXBOb25XaGl0ZVBhcmVuKTtcblxuICAgICAgdHJhdmVyc2UoYXR0ci5hcmd1bWVudCwgcGF0aCwgc3RhdGUpO1xuXG4gICAgICB1dGlscy5jYXRjaHVwKGF0dHIuYXJndW1lbnQucmFuZ2VbMV0sIHN0YXRlKTtcblxuICAgICAgLy8gTW92ZSB0byB0aGUgZW5kLCBpZ25vcmluZyBwYXJlbnRoZXNpcyBhbmQgdGhlIGNsb3NpbmcgYH1gXG4gICAgICB1dGlscy5jYXRjaHVwKGF0dHIucmFuZ2VbMV0gLSAxLCBzdGF0ZSwgc3RyaXBOb25XaGl0ZVBhcmVuKTtcblxuICAgICAgaWYgKCFpc0xhc3QpIHtcbiAgICAgICAgdXRpbHMuYXBwZW5kKCcsJywgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5tb3ZlKGF0dHIucmFuZ2VbMV0sIHN0YXRlKTtcblxuICAgICAgcHJldmlvdXNXYXNTcHJlYWQgPSB0cnVlO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG5leHQgYXR0cmlidXRlIGlzIGEgc3ByZWFkLCB3ZSdyZSBlZmZlY3RpdmUgbGFzdCBpbiB0aGlzIG9iamVjdFxuICAgIGlmICghaXNMYXN0KSB7XG4gICAgICBpc0xhc3QgPSBhdHRyaWJ1dGVzT2JqZWN0W2luZGV4ICsgMV0udHlwZSA9PT0gU3ludGF4LkpTWFNwcmVhZEF0dHJpYnV0ZTtcbiAgICB9XG5cbiAgICBpZiAoYXR0ci5uYW1lLm5hbWVzcGFjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgJ05hbWVzcGFjZSBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkLiBKU1ggaXMgbm90IFhNTC4nKTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBhdHRyLm5hbWUubmFtZTtcblxuICAgIHV0aWxzLmNhdGNodXAoYXR0ci5yYW5nZVswXSwgc3RhdGUsIHRyaW1MZWZ0KTtcblxuICAgIGlmIChwcmV2aW91c1dhc1NwcmVhZCkge1xuICAgICAgdXRpbHMuYXBwZW5kKCd7Jywgc3RhdGUpO1xuICAgIH1cblxuICAgIHV0aWxzLmFwcGVuZChxdW90ZUF0dHJOYW1lKG5hbWUpLCBzdGF0ZSk7XG4gICAgdXRpbHMuYXBwZW5kKCc6Jywgc3RhdGUpO1xuXG4gICAgaWYgKCFhdHRyLnZhbHVlKSB7XG4gICAgICBzdGF0ZS5nLmJ1ZmZlciArPSAndHJ1ZSc7XG4gICAgICBzdGF0ZS5nLnBvc2l0aW9uID0gYXR0ci5uYW1lLnJhbmdlWzFdO1xuICAgICAgaWYgKCFpc0xhc3QpIHtcbiAgICAgICAgdXRpbHMuYXBwZW5kKCcsJywgc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1dGlscy5tb3ZlKGF0dHIubmFtZS5yYW5nZVsxXSwgc3RhdGUpO1xuICAgICAgLy8gVXNlIGNhdGNodXBOZXdsaW5lcyB0byBza2lwIG92ZXIgdGhlICc9JyBpbiB0aGUgYXR0cmlidXRlXG4gICAgICB1dGlscy5jYXRjaHVwTmV3bGluZXMoYXR0ci52YWx1ZS5yYW5nZVswXSwgc3RhdGUpO1xuICAgICAgaWYgKGF0dHIudmFsdWUudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgcmVuZGVySlNYTGl0ZXJhbChhdHRyLnZhbHVlLCBpc0xhc3QsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlckpTWEV4cHJlc3Npb25Db250YWluZXIodHJhdmVyc2UsIGF0dHIudmFsdWUsIGlzTGFzdCwgcGF0aCwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzLmNhdGNodXAoYXR0ci5yYW5nZVsxXSwgc3RhdGUsIHRyaW1MZWZ0KTtcblxuICAgIHByZXZpb3VzV2FzU3ByZWFkID0gZmFsc2U7XG4gIH0pO1xuXG4gIGlmICghb3BlbmluZ0VsZW1lbnQuc2VsZkNsb3NpbmcpIHtcbiAgICB1dGlscy5jYXRjaHVwKG9wZW5pbmdFbGVtZW50LnJhbmdlWzFdIC0gMSwgc3RhdGUsIHRyaW1MZWZ0KTtcbiAgICB1dGlscy5tb3ZlKG9wZW5pbmdFbGVtZW50LnJhbmdlWzFdLCBzdGF0ZSk7XG4gIH1cblxuICBpZiAoaGFzQXR0cmlidXRlcyAmJiAhcHJldmlvdXNXYXNTcHJlYWQpIHtcbiAgICB1dGlscy5hcHBlbmQoJ30nLCBzdGF0ZSk7XG4gIH1cblxuICBpZiAoaGFzQXRMZWFzdE9uZVNwcmVhZFByb3BlcnR5KSB7XG4gICAgdXRpbHMuYXBwZW5kKCcpJywgc3RhdGUpO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuVG9SZW5kZXIubGVuZ3RoID4gMCkge1xuICAgIGlmIChsYXN0UmVuZGVyYWJsZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHV0aWxzLmFwcGVuZChwYXJ0cy5zdGFydENoaWxkcmVuLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgY2hpbGRyZW5Ub1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgdXRpbHMuY2F0Y2h1cChjaGlsZC5yYW5nZVswXSwgc3RhdGUsIHRyaW1MZWZ0KTtcblxuICAgICAgdmFyIGlzTGFzdCA9IGluZGV4ID49IGxhc3RSZW5kZXJhYmxlSW5kZXg7XG5cbiAgICAgIGlmIChjaGlsZC50eXBlID09PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICByZW5kZXJKU1hMaXRlcmFsKGNoaWxkLCBpc0xhc3QsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gU3ludGF4LkpTWEV4cHJlc3Npb25Db250YWluZXIpIHtcbiAgICAgICAgcmVuZGVySlNYRXhwcmVzc2lvbkNvbnRhaW5lcih0cmF2ZXJzZSwgY2hpbGQsIGlzTGFzdCwgcGF0aCwgc3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhdmVyc2UoY2hpbGQsIHBhdGgsIHN0YXRlKTtcbiAgICAgICAgaWYgKCFpc0xhc3QpIHtcbiAgICAgICAgICB1dGlscy5hcHBlbmQoJywgJywgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmNhdGNodXAoY2hpbGQucmFuZ2VbMV0sIHN0YXRlLCB0cmltTGVmdCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAob3BlbmluZ0VsZW1lbnQuc2VsZkNsb3NpbmcpIHtcbiAgICAvLyBldmVyeXRoaW5nIHVwIHRvIC8+XG4gICAgdXRpbHMuY2F0Y2h1cChvcGVuaW5nRWxlbWVudC5yYW5nZVsxXSAtIDIsIHN0YXRlLCB0cmltTGVmdCk7XG4gICAgdXRpbHMubW92ZShvcGVuaW5nRWxlbWVudC5yYW5nZVsxXSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGV2ZXJ5dGhpbmcgdXAgdG8gPC8gc2RmbGtzamZkPlxuICAgIHV0aWxzLmNhdGNodXAob2JqZWN0LmNsb3NpbmdFbGVtZW50LnJhbmdlWzBdLCBzdGF0ZSwgdHJpbUxlZnQpO1xuICAgIHV0aWxzLm1vdmUob2JqZWN0LmNsb3NpbmdFbGVtZW50LnJhbmdlWzFdLCBzdGF0ZSk7XG4gIH1cblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB1dGlscy5hcHBlbmQocGFydHMuZW5kQ2hpbGRyZW4sIHN0YXRlKTtcbiAgfVxuICBpZiAocGFydHMgIT09IGNvbXBvbmVudFBhcnRzIHx8IGhhc0F0dHJpYnV0ZXMgfHwgaGFzQ2hpbGRyZW4pIHtcbiAgICB1dGlscy5hcHBlbmQocGFydHMuZW5kVGFnLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52aXNpdFJlYWN0VGFnLnRlc3QgPSBmdW5jdGlvbihvYmplY3QsIHBhdGgsIHN0YXRlKSB7XG4gIHJldHVybiBvYmplY3QudHlwZSA9PT0gU3ludGF4LkpTWEVsZW1lbnQ7XG59O1xuXG5leHBvcnRzLnZpc2l0b3JMaXN0ID0gW1xuICB2aXNpdFJlYWN0VGFnXG5dO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuLypnbG9iYWwgZXhwb3J0czp0cnVlKi9cbid1c2Ugc3RyaWN0JztcclxuXG52YXIgU3ludGF4ID0gcmVxdWlyZSgnanN0cmFuc2Zvcm0nKS5TeW50YXg7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdqc3RyYW5zZm9ybS9zcmMvdXRpbHMnKTtcblxuZnVuY3Rpb24gc2hvdWxkQWRkRGlzcGxheU5hbWUob2JqZWN0KSB7XHJcbiAgaWYgKG9iamVjdCAmJlxuICAgICAgb2JqZWN0LnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJlxuICAgICAgb2JqZWN0LmNhbGxlZS50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJlxuICAgICAgb2JqZWN0LmNhbGxlZS5vYmplY3QudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiZcbiAgICAgIG9iamVjdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdSZWFjdCcgJiZcbiAgICAgIG9iamVjdC5jYWxsZWUucHJvcGVydHkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiZcbiAgICAgIG9iamVjdC5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ2NyZWF0ZUNsYXNzJyAmJlxuICAgICAgb2JqZWN0LmFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgb2JqZWN0LmFyZ3VtZW50c1swXS50eXBlID09PSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbikge1xyXG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGRpc3BsYXlOYW1lIHByb3BlcnR5IGlzbid0IGFscmVhZHkgc2V0XG4gICAgdmFyIHByb3BlcnRpZXMgPSBvYmplY3QuYXJndW1lbnRzWzBdLnByb3BlcnRpZXM7XHJcbiAgICB2YXIgc2FmZSA9IHByb3BlcnRpZXMuZXZlcnkoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnR5LmtleS50eXBlID09PSBTeW50YXguSWRlbnRpZmllciA/XG4gICAgICAgIHByb3BlcnR5LmtleS5uYW1lIDpcbiAgICAgICAgcHJvcGVydHkua2V5LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAnZGlzcGxheU5hbWUnO1xuICAgIH0pO1xuICAgIHJldHVybiBzYWZlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXG4vKipcclxuICogSWYgYGV4cHJgIGlzIGFuIElkZW50aWZpZXIgb3IgTWVtYmVyRXhwcmVzc2lvbiBub2RlIG1hZGUgb2YgaWRlbnRpZmllcnMgYW5kXHJcbiAqIGRvdCBhY2Nlc3NlcywgcmV0dXJuIGEgbGlzdCBvZiB0aGUgaWRlbnRpZmllciBwYXJ0cy4gT3RoZXIgbm9kZXMgcmV0dXJuIG51bGwuXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKlxyXG4gKiBNeUNvbXBvbmVudCAtPiBbJ015Q29tcG9uZW50J11cclxuICogbmFtZXNwYWNlLk15Q29tcG9uZW50IC0+IFsnbmFtZXNwYWNlJywgJ015Q29tcG9uZW50J11cclxuICogbmFtZXNwYWNlWydmb28nXSAtPiBudWxsXHJcbiAqIG5hbWVzcGFjZVsnZm9vJ10uYmFyIC0+IFsnYmFyJ11cclxuICovXHJcbmZ1bmN0aW9uIGZsYXR0ZW5JZGVudGlmaWVyT3JNZW1iZXJFeHByZXNzaW9uKGV4cHIpIHtcclxuICBpZiAoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xyXG4gICAgcmV0dXJuIFtleHByLm5hbWVdO1xyXG4gIH0gZWxzZSBpZiAoZXhwci50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbikge1xyXG4gICAgaWYgKCFleHByLmNvbXB1dGVkICYmIGV4cHIucHJvcGVydHkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgdmFyIGZsYXR0ZW5lZE9iamVjdCA9IGZsYXR0ZW5JZGVudGlmaWVyT3JNZW1iZXJFeHByZXNzaW9uKGV4cHIub2JqZWN0KTtcclxuICAgICAgaWYgKGZsYXR0ZW5lZE9iamVjdCkge1xyXG4gICAgICAgIGZsYXR0ZW5lZE9iamVjdC5wdXNoKGV4cHIucHJvcGVydHkubmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZE9iamVjdDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW2V4cHIucHJvcGVydHkubmFtZV07XHJcbiAgICB9XG4gIH1cbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZm9sbG93aW5nOlxuICpcbiAqIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHJlbmRlcjogLi4uXG4gKiB9KTtcbiAqXG4gKiBpbnRvOlxuICpcbiAqIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIGRpc3BsYXlOYW1lOiAnTXlDb21wb25lbnQnLFxuICogICAgcmVuZGVyOiAuLi5cbiAqIH0pO1xuICpcbiAqIEFsc28gY2F0Y2hlczpcbiAqXG4gKiBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKC4uLik7XG4gKiBuYW1lc3BhY2UuTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyguLi4pO1xyXG4gKiBleHBvcnRzLk15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3MoLi4uKTtcbiAqIG1vZHVsZS5leHBvcnRzID0ge015Q29tcG9uZW50OiBSZWFjdC5jcmVhdGVDbGFzcyguLi4pfTtcbiAqL1xuZnVuY3Rpb24gdmlzaXRSZWFjdERpc3BsYXlOYW1lKHRyYXZlcnNlLCBvYmplY3QsIHBhdGgsIHN0YXRlKSB7XG4gIHZhciBsZWZ0LCByaWdodDtcblxuICBpZiAob2JqZWN0LnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgIGxlZnQgPSBvYmplY3QubGVmdDtcbiAgICByaWdodCA9IG9iamVjdC5yaWdodDtcbiAgfSBlbHNlIGlmIChvYmplY3QudHlwZSA9PT0gU3ludGF4LlByb3BlcnR5KSB7XG4gICAgbGVmdCA9IG9iamVjdC5rZXk7XG4gICAgcmlnaHQgPSBvYmplY3QudmFsdWU7XG4gIH0gZWxzZSBpZiAob2JqZWN0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IpIHtcbiAgICBsZWZ0ID0gb2JqZWN0LmlkO1xuICAgIHJpZ2h0ID0gb2JqZWN0LmluaXQ7XG4gIH1cblxuICBpZiAocmlnaHQgJiYgc2hvdWxkQWRkRGlzcGxheU5hbWUocmlnaHQpKSB7XHJcbiAgICB2YXIgZGlzcGxheU5hbWVQYXRoID0gZmxhdHRlbklkZW50aWZpZXJPck1lbWJlckV4cHJlc3Npb24obGVmdCk7XHJcbiAgICBpZiAoZGlzcGxheU5hbWVQYXRoKSB7XHJcbiAgICAgIGlmIChkaXNwbGF5TmFtZVBhdGgubGVuZ3RoID4gMSAmJiBkaXNwbGF5TmFtZVBhdGhbMF0gPT09ICdleHBvcnRzJykge1xyXG4gICAgICAgIGRpc3BsYXlOYW1lUGF0aC5zaGlmdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZVBhdGguam9pbignLicpO1xyXG5cclxuICAgICAgdXRpbHMuY2F0Y2h1cChyaWdodC5hcmd1bWVudHNbMF0ucmFuZ2VbMF0gKyAxLCBzdGF0ZSk7XHJcbiAgICAgIHV0aWxzLmFwcGVuZCgnZGlzcGxheU5hbWU6IFwiJyArIGRpc3BsYXlOYW1lICsgJ1wiLCcsIHN0YXRlKTtcclxuICB9XG4gIH1cbn1cblxudmlzaXRSZWFjdERpc3BsYXlOYW1lLnRlc3QgPSBmdW5jdGlvbihvYmplY3QsIHBhdGgsIHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG9iamVjdC50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gfHxcbiAgICAgIG9iamVjdC50eXBlID09PSBTeW50YXguUHJvcGVydHkgfHxcbiAgICAgIG9iamVjdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yXG4gICAgKTtcbn07XG5cbmV4cG9ydHMudmlzaXRvckxpc3QgPSBbXG4gIHZpc2l0UmVhY3REaXNwbGF5TmFtZVxuXTtcbiIsIi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSovXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGVzNkFycm93RnVuY3Rpb25zID1cclxuICByZXF1aXJlKCdqc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtYXJyb3ctZnVuY3Rpb24tdmlzaXRvcnMnKTtcclxudmFyIGVzNkNsYXNzZXMgPSByZXF1aXJlKCdqc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtY2xhc3MtdmlzaXRvcnMnKTtcbnZhciBlczZEZXN0cnVjdHVyaW5nID1cclxuICByZXF1aXJlKCdqc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtZGVzdHJ1Y3R1cmluZy12aXNpdG9ycycpO1xyXG52YXIgZXM2T2JqZWN0Q29uY2lzZU1ldGhvZCA9XHJcbiAgcmVxdWlyZSgnanN0cmFuc2Zvcm0vdmlzaXRvcnMvZXM2LW9iamVjdC1jb25jaXNlLW1ldGhvZC12aXNpdG9ycycpO1xyXG52YXIgZXM2T2JqZWN0U2hvcnROb3RhdGlvbiA9XHJcbiAgcmVxdWlyZSgnanN0cmFuc2Zvcm0vdmlzaXRvcnMvZXM2LW9iamVjdC1zaG9ydC1ub3RhdGlvbi12aXNpdG9ycycpO1xyXG52YXIgZXM2UmVzdFBhcmFtZXRlcnMgPSByZXF1aXJlKCdqc3RyYW5zZm9ybS92aXNpdG9ycy9lczYtcmVzdC1wYXJhbS12aXNpdG9ycycpO1xudmFyIGVzNlRlbXBsYXRlcyA9IHJlcXVpcmUoJ2pzdHJhbnNmb3JtL3Zpc2l0b3JzL2VzNi10ZW1wbGF0ZS12aXNpdG9ycycpO1xudmFyIGVzNkNhbGxTcHJlYWQgPVxyXG4gIHJlcXVpcmUoJ2pzdHJhbnNmb3JtL3Zpc2l0b3JzL2VzNi1jYWxsLXNwcmVhZC12aXNpdG9ycycpO1xyXG52YXIgZXM3U3ByZWFkUHJvcGVydHkgPVxyXG4gIHJlcXVpcmUoJ2pzdHJhbnNmb3JtL3Zpc2l0b3JzL2VzNy1zcHJlYWQtcHJvcGVydHktdmlzaXRvcnMnKTtcclxudmFyIHJlYWN0ID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1zL3JlYWN0Jyk7XG52YXIgcmVhY3REaXNwbGF5TmFtZSA9IHJlcXVpcmUoJy4vdHJhbnNmb3Jtcy9yZWFjdERpc3BsYXlOYW1lJyk7XG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHJlcXVpcmUoJ2pzdHJhbnNmb3JtL3Zpc2l0b3JzL3Jlc2VydmVkLXdvcmRzLXZpc2l0b3JzJyk7XHJcblxuLyoqXG4gKiBNYXAgZnJvbSB0cmFuc2Zvcm1OYW1lID0+IG9yZGVyZWRMaXN0T2ZWaXNpdG9ycy5cbiAqL1xudmFyIHRyYW5zZm9ybVZpc2l0b3JzID0ge1xuICAnZXM2LWFycm93LWZ1bmN0aW9ucyc6IGVzNkFycm93RnVuY3Rpb25zLnZpc2l0b3JMaXN0LFxuICAnZXM2LWNsYXNzZXMnOiBlczZDbGFzc2VzLnZpc2l0b3JMaXN0LFxuICAnZXM2LWRlc3RydWN0dXJpbmcnOiBlczZEZXN0cnVjdHVyaW5nLnZpc2l0b3JMaXN0LFxuICAnZXM2LW9iamVjdC1jb25jaXNlLW1ldGhvZCc6IGVzNk9iamVjdENvbmNpc2VNZXRob2QudmlzaXRvckxpc3QsXG4gICdlczYtb2JqZWN0LXNob3J0LW5vdGF0aW9uJzogZXM2T2JqZWN0U2hvcnROb3RhdGlvbi52aXNpdG9yTGlzdCxcbiAgJ2VzNi1yZXN0LXBhcmFtcyc6IGVzNlJlc3RQYXJhbWV0ZXJzLnZpc2l0b3JMaXN0LFxuICAnZXM2LXRlbXBsYXRlcyc6IGVzNlRlbXBsYXRlcy52aXNpdG9yTGlzdCxcbiAgJ2VzNi1jYWxsLXNwcmVhZCc6IGVzNkNhbGxTcHJlYWQudmlzaXRvckxpc3QsXHJcbiAgJ2VzNy1zcHJlYWQtcHJvcGVydHknOiBlczdTcHJlYWRQcm9wZXJ0eS52aXNpdG9yTGlzdCxcbiAgJ3JlYWN0JzogcmVhY3QudmlzaXRvckxpc3QuY29uY2F0KHJlYWN0RGlzcGxheU5hbWUudmlzaXRvckxpc3QpLFxyXG4gICdyZXNlcnZlZC13b3Jkcyc6IHJlc2VydmVkV29yZHMudmlzaXRvckxpc3RcclxufTtcblxudmFyIHRyYW5zZm9ybVNldHMgPSB7XG4gICdoYXJtb255JzogW1xuICAgICdlczYtYXJyb3ctZnVuY3Rpb25zJyxcbiAgICAnZXM2LW9iamVjdC1jb25jaXNlLW1ldGhvZCcsXG4gICAgJ2VzNi1vYmplY3Qtc2hvcnQtbm90YXRpb24nLFxuICAgICdlczYtY2xhc3NlcycsXG4gICAgJ2VzNi1yZXN0LXBhcmFtcycsXG4gICAgJ2VzNi10ZW1wbGF0ZXMnLFxuICAgICdlczYtZGVzdHJ1Y3R1cmluZycsXG4gICAgJ2VzNi1jYWxsLXNwcmVhZCcsXHJcbiAgICAnZXM3LXNwcmVhZC1wcm9wZXJ0eSdcbiAgXSxcbiAgJ2VzMyc6IFtcclxuICAgICdyZXNlcnZlZC13b3JkcydcclxuICBdLFxyXG4gICdyZWFjdCc6IFtcbiAgICAncmVhY3QnXG4gIF1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBvcmRlciBpbiB3aGljaCBlYWNoIHRyYW5zZm9ybSBzaG91bGQgcnVuLlxuICovXG52YXIgdHJhbnNmb3JtUnVuT3JkZXIgPSBbXG4gICdyZXNlcnZlZC13b3JkcycsXHJcbiAgJ2VzNi1hcnJvdy1mdW5jdGlvbnMnLFxuICAnZXM2LW9iamVjdC1jb25jaXNlLW1ldGhvZCcsXG4gICdlczYtb2JqZWN0LXNob3J0LW5vdGF0aW9uJyxcbiAgJ2VzNi1jbGFzc2VzJyxcbiAgJ2VzNi1yZXN0LXBhcmFtcycsXG4gICdlczYtdGVtcGxhdGVzJyxcbiAgJ2VzNi1kZXN0cnVjdHVyaW5nJyxcbiAgJ2VzNi1jYWxsLXNwcmVhZCcsXHJcbiAgJ2VzNy1zcHJlYWQtcHJvcGVydHknLFxuICAncmVhY3QnXG5dO1xuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiB0cmFuc2Zvcm0gbmFtZXMsIHJldHVybiB0aGUgb3JkZXJlZCBsaXN0IG9mIHZpc2l0b3JzIHRvIGJlXG4gKiBwYXNzZWQgdG8gdGhlIHRyYW5zZm9ybSgpIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7YXJyYXk/fSBleGNsdWRlc1xuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldEFsbFZpc2l0b3JzKGV4Y2x1ZGVzKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGlsID0gdHJhbnNmb3JtUnVuT3JkZXIubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGlmICghZXhjbHVkZXMgfHwgZXhjbHVkZXMuaW5kZXhPZih0cmFuc2Zvcm1SdW5PcmRlcltpXSkgPT09IC0xKSB7XG4gICAgICByZXQgPSByZXQuY29uY2F0KHRyYW5zZm9ybVZpc2l0b3JzW3RyYW5zZm9ybVJ1bk9yZGVyW2ldXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIHZpc2l0b3Igc2V0IG5hbWVzLCByZXR1cm4gdGhlIG9yZGVyZWQgbGlzdCBvZiB2aXNpdG9ycyB0byBiZVxuICogcGFzc2VkIHRvIGpzdHJhbnNmb3JtLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9XG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0VmlzaXRvcnNCeVNldChzZXRzKSB7XG4gIHZhciB2aXNpdG9yc1RvSW5jbHVkZSA9IHNldHMucmVkdWNlKGZ1bmN0aW9uKHZpc2l0b3JzLCBzZXQpIHtcbiAgICBpZiAoIXRyYW5zZm9ybVNldHMuaGFzT3duUHJvcGVydHkoc2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHZpc2l0b3Igc2V0OiAnICsgc2V0KTtcbiAgICB9XG4gICAgdHJhbnNmb3JtU2V0c1tzZXRdLmZvckVhY2goZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgdmlzaXRvcnNbdmlzaXRvcl0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB2aXNpdG9ycztcbiAgfSwge30pO1xuXG4gIHZhciB2aXNpdG9yTGlzdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybVJ1bk9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHZpc2l0b3JzVG9JbmNsdWRlLmhhc093blByb3BlcnR5KHRyYW5zZm9ybVJ1bk9yZGVyW2ldKSkge1xuICAgICAgdmlzaXRvckxpc3QgPSB2aXNpdG9yTGlzdC5jb25jYXQodHJhbnNmb3JtVmlzaXRvcnNbdHJhbnNmb3JtUnVuT3JkZXJbaV1dKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmlzaXRvckxpc3Q7XG59XG5cbmV4cG9ydHMuZ2V0VmlzaXRvcnNCeVNldCA9IGdldFZpc2l0b3JzQnlTZXQ7XG5leHBvcnRzLmdldEFsbFZpc2l0b3JzID0gZ2V0QWxsVmlzaXRvcnM7XG5leHBvcnRzLnRyYW5zZm9ybVZpc2l0b3JzID0gdHJhbnNmb3JtVmlzaXRvcnM7XG4iLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcbi8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWYqL1xyXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xyXG5cclxuZnVuY3Rpb24gaW5saW5lU291cmNlTWFwKHNvdXJjZU1hcCwgc291cmNlQ29kZSwgc291cmNlRmlsZW5hbWUpIHtcclxuICAvLyBUaGlzIGNhbiBiZSB1c2VkIHdpdGggYSBzb3VyY2VtYXAgdGhhdCBoYXMgYWxyZWFkeSBoYXMgdG9KU09OIGNhbGxlZCBvbiBpdC5cclxuICAvLyBDaGVjayBmaXJzdC5cclxuICB2YXIganNvbiA9IHNvdXJjZU1hcDtcclxuICBpZiAodHlwZW9mIHNvdXJjZU1hcC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGpzb24gPSBzb3VyY2VNYXAudG9KU09OKCk7XHJcbiAgfVxyXG4gIGpzb24uc291cmNlcyA9IFtzb3VyY2VGaWxlbmFtZV07XHJcbiAganNvbi5zb3VyY2VzQ29udGVudCA9IFtzb3VyY2VDb2RlXTtcclxuICB2YXIgYmFzZTY0ID0gQnVmZmVyKEpTT04uc3RyaW5naWZ5KGpzb24pKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcbiAgcmV0dXJuICcvLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBiYXNlNjQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW5saW5lU291cmNlTWFwO1xyXG4iLCJ2YXIgQXBwTGF5b3V0ID0gcmVxdWlyZSgnLi4vY29tbW9uL2xheW91dHMvYXBwX2xheW91dC5qcycpO1xudmFyIEFQSSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zZXJ2aWNlcy9hcGlfc2VydmljZS5qcycpO1xudmFyIEtvcnZhaSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tb2RlbHMva29ydmFpLmpzJyk7XG52YXIgS29ydmFpUmVuZGVyU2VydmljZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zZXJ2aWNlcy9rb3J2YWlfcmVuZGVyX3NlcnZpY2UuanMnKTtcblxudmFyIEtvcnZhaURldGFpbFBhZ2UgPSB7fTtcblxuS29ydmFpRGV0YWlsUGFnZS5jb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2bSA9IHRoaXM7XG5cbiAgbS5zdGFydENvbXB1dGF0aW9uKCk7XG4gIEFQSSgnR0VUJywgJy9rb3J2YWlzLycgKyBtLnJvdXRlLnBhcmFtKCdrb3J2YWlfaWQnKSkudGhlbihmdW5jdGlvbihrb3J2YWlEYXRhKSB7XG4gICAgdm0ua29ydmFpID0gbmV3IEtvcnZhaShrb3J2YWlEYXRhKTtcbiAgICBtLmVuZENvbXB1dGF0aW9uKCk7XG4gIH0pO1xufTtcblxuS29ydmFpRGV0YWlsUGFnZS52aWV3ID0gQXBwTGF5b3V0KGZ1bmN0aW9uKGN0cmwpIHtcbiAgdmFyIGtvcnZhaUh0bWwgPSBLb3J2YWlSZW5kZXJTZXJ2aWNlLnRvTXN4KGN0cmwua29ydmFpLmNvbnRlbnQoKSk7XG5cbiAgcmV0dXJuIChcbiAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2lkOlwiS29ydmFpRGV0YWlsXCJ9LCBjaGlsZHJlbjogW1xuICAgICAge3RhZzogXCJoMVwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbXCJLb3J2YWkgI1wiLCBjdHJsLmtvcnZhaS5pZCgpXX0sIFxuICAgICAga29ydmFpSHRtbFxuICAgIF19XG4gICk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBLb3J2YWlEZXRhaWxQYWdlOyIsInZhciBBcHBMYXlvdXQgPSByZXF1aXJlKCcuLi9jb21tb24vbGF5b3V0cy9hcHBfbGF5b3V0LmpzJyk7XG52YXIgQ3VycmVudFVzZXIgPSByZXF1aXJlKCcuLi9jb21tb24vbW9kZWxzL2N1cnJlbnRfdXNlci5qcycpO1xuXG52YXIgUHJvZmlsZUtvcnZhaXNQYWdlID0ge307XG5cblByb2ZpbGVLb3J2YWlzUGFnZS5jb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMua29ydmFpcyA9IEN1cnJlbnRVc2VyLmtvcnZhaXMoKTtcblxuICB0aGlzLmdvVG9Lb3J2YWkgPSBmdW5jdGlvbihrb3J2YWlJZCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIG0ucm91dGUoJy9rb3J2YWlzLycgKyBrb3J2YWlJZCk7XG4gICAgfVxuICB9O1xufTtcblxuUHJvZmlsZUtvcnZhaXNQYWdlLnZpZXcgPSBBcHBMYXlvdXQoZnVuY3Rpb24oY3RybCkge1xuICB2YXIga29ydmFpcyA9IGN0cmwua29ydmFpcygpLm1hcChmdW5jdGlvbihrb3J2YWksIGluZGV4KSB7XG4gICAgdmFyIHRpdGxlID0gXCJUaGFsYW06IFwiICsga29ydmFpLnRoYWxhbSgpICsgXCIsIE1hdHJhcyBhZnRlcjogXCIgKyBrb3J2YWkubWF0cmFzX2FmdGVyKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAge3RhZzogXCJkaXZcIiwgYXR0cnM6IHtjbGFzczpcInBhbmVsIHBhbmVsLXByaW1hcnlcIiwgb25jbGljazpjdHJsLmdvVG9Lb3J2YWkoa29ydmFpLmlkKCkpfSwgY2hpbGRyZW46IFtcbiAgICAgICAge3RhZzogXCJkaXZcIiwgYXR0cnM6IHtjbGFzczpcInBhbmVsLWhlYWRpbmdcIn0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAge3RhZzogXCJoM1wiLCBhdHRyczoge2NsYXNzOlwicGFuZWwtdGl0bGVcIn0sIGNoaWxkcmVuOiBbdGl0bGVdfVxuICAgICAgICBdfSwgXG4gICAgICAgIHt0YWc6IFwiZGl2XCIsIGF0dHJzOiB7Y2xhc3M6XCJwYW5lbC1ib2R5XCJ9LCBjaGlsZHJlbjogW1xuICAgICAgICAgIGtvcnZhaS5jb250ZW50KClcbiAgICAgICAgXX1cbiAgICAgIF19XG4gICAgKTtcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2lkOlwiUHJvZmlsZUtvcnZhaXNcIn0sIGNoaWxkcmVuOiBbXG4gICAgICB7dGFnOiBcImgxXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFtcIktvcnZhaXMgVmlld1wiXX0sIHt0YWc6IFwiYnJcIiwgYXR0cnM6IHt9fSwgXG4gICAgICBrb3J2YWlzXG4gICAgXX1cbiAgKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVLb3J2YWlzUGFnZTsiLCJ2YXIgQ3VycmVudFVzZXIgPSByZXF1aXJlKCcuLi9jb21tb24vbW9kZWxzL2N1cnJlbnRfdXNlci5qcycpO1xudmFyIEF1dGhTZXJ2aWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3NlcnZpY2VzL2F1dGhfc2VydmljZS5qcycpO1xuXG52YXIgTG9naW5QYWdlID0ge307XG5cbkxvZ2luUGFnZS5jb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2bSA9IHRoaXM7XG5cbiAgdm0uZW1haWwgPSBtLnByb3AoJycpO1xuICB2bS5wYXNzd29yZCA9IG0ucHJvcCgnJyk7XG4gIHZtLmFsZXJ0cyA9IG0ucHJvcChbXSk7XG5cbiAgdm0ubG9naW4gPSBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYodm0uZW1haWwoKSAmJiB2bS5wYXNzd29yZCgpKSB7XG4gICAgICBBdXRoU2VydmljZS5sb2dpbih2bS5lbWFpbCgpLCB2bS5wYXNzd29yZCgpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnQ3VycmVudCB1c2VyIG1vZGVsOiAnLCBDdXJyZW50VXNlcik7XG4gICAgICAgIHZtLmFsZXJ0cygpLnB1c2goXCJMb2dpbiBzdWNjZXNzIVwiKTtcbiAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICB2bS5hbGVydHMoKS5wdXNoKFwiTG9naW4gZmFpbHVyZSFcIik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uYWxlcnRzKCkucHVzaChcIkZpZWxkcyBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICB9XG59O1xuXG5Mb2dpblBhZ2UudmlldyA9IGZ1bmN0aW9uKGN0cmwpIHtcbiAgdmFyIGFsZXJ0cyA9IGN0cmwuYWxlcnRzKCkubWFwKGZ1bmN0aW9uKG1zZywgaW5kZXgpIHtcbiAgICByZXR1cm4gKFxuICAgICAge3RhZzogXCJkaXZcIiwgYXR0cnM6IHtjbGFzczpcImFsZXJ0IGFsZXJ0LXdhcm5pbmcgYWxlcnQtZGlzbWlzc2libGVcIiwgcm9sZTpcImFsZXJ0XCJ9LCBjaGlsZHJlbjogW1xuICAgICAgICB7dGFnOiBcImJ1dHRvblwiLCBhdHRyczoge3R5cGU6XCJidXR0b25cIiwgY2xhc3M6XCJjbG9zZVwiLCBcImRhdGEtZGlzbWlzc1wiOlwiYWxlcnRcIiwgXCJhcmlhLWxhYmVsXCI6XCJDbG9zZVwifSwgY2hpbGRyZW46IFt7dGFnOiBcInNwYW5cIiwgYXR0cnM6IHtcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9LCBjaGlsZHJlbjogW1wiw5dcIl19XX0sIFxuICAgICAgICBtc2dcbiAgICAgIF19XG4gICAgKTtcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2lkOlwiTG9naW5cIn0sIGNoaWxkcmVuOiBbXG4gICAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2NsYXNzOlwiY29udGFpbmVyXCJ9LCBjaGlsZHJlbjogW1xuICAgICAgICB7dGFnOiBcImZvcm1cIiwgYXR0cnM6IHtjbGFzczpcImZvcm0tc2lnbmluXCIsIG9uc3VibWl0OmN0cmwubG9naW59LCBjaGlsZHJlbjogW1xuICAgICAgICAgIHt0YWc6IFwiaDJcIiwgYXR0cnM6IHtjbGFzczpcImZvcm0tc2lnbmluLWhlYWRpbmdcIn0sIGNoaWxkcmVuOiBbXCJQbGVhc2Ugc2lnbiBpblwiXX0sIFxuXG4gICAgICAgICAge3RhZzogXCJsYWJlbFwiLCBhdHRyczoge2ZvcjpcImlucHV0RW1haWxcIiwgY2xhc3M6XCJzci1vbmx5XCJ9LCBjaGlsZHJlbjogW1wiRW1haWwgYWRkcmVzc1wiXX0sIFxuICAgICAgICAgIHt0YWc6IFwiaW5wdXRcIiwgYXR0cnM6IHtcbiAgICAgICAgICAgIHR5cGU6XCJlbWFpbFwiLCBcbiAgICAgICAgICAgIGlkOlwiaW5wdXRFbWFpbFwiLCBcbiAgICAgICAgICAgIGNsYXNzOlwiZm9ybS1jb250cm9sXCIsIFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6XCJFbWFpbCBhZGRyZXNzXCIsIFxuICAgICAgICAgICAgb25jaGFuZ2U6bS53aXRoQXR0cigndmFsdWUnLCBjdHJsLmVtYWlsKSwgXG4gICAgICAgICAgICB2YWx1ZTpjdHJsLmVtYWlsKCksIFxuICAgICAgICAgICAgcmVxdWlyZWQ6dHJ1ZSxhdXRvZm9jdXM6dHJ1ZX19LCBcblxuICAgICAgICAgIHt0YWc6IFwibGFiZWxcIiwgYXR0cnM6IHtmb3I6XCJpbnB1dFBhc3N3b3JkXCIsIGNsYXNzOlwic3Itb25seVwifSwgY2hpbGRyZW46IFtcIlBhc3N3b3JkXCJdfSwgXG4gICAgICAgICAge3RhZzogXCJpbnB1dFwiLCBhdHRyczoge1xuICAgICAgICAgICAgdHlwZTpcInBhc3N3b3JkXCIsIFxuICAgICAgICAgICAgaWQ6XCJpbnB1dFBhc3N3b3JkXCIsIFxuICAgICAgICAgICAgY2xhc3M6XCJmb3JtLWNvbnRyb2xcIiwgXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjpcIlBhc3N3b3JkXCIsIFxuICAgICAgICAgICAgb25jaGFuZ2U6bS53aXRoQXR0cigndmFsdWUnLCBjdHJsLnBhc3N3b3JkKSwgXG4gICAgICAgICAgICB2YWx1ZTpjdHJsLnBhc3N3b3JkKCksIFxuICAgICAgICAgICAgcmVxdWlyZWQ6dHJ1ZX19LCBcblxuICAgICAgICAgIHt0YWc6IFwiZGl2XCIsIGF0dHJzOiB7Y2xhc3M6XCJjaGVja2JveFwifSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHt0YWc6IFwibGFiZWxcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB7dGFnOiBcImlucHV0XCIsIGF0dHJzOiB7dHlwZTpcImNoZWNrYm94XCIsIHZhbHVlOlwicmVtZW1iZXItbWVcIn19LCBcIiBSZW1lbWJlciBtZVwiXG4gICAgICAgICAgICBdfVxuICAgICAgICAgIF19LCBcblxuICAgICAgICAgIHt0YWc6IFwiYnV0dG9uXCIsIGF0dHJzOiB7Y2xhc3M6XCJidG4gYnRuLWxnIGJ0bi1wcmltYXJ5IGJ0bi1ibG9ja1wiLCB0eXBlOlwic3VibWl0XCJ9LCBjaGlsZHJlbjogW1wiU2lnbiBpblwiXX1cbiAgICAgICAgXX0sIFxuXG4gICAgICAgIGFsZXJ0c1xuICAgICAgXX1cbiAgICBdfVxuICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2dpblBhZ2U7IiwidmFyIEFwcExheW91dCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9sYXlvdXRzL2FwcF9sYXlvdXQuanMnKTtcbnZhciBDdXJyZW50VXNlciA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tb2RlbHMvY3VycmVudF91c2VyLmpzJyk7XG5cbnZhciBQcm9maWxlUGFnZSA9IHt9O1xuXG5Qcm9maWxlUGFnZS5jb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudXNlcklkID0gQ3VycmVudFVzZXIuaWQoKTtcbiAgdGhpcy5ncmF2YXRhclVybCA9ICdodHRwOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIvJyArIENyeXB0b0pTLk1ENShDdXJyZW50VXNlci5lbWFpbCgpKSArICc/ZD1tbSZzPTI1Nic7XG59O1xuXG5Qcm9maWxlUGFnZS52aWV3ID0gQXBwTGF5b3V0KGZ1bmN0aW9uKGN0cmwpIHtcbiAgcmV0dXJuIChcbiAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2NsYXNzOlwiY29udGFpbmVyXCIsIGlkOlwiUHJvZmlsZVwifSwgY2hpbGRyZW46IFtcbiAgICAgIHt0YWc6IFwiZGl2XCIsIGF0dHJzOiB7Y2xhc3M6XCJyb3dcIn0sIGNoaWxkcmVuOiBbXG4gICAgICAgIHt0YWc6IFwiZGl2XCIsIGF0dHJzOiB7Y2xhc3M6XCJjb2wtbWQtOCBjb2wteHMtMTBcIn0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAge3RhZzogXCJkaXZcIiwgYXR0cnM6IHtjbGFzczpcIndlbGwgcGFuZWwgcGFuZWwtZGVmYXVsdFwifSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHt0YWc6IFwiZGl2XCIsIGF0dHJzOiB7Y2xhc3M6XCJwYW5lbC1ib2R5XCJ9LCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2NsYXNzOlwicm93XCJ9LCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIHt0YWc6IFwiZGl2XCIsIGF0dHJzOiB7Y2xhc3M6XCJjb2wteHMtMTIgY29sLXNtLTQgdGV4dC1jZW50ZXJcIn0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICB7dGFnOiBcImltZ1wiLCBhdHRyczoge3NyYzpjdHJsLmdyYXZhdGFyVXJsLCBhbHQ6XCJQcm9maWxlIHBpY3R1cmVcIiwgY2xhc3M6XCJjZW50ZXItYmxvY2sgaW1nLWNpcmNsZSBpbWctdGh1bWJuYWlsIGltZy1yZXNwb25zaXZlXCJ9fSwgXG4gICAgICAgICAgICAgICAgICB7dGFnOiBcInVsXCIsIGF0dHJzOiB7Y2xhc3M6XCJsaXN0LWlubGluZSByYXRpbmdzIHRleHQtY2VudGVyXCIsIHRpdGxlOlwiUmF0aW5nc1wifSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAge3RhZzogXCJsaVwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbe3RhZzogXCJhXCIsIGF0dHJzOiB7aHJlZjpcIiNcIn0sIGNoaWxkcmVuOiBbe3RhZzogXCJzcGFuXCIsIGF0dHJzOiB7Y2xhc3M6XCJmYSBmYS1zdGFyIGZhLWxnXCJ9fV19XX0sIFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiBcImxpXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFt7dGFnOiBcImFcIiwgYXR0cnM6IHtocmVmOlwiI1wifSwgY2hpbGRyZW46IFt7dGFnOiBcInNwYW5cIiwgYXR0cnM6IHtjbGFzczpcImZhIGZhLXN0YXIgZmEtbGdcIn19XX1dfSwgXG4gICAgICAgICAgICAgICAgICAgIHt0YWc6IFwibGlcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW3t0YWc6IFwiYVwiLCBhdHRyczoge2hyZWY6XCIjXCJ9LCBjaGlsZHJlbjogW3t0YWc6IFwic3BhblwiLCBhdHRyczoge2NsYXNzOlwiZmEgZmEtc3RhciBmYS1sZ1wifX1dfV19LCBcbiAgICAgICAgICAgICAgICAgICAge3RhZzogXCJsaVwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbe3RhZzogXCJhXCIsIGF0dHJzOiB7aHJlZjpcIiNcIn0sIGNoaWxkcmVuOiBbe3RhZzogXCJzcGFuXCIsIGF0dHJzOiB7Y2xhc3M6XCJmYSBmYS1zdGFyIGZhLWxnXCJ9fV19XX0sIFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiBcImxpXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFt7dGFnOiBcImFcIiwgYXR0cnM6IHtocmVmOlwiI1wifSwgY2hpbGRyZW46IFt7dGFnOiBcInNwYW5cIiwgYXR0cnM6IHtjbGFzczpcImZhIGZhLXN0YXIgZmEtbGdcIn19XX1dfVxuICAgICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICBdfSwgXG5cbiAgICAgICAgICAgICAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2NsYXNzOlwiY29sLXhzLTEyIGNvbC1zbS04XCJ9LCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAge3RhZzogXCJoMlwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbY3RybC51c2VySWRdfSwgXG4gICAgICAgICAgICAgICAgICB7dGFnOiBcInBcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW3t0YWc6IFwic3Ryb25nXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFtcIkFib3V0OiBcIl19LCBcIiBXZWIgRGVzaWduZXIgLyBVSSBFeHBlcnQuIFwiXX0sIFxuICAgICAgICAgICAgICAgICAge3RhZzogXCJwXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFt7dGFnOiBcInN0cm9uZ1wiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbXCJIb2JiaWVzOiBcIl19LCBcIiBSZWFkLCBvdXQgd2l0aCBmcmllbmRzLCBsaXN0ZW4gdG8gbXVzaWMsIGRyYXcgYW5kIGxlYXJuIG5ldyB0aGluZ3MuIFwiXX0sIFxuICAgICAgICAgICAgICAgICAge3RhZzogXCJwXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFt7dGFnOiBcInN0cm9uZ1wiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbXCJTa2lsbHM6IFwiXX0sIFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiBcInNwYW5cIiwgYXR0cnM6IHtjbGFzczpcImxhYmVsIGxhYmVsLWluZm8gdGFnc1wifSwgY2hpbGRyZW46IFtcImh0bWw1XCJdfSwgXG4gICAgICAgICAgICAgICAgICAgIHt0YWc6IFwic3BhblwiLCBhdHRyczoge2NsYXNzOlwibGFiZWwgbGFiZWwtaW5mbyB0YWdzXCJ9LCBjaGlsZHJlbjogW1wiY3NzM1wiXX0sIFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiBcInNwYW5cIiwgYXR0cnM6IHtjbGFzczpcImxhYmVsIGxhYmVsLWluZm8gdGFnc1wifSwgY2hpbGRyZW46IFtcImpxdWVyeVwiXX0sIFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiBcInNwYW5cIiwgYXR0cnM6IHtjbGFzczpcImxhYmVsIGxhYmVsLWluZm8gdGFnc1wifSwgY2hpbGRyZW46IFtcImJvb3RzdHJhcDNcIl19XG4gICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgIF19LCBcblxuICAgICAgICAgICAgICAgIHt0YWc6IFwiZGl2XCIsIGF0dHJzOiB7Y2xhc3M6XCJjbGVhcmZpeFwifX0sIFxuICAgICAgICAgICAgICAgIHt0YWc6IFwiZGl2XCIsIGF0dHJzOiB7Y2xhc3M6XCJjb2wteHMtMTIgY29sLXNtLTRcIn0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICB7dGFnOiBcImgyXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFt7dGFnOiBcInN0cm9uZ1wiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbXCIgMjAsN0sgXCJdfV19LCBcbiAgICAgICAgICAgICAgICAgIHt0YWc6IFwicFwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbe3RhZzogXCJzbWFsbFwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbXCJGb2xsb3dlcnNcIl19XX0sIFxuICAgICAgICAgICAgICAgICAge3RhZzogXCJidXR0b25cIiwgYXR0cnM6IHtjbGFzczpcImJ0biBidG4tc3VjY2VzcyBidG4tYmxvY2tcIn0sIGNoaWxkcmVuOiBbe3RhZzogXCJzcGFuXCIsIGF0dHJzOiB7Y2xhc3M6XCJmYSBmYS1wbHVzLWNpcmNsZVwifX0sIFwiIEZvbGxvdyBcIl19XG4gICAgICAgICAgICAgICAgXX0sIFxuXG4gICAgICAgICAgICAgICAge3RhZzogXCJkaXZcIiwgYXR0cnM6IHtjbGFzczpcImNvbC14cy0xMiBjb2wtc20tNFwifSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgIHt0YWc6IFwiaDJcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW3t0YWc6IFwic3Ryb25nXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFtcIjI0NVwiXX1dfSwgXG4gICAgICAgICAgICAgICAgICB7dGFnOiBcInBcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW3t0YWc6IFwic21hbGxcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW1wiRm9sbG93aW5nXCJdfV19LCBcbiAgICAgICAgICAgICAgICAgIHt0YWc6IFwiYnV0dG9uXCIsIGF0dHJzOiB7Y2xhc3M6XCJidG4gYnRuLWluZm8gYnRuLWJsb2NrXCJ9LCBjaGlsZHJlbjogW3t0YWc6IFwic3BhblwiLCBhdHRyczoge2NsYXNzOlwiZmEgZmEtdXNlclwifX0sIFwiIFZpZXcgUHJvZmlsZSBcIl19XG4gICAgICAgICAgICAgICAgXX0sIFxuXG4gICAgICAgICAgICAgICAge3RhZzogXCJkaXZcIiwgYXR0cnM6IHtjbGFzczpcImNvbC14cy0xMiBjb2wtc20tNFwifSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgIHt0YWc6IFwiaDJcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW3t0YWc6IFwic3Ryb25nXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFtcIjQzXCJdfV19LCBcbiAgICAgICAgICAgICAgICAgIHt0YWc6IFwicFwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbe3RhZzogXCJzbWFsbFwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbXCJTbmlwcGV0c1wiXX1dfSwgXG4gICAgICAgICAgICAgICAgICB7dGFnOiBcImJ1dHRvblwiLCBhdHRyczoge3R5cGU6XCJidXR0b25cIiwgY2xhc3M6XCJidG4gYnRuLXByaW1hcnkgYnRuLWJsb2NrXCJ9LCBjaGlsZHJlbjogW3t0YWc6IFwic3BhblwiLCBhdHRyczoge2NsYXNzOlwiZmEgZmEtZ2VhclwifX0sIFwiIE9wdGlvbnMgXCJdfVxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgIF19XG4gICAgICAgICAgICBdfVxuICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgICBdfVxuICAgIF19XG4gICk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9maWxlUGFnZTsiLCJ2YXIgTG9naW5QYWdlID0gcmVxdWlyZSgnLi9Mb2dpbi9sb2dpbi5qcycpO1xudmFyIFByb2ZpbGVQYWdlID0gcmVxdWlyZSgnLi9Qcm9maWxlL3Byb2ZpbGUuanMnKTtcbnZhciBQcm9maWxlS29ydmFpc1BhZ2UgPSByZXF1aXJlKCcuL0tvcnZhaXMva29ydmFpTGlzdC5qcycpO1xudmFyIEtvcnZhaURldGFpbFBhZ2UgPSByZXF1aXJlKCcuL0tvcnZhaXMva29ydmFpRGV0YWlsLmpzJyk7XG5cbnZhciBDdXJyZW50VXNlciA9IHJlcXVpcmUoJy4vY29tbW9uL21vZGVscy9jdXJyZW50X3VzZXIuanMnKTtcblxudmFyIEF1dGhlbnRpY2F0ZWQgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGVkLmNvbnRyb2xsZXIobW9kdWxlKTsgfSxcbiAgICB2aWV3OiBBdXRoZW50aWNhdGVkLnZpZXdcbiAgfTtcbn07XG5cbkF1dGhlbnRpY2F0ZWQuY29udHJvbGxlciA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICBpZighQ3VycmVudFVzZXIuaWQoKSkgbS5yb3V0ZSgnL2xvZ2luJyk7XG4gIGVsc2UgdGhpcy5jb250ZW50ID0gbW9kdWxlLnZpZXcuYmluZCh0aGlzLCBuZXcgbW9kdWxlLmNvbnRyb2xsZXIpO1xufTtcblxuQXV0aGVudGljYXRlZC52aWV3ID0gZnVuY3Rpb24oY3RybCkge1xuICByZXR1cm4gbShcIiNBdXRoZW50aWNhdGVkXCIsIGN0cmwuY29udGVudCgpKTtcbn07XG5cbi8vIGhlbHBlcnNcblxuU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihudW0pIHtcbiAgcmV0dXJuIG5ldyBBcnJheShudW0gKyAxKS5qb2luKHRoaXMpO1xufTtcblxuU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQWxsID0gZnVuY3Rpb24oZmluZCwgcmVwbGFjZSkge1xuICByZXR1cm4gdGhpcy5yZXBsYWNlKG5ldyBSZWdFeHAoZmluZCwgJ2cnKSwgcmVwbGFjZSk7XG59O1xuXG5BcnJheS5wcm90b3R5cGUucmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24oYWNjdW0sIGN1cnJlbnQpIHtcbiAgICBpZihhY2N1bS5pbmRleE9mKGN1cnJlbnQpIDwgMCkgYWNjdW0ucHVzaChjdXJyZW50KTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH0sIFtdKTtcbn07XG5cbi8vIHJvdXRlc1xuXG5tLnJvdXRlLm1vZGUgPSAnaGFzaCc7XG5tLnJvdXRlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSwgJy9sb2dpbicsIHtcbiAgJy9sb2dpbic6IExvZ2luUGFnZSxcblxuICAnL2tvcnZhaXMnOiBBdXRoZW50aWNhdGVkKFByb2ZpbGVLb3J2YWlzUGFnZSksXG4gICcva29ydmFpcy86a29ydmFpX2lkJzogQXV0aGVudGljYXRlZChLb3J2YWlEZXRhaWxQYWdlKSxcblxuICAnL21lJzogQXV0aGVudGljYXRlZChQcm9maWxlUGFnZSlcbn0pOyIsInZhciBDdXJyZW50VXNlciA9IHJlcXVpcmUoJy4uL21vZGVscy9jdXJyZW50X3VzZXIuanMnKTtcblxudmFyIEhlYWRlciA9IHt9O1xuXG5IZWFkZXIuY29udHJvbGxlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnVzZXJJZCA9IEN1cnJlbnRVc2VyLmlkKCk7XG59O1xuXG5IZWFkZXIudmlldyA9IGZ1bmN0aW9uKGN0cmwpIHtcbiAgcmV0dXJuIChcbiAgICB7dGFnOiBcIm5hdlwiLCBhdHRyczoge2NsYXNzOlwibmF2YmFyIG5hdmJhci1pbnZlcnNlIG5hdmJhci1maXhlZC10b3BcIiwgaWQ6XCJIZWFkZXJcIn0sIGNoaWxkcmVuOiBbXG4gICAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2NsYXNzOlwiY29udGFpbmVyLWZsdWlkXCJ9LCBjaGlsZHJlbjogW1xuICAgICAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2NsYXNzOlwibmF2YmFyLWhlYWRlclwifSwgY2hpbGRyZW46IFtcbiAgICAgICAgICB7dGFnOiBcImJ1dHRvblwiLCBhdHRyczoge3R5cGU6XCJidXR0b25cIiwgY2xhc3M6XCJuYXZiYXItdG9nZ2xlIGNvbGxhcHNlZFwiLCBcImRhdGEtdG9nZ2xlXCI6XCJjb2xsYXBzZVwiLCBcImRhdGEtdGFyZ2V0XCI6XCIjbmF2YmFyXCIsIFwiYXJpYS1leHBhbmRlZFwiOlwiZmFsc2VcIiwgXCJhcmlhLWNvbnRyb2xzXCI6XCJuYXZiYXJcIn0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB7dGFnOiBcInNwYW5cIiwgYXR0cnM6IHtjbGFzczpcInNyLW9ubHlcIn0sIGNoaWxkcmVuOiBbXCJUb2dnbGUgbmF2aWdhdGlvblwiXX0sIFxuICAgICAgICAgICAge3RhZzogXCJzcGFuXCIsIGF0dHJzOiB7Y2xhc3M6XCJpY29uLWJhclwifX0sIFxuICAgICAgICAgICAge3RhZzogXCJzcGFuXCIsIGF0dHJzOiB7Y2xhc3M6XCJpY29uLWJhclwifX0sIFxuICAgICAgICAgICAge3RhZzogXCJzcGFuXCIsIGF0dHJzOiB7Y2xhc3M6XCJpY29uLWJhclwifX1cbiAgICAgICAgICBdfSwgXG4gICAgICAgICAge3RhZzogXCJhXCIsIGF0dHJzOiB7Y2xhc3M6XCJuYXZiYXItYnJhbmRcIiwgaHJlZjpcIiNcIiwgaWQ6XCJsb2dvXCJ9LCBjaGlsZHJlbjogW1wiQ2FybmF0aWNcIl19XG4gICAgICAgIF19LCBcblxuICAgICAgICB7dGFnOiBcImRpdlwiLCBhdHRyczoge2lkOlwibmF2YmFyXCIsIGNsYXNzOlwibmF2YmFyLWNvbGxhcHNlIGNvbGxhcHNlXCJ9LCBjaGlsZHJlbjogW1xuICAgICAgICAgIHt0YWc6IFwidWxcIiwgYXR0cnM6IHtjbGFzczpcIm5hdiBuYXZiYXItbmF2IG5hdmJhci1yaWdodFwifSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHt0YWc6IFwibGlcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW3t0YWc6IFwiYVwiLCBhdHRyczoge2hyZWY6XCIjXCJ9LCBjaGlsZHJlbjogW1wiRGFzaGJvYXJkXCJdfV19LCBcbiAgICAgICAgICAgIHt0YWc6IFwibGlcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW3t0YWc6IFwiYVwiLCBhdHRyczoge2hyZWY6XCIjXCJ9LCBjaGlsZHJlbjogW1wiU2V0dGluZ3NcIl19XX0sIFxuICAgICAgICAgICAge3RhZzogXCJsaVwiLCBhdHRyczoge30sIGNoaWxkcmVuOiBbe3RhZzogXCJhXCIsIGF0dHJzOiB7aHJlZjpcIiNcIn0sIGNoaWxkcmVuOiBbXCJQcm9maWxlXCJdfV19LCBcbiAgICAgICAgICAgIHt0YWc6IFwibGlcIiwgYXR0cnM6IHt9LCBjaGlsZHJlbjogW3t0YWc6IFwiYVwiLCBhdHRyczoge2hyZWY6XCIjXCJ9LCBjaGlsZHJlbjogW1wiSGVscFwiXX1dfSwgXG4gICAgICAgICAgICB7dGFnOiBcImxpXCIsIGF0dHJzOiB7Y2xhc3M6XCJkaXZpZGVyXCJ9fSwgXG4gICAgICAgICAgICB7dGFnOiBcImxpXCIsIGF0dHJzOiB7fSwgY2hpbGRyZW46IFt7dGFnOiBcImFcIiwgYXR0cnM6IHtocmVmOlwiIy9tZVwifSwgY2hpbGRyZW46IFtjdHJsLnVzZXJJZF19XX1cbiAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgICAgXX1cbiAgICBdfVxuICApO1xufTtcblxudmFyIEFwcExheW91dCA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGN0cmwpIHtcbiAgICByZXR1cm4gKFxuICAgICAge3RhZzogXCJkaXZcIiwgYXR0cnM6IHtpZDpcIkFwcExheW91dFwifSwgY2hpbGRyZW46IFtcbiAgICAgICAgSGVhZGVyLCBcbiAgICAgICAge3RhZzogXCJkaXZcIiwgYXR0cnM6IHtjbGFzczpcImNvbnRhaW5lci1mbHVpZFwifSwgY2hpbGRyZW46IFtcbiAgICAgICAgICB2aWV3KGN0cmwpXG4gICAgICAgIF19XG4gICAgICBdfVxuICAgICk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcExheW91dDsiLCJ2YXIgQVBJID0gcmVxdWlyZSgnLi4vc2VydmljZXMvYXBpX3NlcnZpY2UuanMnKTtcbnZhciBLb3J2YWkgPSByZXF1aXJlKCcuLi9tb2RlbHMva29ydmFpLmpzJyk7XG52YXIgUHJvZmlsZSA9IHJlcXVpcmUoJy4uL21vZGVscy9wcm9maWxlLmpzJyk7XG5cbnZhciBDdXJyZW50VXNlciA9IChmdW5jdGlvbigpe1xuICB2YXIgbG9jYWxVc2VyRGF0YSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Nhcm5hdGljLWN1cnJlbnRVc2VyJykpIHx8IHt9O1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IG0ucHJvcChsb2NhbFVzZXJEYXRhLmlkIHx8ICcnKSxcbiAgICBlbWFpbDogbS5wcm9wKGxvY2FsVXNlckRhdGEuZW1haWwgfHwgJycpLFxuICAgIGF1dGhfdG9rZW46IG0ucHJvcChsb2NhbFVzZXJEYXRhLmF1dGhfdG9rZW4gfHwgJycpXG4gIH07XG59KCkpO1xuXG5DdXJyZW50VXNlci5yZXNldCA9IGZ1bmN0aW9uKHVzZXJEYXRhKSB7XG4gIEN1cnJlbnRVc2VyLmlkKHVzZXJEYXRhLmlkKTtcbiAgQ3VycmVudFVzZXIuZW1haWwodXNlckRhdGEuZW1haWwpO1xuICBDdXJyZW50VXNlci5hdXRoX3Rva2VuKHVzZXJEYXRhLmF1dGhfdG9rZW4pO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY2FybmF0aWMtY3VycmVudFVzZXInLCBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSkpO1xufTtcblxuQ3VycmVudFVzZXIucHJvZmlsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQVBJKCdHRVQnLCAnL3VzZXJzLycgKyBDdXJyZW50VXNlci5pZCgpICsgJy9wcm9maWxlJykudGhlbihmdW5jdGlvbihwcm9maWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9maWxlKHByb2ZpbGUpO1xuICB9KTtcbn07XG5cbkN1cnJlbnRVc2VyLmtvcnZhaXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFQSSgnR0VUJywgJy91c2Vycy8nICsgQ3VycmVudFVzZXIuaWQoKSArICcva29ydmFpcycpLnRoZW4oZnVuY3Rpb24oa29ydmFpcykge1xuICAgIHJldHVybiBrb3J2YWlzLm1hcChmdW5jdGlvbihrLCBpbmRleCkge3JldHVybiBuZXcgS29ydmFpKGspfSk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXJyZW50VXNlcjsiLCJ2YXIgS29ydmFpID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmlkID0gbS5wcm9wKGRhdGEuaWQgfHwgMCk7XG4gIHRoaXMudXNlcl9pZCA9IG0ucHJvcChkYXRhLnVzZXJfaWQgfHwgMCk7XG4gIHRoaXMuY29udGVudCA9IG0ucHJvcChkYXRhLmNvbnRlbnQgfHwgJycpO1xuICB0aGlzLnRoYWxhbSA9IG0ucHJvcChkYXRhLnRoYWxhbSB8fCAzMik7XG4gIHRoaXMubWF0cmFzX2FmdGVyID0gbS5wcm9wKGRhdGEubWF0cmFzQWZ0ZXIgfHwgMCk7XG4gIHRoaXMuY3JlYXRlZF9hdCA9IG0ucHJvcChkYXRhLmNyZWF0ZWRfYXQgfHwgJycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLb3J2YWk7IiwidmFyIFByb2ZpbGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuaWQgPSBtLnByb3AoZGF0YS5pZCB8fCAwKTtcbiAgdGhpcy51c2VyX2lkID0gbS5wcm9wKGRhdGEudXNlcl9pZCB8fCAwKTtcbiAgdGhpcy5uYW1lID0gbS5wcm9wKGRhdGEubmFtZSB8fCAnJyk7XG4gIHRoaXMucGljdHVyZV91cmwgPSBtLnByb3AoZGF0YS5waWN0dXJlX3VybCB8fCAzMik7XG4gIHRoaXMuY3JlYXRlZF9hdCA9IG0ucHJvcChkYXRhLmNyZWF0ZWRfYXQgfHwgJycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9maWxlOyIsIi8vIHJlcXVpcmVzIG1ldGhvZCAoZS5nLiBHRVQsIFBPU1QsIGV0Yy4pXG4vLyByZXF1aXJlcyB1cmwgKGUuZy4gJy91c2Vycy8xJylcbi8vIG9wdGlvbmFsIGRhdGEgKGphdmFzY3JpcHQgb2JqZWN0KVxuLy8gb3B0aW9uYWwgYXV0aF90b2tlbiAoaWYgYXV0aGVudGljYXRpb24gaXMgcmVxdWlyZWQpXG52YXIgQVBJID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGRhdGEsIGF1dGhfdG9rZW4pIHtcbiAgdmFyIHhockNvbmZpZyA9IGZ1bmN0aW9uKHhocikge1xuICAgIGlmKGF1dGhfdG9rZW4pIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBdXRoZW50aWNhdGlvbjogVG9rZW4gJywgYXV0aF90b2tlbik7XG4gIH07XG5cbiAgcmV0dXJuIG0ucmVxdWVzdCh7XG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgdXJsOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyArIHVybCxcbiAgICBkYXRhOiBkYXRhIHx8IHt9LFxuICAgIGNvbmZpZzogeGhyQ29uZmlnXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBUEk7IiwidmFyIEN1cnJlbnRVc2VyID0gcmVxdWlyZSgnLi4vbW9kZWxzL2N1cnJlbnRfdXNlci5qcycpO1xuXG52YXIgQXV0aFNlcnZpY2UgPSB7XG4gIGxvZ2luOiBmdW5jdGlvbihlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICBtLnN0YXJ0Q29tcHV0YXRpb24oKTtcblxuICAgIHJldHVybiBtLnJlcXVlc3Qoe21ldGhvZDogJ1BPU1QnLCB1cmw6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvdXNlcnMvbG9naW4nLCBkYXRhOiB7XG4gICAgICBlbWFpbDogZW1haWwsXG4gICAgICBwYXNzd29yZDogcGFzc3dvcmRcbiAgICB9fSkudGhlbihmdW5jdGlvbih1c2VyRGF0YSkge1xuICAgICAgY29uc29sZS5sb2coXCJsb2dpbiBzdWNjZXNzOiBcIiwgdXNlckRhdGEpO1xuICAgICAgQ3VycmVudFVzZXIucmVzZXQodXNlckRhdGEpO1xuICAgICAgbS5lbmRDb21wdXRhdGlvbigpO1xuICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImxvZ2luIGZhaWx1cmU6IFwiLCBlcnJvcik7XG4gICAgICBtLmVuZENvbXB1dGF0aW9uKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aFNlcnZpY2U7IiwidmFyIE1hdHJhc1NlcnZpY2UgPSByZXF1aXJlKCcuL21hdHJhc19zZXJ2aWNlLmpzJyk7XG52YXIgbXN4ID0gcmVxdWlyZSgnbXN4Jyk7XG5cbnZhciBLb3J2YWlSZW5kZXJTZXJ2aWNlID0ge1xuICB0b01zeDogZnVuY3Rpb24oa29ydmFpKSB7XG4gICAgcmV0dXJuIGV2YWwoJygnICsgbXN4LnRyYW5zZm9ybSh0aGlzLnJlbmRlckhUTUwoa29ydmFpKSkgKyAnKScpO1xuICB9LFxuXG4gIHJlbmRlckhUTUw6IGZ1bmN0aW9uKGtvcnZhaSkge1xuICAgIHJldHVybiAnPGRpdiBpZD1cImtvcnZhaS1jb250ZW50XCI+JyArIHRoaXMua29ydmFpVG9IVE1MKGtvcnZhaSkgKyAnPC9kaXY+JztcbiAgfSxcblxuICAvLyAtLS0tLS0tLSBQUklWQVRFIC0tLS0tLS0tXG5cbiAgY29udmVydFJlcGVhdGVyOiBmdW5jdGlvbihyKSB7XG4gICAgdmFyIGxhc3RTbGFzaCA9IHIubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmKGxhc3RTbGFzaCA9PSAtMSkgcmV0dXJuO1xuXG4gICAgdmFyIHJTdHJpbmcgPSByLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpO1xuICAgIHZhciByZXBlYXRlcnMgPSBNYXRyYXNTZXJ2aWNlLmZpbmRNb2RpZmllcnMoclN0cmluZywgXCIoXCIsIFwiKVwiKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCByZXBlYXRlcnMubGVuZ3RoOyBpKyspXG4gICAgICByU3RyaW5nID0gdGhpcy5yZXBsYWNlUmVwZWF0ZXIoclN0cmluZywgcmVwZWF0ZXJzW2ldKTtcblxuICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJtb2RpZmllci1icmFja2V0XCI+KDwvc3Bhbj4nICsgclN0cmluZyArICc8c3BhbiBjbGFzcz1cIm1vZGlmaWVyLWJyYWNrZXRcIj4pPC9zcGFuPiDDlycgKyByLnNsaWNlKGxhc3RTbGFzaCArIDEpO1xuICB9LFxuXG4gIHJlcGxhY2VSZXBlYXRlcjogZnVuY3Rpb24oc3RyLCByKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFwiKFwiICsgciArIFwiKVwiLCB0aGlzLmNvbnZlcnRSZXBlYXRlcihyKSk7XG4gIH0sXG5cbiAgY29udmVydE5hZGFpOiBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGxhc3RTbGFzaCA9IG4ubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmKGxhc3RTbGFzaCA9PSAtMSkgcmV0dXJuO1xuXG4gICAgdmFyIG5TdHJpbmcgPSBuLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpO1xuICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJtb2RpZmllci1icmFja2V0XCI+Wzwvc3Bhbj4nICsgblN0cmluZyArICc8c3BhbiBjbGFzcz1cIm1vZGlmaWVyLWJyYWNrZXRcIj5dPC9zcGFuPiDihpIgJyArIHRoaXMubnVtYmVyVG9OYWRhaShwYXJzZUludChuLnNsaWNlKGxhc3RTbGFzaCArIDEpKSk7XG4gIH0sXG5cbiAgbnVtYmVyVG9OYWRhaTogZnVuY3Rpb24obnVtKSB7XG4gICAgc3dpdGNoKG51bSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gXCJ0aGlzcmFtXCI7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBcImNoYXR1c3JhbVwiO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gXCJrYW5kYW1cIjtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuIFwibWFlbCB0aGlzcmFtXCI7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJldHVybiBcIm1pc3JhbVwiO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gXCJtYWVsIGNoYXR1c3JhbVwiO1xuICAgICAgY2FzZSA5OlxuICAgICAgICByZXR1cm4gXCJzYW5rZWVybmFtXCI7XG4gICAgfVxuICB9LFxuXG4gIGdyYWJDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZUFsbChcIjxicj5cIiwgXCJcXG5cIik7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgY29udGVudCA9IGRpdi50ZXh0Q29udGVudCB8fCBkaXYuaW5uZXJUZXh0IHx8IFwiXCI7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH0sXG5cbiAga29ydmFpVG9IVE1MOiBmdW5jdGlvbihrb3J2YWkpIHtcbiAgICBpZihrb3J2YWkgPT0gXCJcIiB8fCBrb3J2YWkgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgXG4gICAgLy8gVE9ETzogdW5kZXJzdGFuZCB3aHkgeW91IG5lZWQgNCBiYWNrc2xhc2hlcyBmb3IgdGhlIG5ld2xpbmUgcmVwbGFjZVxuICAgIGtvcnZhaSA9IGtvcnZhaS5yZXBsYWNlQWxsKFwiLFwiLCBcIiAsIFwiKS5yZXBsYWNlQWxsKFwiO1wiLCBcIiA7IFwiKS5yZXBsYWNlQWxsKFwiXFxcXFxcXFxuXCIsIFwiIFxcbiBcIik7XG4gICAgdmFyIGtvcnZhaVdvcmRzID0ga29ydmFpLm1hdGNoKC8oW2EtekEtWl0rKS9nKS5yZW1vdmVEdXBsaWNhdGVzKCk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwga29ydmFpV29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0ga29ydmFpV29yZHNbaV07XG4gICAgICBrb3J2YWkgPSBrb3J2YWkucmVwbGFjZUFsbChcIlxcXFxiXCIgKyB3b3JkICsgXCJcXFxcYlwiLCBcIiBcIiArIHdvcmQgKyBcIjxzdXA+XCIgKyBNYXRyYXNTZXJ2aWNlLndvcmRNYXRyYXMod29yZCkgKyBcIjwvc3VwPiBcIik7XG4gICAgfVxuXG4gICAgdmFyIHJlcGVhdGVycyA9IE1hdHJhc1NlcnZpY2UuZmluZE1vZGlmaWVycyhrb3J2YWksIFwiKFwiLCBcIilcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHJlcGVhdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHIgPSByZXBlYXRlcnNbaV07XG4gICAgICBrb3J2YWkgPSBrb3J2YWkucmVwbGFjZShcIihcIiArIHIgKyBcIilcIiwgdGhpcy5jb252ZXJ0UmVwZWF0ZXIocikpO1xuICAgIH1cblxuICAgIHZhciBuYWRhaXMgPSBNYXRyYXNTZXJ2aWNlLmZpbmRNb2RpZmllcnMoa29ydmFpLCBcIltcIiwgXCJdXCIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5hZGFpc1tpXTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IG5hZGFpc1tpXTtcbiAgICAgIGtvcnZhaSA9IGtvcnZhaS5yZXBsYWNlKFwiW1wiICsgbiArIFwiXVwiLCB0aGlzLmNvbnZlcnROYWRhaShuKSk7XG4gICAgfVxuXG4gICAga29ydmFpID0ga29ydmFpLnJlcGxhY2VBbGwoXCJcXG5cIiwgXCI8YnIgLz5cIik7XG5cbiAgICByZXR1cm4ga29ydmFpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtvcnZhaVJlbmRlclNlcnZpY2U7IiwidmFyIE1hdHJhc1NlcnZpY2UgPSB7XG4gIC8vIGZpbmRNb2RpZmllcnMoc3RyLCBvQnJhY2tldCwgY0JyYWNrZXQpIHByb2R1Y2VzIGFuIGFycmF5IG9mIGFsbCB0aGVcbiAgLy8gY29udGVudCBvZiB0aGUgXCJtb2RpZmllcnNcIiBpbiB0aGUgZ2l2ZW4ga29ydmFpIHN0cmluZywgd2hlcmUgYSBtb2RpZmllclxuICAvLyBpcyBlaXRoZXIgYSByZXBlYXRlciBvciBuYWRhaVxuICAvLyBhIHJlcGVhdGVyIGlzIG9mIHRoZSBmb3JtIFwiKHRoYXRoaW5raW5hdGhvbSAvMylcIiB3aXRoIHBhcmVudGhlc2VzXG4gIC8vIGEgbmFkYWkgaXMgb2YgdGhlIGZvcm0gXCJbdGhhdGhpbmtpbmF0aG9tIC8zXVwiIHdpdGggc3F1YXJlIGJyYWNrZXRzXG4gIC8vIFRPRE86IGNsZWFuIHRoaXMgdXAsIGl0J3MgdmVyeSBtZXNzeVxuICBmaW5kTW9kaWZpZXJzOiBmdW5jdGlvbihzdHIsIG9CcmFja2V0LCBjQnJhY2tldCkge1xuICAgIHZhciBlbmRQb3MgPSAtMTtcbiAgICB2YXIgbW9kaWZpZXJzID0gW107XG5cbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICB3aGlsZShzdHIuY2hhckF0KGVuZFBvcyArIDEpICE9IG9CcmFja2V0ICYmIGVuZFBvcyA8IHN0ci5sZW5ndGgpIGVuZFBvcysrO1xuICAgICAgaWYoZW5kUG9zID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXG4gICAgICB2YXIgb3BlbkJyYWNrZXRzID0gMDtcbiAgICAgIHZhciBzdGFydFBvcyA9IGVuZFBvcztcblxuICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBjaHIgPSBzdHIuY2hhckF0KCsrZW5kUG9zKTtcblxuICAgICAgICBpZihjaHIgPT0gb0JyYWNrZXQpIG9wZW5CcmFja2V0cysrO1xuICAgICAgICBlbHNlIGlmKGNociA9PSBjQnJhY2tldCkgb3BlbkJyYWNrZXRzLS07XG5cbiAgICAgICAgaWYoIShvcGVuQnJhY2tldHMgPiAwICYmIGVuZFBvcyA8IHN0ci5sZW5ndGgpKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYoZW5kUG9zID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXG4gICAgICBtb2RpZmllcnMucHVzaChzdHIuc3Vic3RyaW5nKHN0YXJ0UG9zICsgMiwgZW5kUG9zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGlmaWVycztcbiAgfSxcblxuICAvLyByZXBlYXRTdHJpbmcocikgY29uc3VtZXMgYSByZXBlYXRlciAoYXMgZGVmaW5lZCBhYm92ZSlcbiAgLy8gYW5kIHByb2R1Y2VzIHRoZSByZXBlYXRlZCBzZXF1ZW5jZSBhcyBhIHN0cmluZyAob3IgZmFsc2UgaWYgbm90IGZvdW5kKVxuICAvLyBlLmcuICh0aGF0aGlua2luYXRob20gLzMpIHByb2R1Y2VzIFwidGhhdGhpbmtpbmF0aG9tIHRoYXRoaW5raW5hdGhvbSB0aGF0aGlua2luYXRob20gXCJcbiAgcmVwZWF0U3RyaW5nOiBmdW5jdGlvbihyKSB7XG4gICAgdmFyIGxhc3RTbGFzaCA9IHIubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmKGxhc3RTbGFzaCA9PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHJTdHJpbmcgPSByLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpO1xuICAgIHZhciByZXBlYXRlcnMgPSB0aGlzLmZpbmRNb2RpZmllcnMoclN0cmluZywgXCIoXCIsIFwiKVwiKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCByZXBlYXRlcnMubGVuZ3RoOyBpKyspXG4gICAgICByU3RyaW5nID0gdGhpcy5yZXBsYWNlUmVwZWF0ZXIoclN0cmluZywgcmVwZWF0ZXJzW2ldKTtcblxuICAgIHZhciBudW1PZlJlcGVhdHMgPSBwYXJzZUludChyLnNsaWNlKGxhc3RTbGFzaCArIDEpKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gclN0cmluZy5yZXBlYXQobnVtT2ZSZXBlYXRzKTtcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6IEludmFsaWQgcmVwZWF0ZXIgc3ludGF4OiBcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJTdHJpbmc7XG4gICAgfVxuICB9LFxuXG4gIC8vIHJlcGxhY2VSZXBlYXRlcihzdHIsIHIpIHJlcGxhY2VzIHRoZSBvY2N1cnJlbmNlcyBvZiB0aGUgcmVwZWF0ZXJcbiAgLy8gaW4gdGhlIGdpdmVuIHN0cmluZ1xuICByZXBsYWNlUmVwZWF0ZXI6IGZ1bmN0aW9uKHN0ciwgcikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShcIihcIiArIHIgKyBcIilcIiwgdGhpcy5yZXBlYXRTdHJpbmcocikpO1xuICB9LFxuXG4gIC8vIHJlcGVhdGVyTWF0cmFzKHIpIGNvdW50cyB0aGUgbnVtYmVyIG9mIG1hdHJhcyBpbiB0aGUgZ2l2ZW4gcmVwZWF0ZXJcbiAgcmVwZWF0ZXJNYXRyYXM6IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRyYXNXaXRob3V0TW9kaWZpZXJzKHRoaXMucmVwZWF0U3RyaW5nKHIpKTtcbiAgfSxcblxuICBuYWRhaU1hdHJhczogZnVuY3Rpb24obikge1xuICAgIHZhciBsYXN0U2xhc2ggPSBuLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZihsYXN0U2xhc2ggPT0gLTEpIHJldHVybjtcblxuICAgIHZhciBuU3RyaW5nID0gbi5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKTtcblxuICAgIHJldHVybiB0aGlzLmNvdW50TWF0cmFzKG5TdHJpbmcsIGZhbHNlKSAqIDQgLyBwYXJzZUludChuLnNsaWNlKGxhc3RTbGFzaCArIDEpKTtcbiAgfSxcblxuICB3b3JkTWF0cmFzOiBmdW5jdGlvbih3b3JkKSB7XG4gICAgdmFyIHZvd2VscyA9IHdvcmQubWF0Y2goL1thZWlvdV0vZyk7XG4gICAgaWYodm93ZWxzKSByZXR1cm4gdm93ZWxzLmxlbmd0aDtcbiAgICBlbHNlIHJldHVybiAwO1xuICB9LFxuXG4gIG1hdHJhc1dpdGhvdXRNb2RpZmllcnM6IGZ1bmN0aW9uKGtvcnZhaSkge1xuICAgIHZhciBtYXRyYXMgPSAwO1xuICAgIHZhciBrb3J2YWlXb3JkcyA9IGtvcnZhaS5yZXBsYWNlKC8oXFxyXFxufFxcbnxcXHIpL2dtLCAnICcpLnNwbGl0KCcgJyk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwga29ydmFpV29yZHMubGVuZ3RoOyBpKyspXG4gICAgICBtYXRyYXMgKz0gdGhpcy53b3JkTWF0cmFzKGtvcnZhaVdvcmRzW2ldKTtcblxuICAgIHZhciBjb21tYXMgPSBrb3J2YWkubWF0Y2goLywvZyk7XG4gICAgbWF0cmFzICs9IChjb21tYXMgPyBjb21tYXMubGVuZ3RoIDogMCk7XG5cbiAgICB2YXIgc2VtaWNvbG9ucyA9IGtvcnZhaS5tYXRjaCgvOy9nKTtcbiAgICBtYXRyYXMgKz0gKHNlbWljb2xvbnMgPyBzZW1pY29sb25zLmxlbmd0aCAqIDIgOiAwKTtcblxuICAgIHJldHVybiBtYXRyYXM7XG4gIH0sXG5cbiAgLy8gY291bnRNYXRyYXMoa29ydmFpKSBjb3VudHMgdGhlIG51bWJlciBvZiBtYXRyYXMgaW4gdGhlIGtvcnZhaVxuICAvLyBUT0RPOiB0aGlzIG9ubHkgd29ya3MgZm9yIDJuZCBzcGVlZFxuICBjb3VudE1hdHJhczogZnVuY3Rpb24oa29ydmFpLCBoYXNOYWRhaXMpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuaW5uZXJIVE1MID0ga29ydmFpO1xuICAgIGtvcnZhaSA9IGRpdi50ZXh0Q29udGVudCB8fCBkaXYuaW5uZXJUZXh0IHx8ICcnO1xuXG4gICAgdmFyIG1hdHJhcyA9IDA7XG5cbiAgICBpZihoYXNOYWRhaXMpIHtcbiAgICAgIHZhciBuYWRhaXMgPSB0aGlzLmZpbmRNb2RpZmllcnMoa29ydmFpLCBcIltcIiwgXCJdXCIpO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbmFkYWlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hdHJhcyArPSB0aGlzLm5hZGFpTWF0cmFzKG5hZGFpc1tpXSk7XG4gICAgICAgIGtvcnZhaSA9IGtvcnZhaS5yZXBsYWNlKFwiW1wiICsgbmFkYWlzW2ldICsgXCJdXCIsICcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVwZWF0ZXJzID0gdGhpcy5maW5kTW9kaWZpZXJzKGtvcnZhaSwgXCIoXCIsIFwiKVwiKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCByZXBlYXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hdHJhcyArPSB0aGlzLnJlcGVhdGVyTWF0cmFzKHJlcGVhdGVyc1tpXSk7XG4gICAgICBrb3J2YWkgPSBrb3J2YWkucmVwbGFjZShcIihcIiArIHIgKyBcIilcIiwgJycpO1xuICAgIH1cblxuICAgIG1hdHJhcyArPSB0aGlzLm1hdHJhc1dpdGhvdXRNb2RpZmllcnMoa29ydmFpKTtcbiAgICByZXR1cm4gbWF0cmFzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdHJhc1NlcnZpY2U7Il19
